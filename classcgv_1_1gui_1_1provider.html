<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cgv: cgv::gui::provider Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cgv
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classcgv_1_1gui_1_1provider.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="classcgv_1_1gui_1_1provider-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cgv::gui::provider Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>derive from this class to provide a gui to the current viewer  
 <a href="classcgv_1_1gui_1_1provider.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="provider_8h_source.html">provider.h</a>&gt;</code></p>

<p>Inherits tacker.</p>

<p>Inherited by cgv::gui::base_provider, vr_emulator, and vr_test.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
interface used by the parent gui</h2></td></tr>
<tr class="memitem:afffb2e23a58a488448a175e6275c9e7b"><td class="memItemLeft" align="right" valign="top"><a id="afffb2e23a58a488448a175e6275c9e7b"></a>
<a class="el" href="namespacecgv_1_1gui.html#a24b531058de9d4333ab8541c302587d7">gui_group_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#afffb2e23a58a488448a175e6275c9e7b">parent_group</a></td></tr>
<tr class="memdesc:afffb2e23a58a488448a175e6275c9e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">driver specific handle for the group gui element managing the gui built in the provider <br /></td></tr>
<tr class="separator:afffb2e23a58a488448a175e6275c9e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab51c3efb4addaae6f9ab79e6f5d2f641"><td class="memItemLeft" align="right" valign="top"><a id="ab51c3efb4addaae6f9ab79e6f5d2f641"></a>
<a class="el" href="classcgv_1_1gui_1_1provider.html">provider</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>parent_provider</b></td></tr>
<tr class="separator:ab51c3efb4addaae6f9ab79e6f5d2f641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac301065501736a49cc5ac35b06c05e0f"><td class="memItemLeft" align="right" valign="top"><a id="ac301065501736a49cc5ac35b06c05e0f"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#ac301065501736a49cc5ac35b06c05e0f">gui_group</a></td></tr>
<tr class="memdesc:ac301065501736a49cc5ac35b06c05e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">make the gui group a friend class <br /></td></tr>
<tr class="separator:ac301065501736a49cc5ac35b06c05e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f6cb9fa8994a14fdb5bf70cba90093"><td class="memItemLeft" align="right" valign="top"><a id="aa6f6cb9fa8994a14fdb5bf70cba90093"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#aa6f6cb9fa8994a14fdb5bf70cba90093">set_parent</a> (<a class="el" href="namespacecgv_1_1gui.html#a24b531058de9d4333ab8541c302587d7">gui_group_ptr</a>)</td></tr>
<tr class="memdesc:aa6f6cb9fa8994a14fdb5bf70cba90093"><td class="mdescLeft">&#160;</td><td class="mdescRight">the gui window sets the parent group through this method <br /></td></tr>
<tr class="separator:aa6f6cb9fa8994a14fdb5bf70cba90093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845b81cb3d12858b7b70a2b00105c72f"><td class="memItemLeft" align="right" valign="top"><a id="a845b81cb3d12858b7b70a2b00105c72f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a845b81cb3d12858b7b70a2b00105c72f">update_parent</a> ()</td></tr>
<tr class="memdesc:a845b81cb3d12858b7b70a2b00105c72f"><td class="mdescLeft">&#160;</td><td class="mdescRight">update the parent group <br /></td></tr>
<tr class="separator:a845b81cb3d12858b7b70a2b00105c72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056110300cb3a821afbc5ae5f934a557"><td class="memItemLeft" align="right" valign="top"><a id="a056110300cb3a821afbc5ae5f934a557"></a>
<a class="el" href="namespacecgv_1_1gui.html#a24b531058de9d4333ab8541c302587d7">gui_group_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a056110300cb3a821afbc5ae5f934a557">get_parent_group</a> () const</td></tr>
<tr class="memdesc:a056110300cb3a821afbc5ae5f934a557"><td class="mdescLeft">&#160;</td><td class="mdescRight">use the parent group to append to be managed elements that should be destroyed in a post_recreate_gui event <br /></td></tr>
<tr class="separator:a056110300cb3a821afbc5ae5f934a557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e631f03ab8c729b5a97ef9effc0df4"><td class="memItemLeft" align="right" valign="top"><a id="a56e631f03ab8c729b5a97ef9effc0df4"></a>
<a class="el" href="namespacecgv_1_1gui.html#aceb07fba6859effc2353f70788dd7f9b">view_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a56e631f03ab8c729b5a97ef9effc0df4">add_view_void</a> (const std::string &amp;label, const void *value_ptr, const std::string &amp;value_type, const std::string &amp;gui_type, const std::string &amp;options, const std::string &amp;<a class="el" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>)</td></tr>
<tr class="memdesc:a56e631f03ab8c729b5a97ef9effc0df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a newly created view to the group <br /></td></tr>
<tr class="separator:a56e631f03ab8c729b5a97ef9effc0df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaee067e53371e254a7e8a2ae6e0dd72"><td class="memItemLeft" align="right" valign="top"><a id="abaee067e53371e254a7e8a2ae6e0dd72"></a>
<a class="el" href="namespacecgv_1_1gui.html#aebf3fd94311cb8a2bcffb4634f1e73b1">control_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#abaee067e53371e254a7e8a2ae6e0dd72">add_control_void</a> (const std::string &amp;label, void *value_ptr, <a class="el" href="structcgv_1_1gui_1_1abst__control__provider.html">abst_control_provider</a> *acp, const std::string &amp;value_type, const std::string &amp;gui_type, const std::string &amp;options, const std::string &amp;<a class="el" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>, void *user_data)</td></tr>
<tr class="memdesc:abaee067e53371e254a7e8a2ae6e0dd72"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a newly created control to the group <br /></td></tr>
<tr class="separator:abaee067e53371e254a7e8a2ae6e0dd72"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
creation of gui</h2></td></tr>
<tr class="memitem:a28af4e659bdd1825f3829263e15ce5ae"><td class="memItemLeft" align="right" valign="top"><a id="a28af4e659bdd1825f3829263e15ce5ae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a> (const std::string &amp;_align)</td></tr>
<tr class="memdesc:a28af4e659bdd1825f3829263e15ce5ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">send pure alignment information <br /></td></tr>
<tr class="separator:a28af4e659bdd1825f3829263e15ce5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90fe8e7ea3ff452a8148cc779111512a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a90fe8e7ea3ff452a8148cc779111512a">concat_enum_def</a> (const std::vector&lt; std::string &gt; &amp;names, const std::string &amp;additional_first_name=&quot;&quot;, const std::string &amp;additional_last_name=&quot;&quot;)</td></tr>
<tr class="memdesc:a90fe8e7ea3ff452a8148cc779111512a"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a new group to the given parent group, not supported yet  <a href="classcgv_1_1gui_1_1provider.html#a90fe8e7ea3ff452a8148cc779111512a">More...</a><br /></td></tr>
<tr class="separator:a90fe8e7ea3ff452a8148cc779111512a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f82aa4b9a568ca39bff1c1fa2fc637a"><td class="memItemLeft" align="right" valign="top"><a id="a4f82aa4b9a568ca39bff1c1fa2fc637a"></a>
<a class="el" href="namespacecgv_1_1gui.html#a24b531058de9d4333ab8541c302587d7">gui_group_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>add_object_gui</b> (base_ptr object, const std::string &amp;label, const std::string &amp;group_type, const std::string &amp;options, const std::string &amp;<a class="el" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>)</td></tr>
<tr class="separator:a4f82aa4b9a568ca39bff1c1fa2fc637a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3302fad2cb441f3c26c2979c2c064b51"><td class="memItemLeft" align="right" valign="top"><a id="a3302fad2cb441f3c26c2979c2c064b51"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a3302fad2cb441f3c26c2979c2c064b51">integrate_object_gui</a> (base_ptr object)</td></tr>
<tr class="memdesc:a3302fad2cb441f3c26c2979c2c064b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">call this in <a class="el" href="classcgv_1_1gui_1_1provider.html#a1d2f0b6c734c04d3c90a1c51ffbc0de9" title="you must overload this for gui creation">create_gui()</a> function to integrate gui of another provider object by setting the parent group and parent provider of the other object <br /></td></tr>
<tr class="separator:a3302fad2cb441f3c26c2979c2c064b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d293603edad6ffd9a84303f67d6060a"><td class="memItemLeft" align="right" valign="top"><a id="a6d293603edad6ffd9a84303f67d6060a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a6d293603edad6ffd9a84303f67d6060a">inline_object_gui</a> (base_ptr object)</td></tr>
<tr class="memdesc:a6d293603edad6ffd9a84303f67d6060a"><td class="mdescLeft">&#160;</td><td class="mdescRight">integrate (if not explicitly done before) and inline the gui of another object that must be derived from provider <br /></td></tr>
<tr class="separator:a6d293603edad6ffd9a84303f67d6060a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79595103df6c363aba76db5ce49312ce"><td class="memItemLeft" align="right" valign="top"><a id="a79595103df6c363aba76db5ce49312ce"></a>
<a class="el" href="namespacecgv_1_1gui.html#a24b531058de9d4333ab8541c302587d7">gui_group_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a79595103df6c363aba76db5ce49312ce">add_group</a> (const std::string &amp;label, const std::string &amp;group_type, const std::string &amp;options=&quot;&quot;, const std::string &amp;<a class="el" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>=&quot;\n&quot;)</td></tr>
<tr class="memdesc:a79595103df6c363aba76db5ce49312ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a newly created subgroup to the group <br /></td></tr>
<tr class="separator:a79595103df6c363aba76db5ce49312ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f624e9a95eb0b58dff0ac2a10fb6ed9"><td class="memItemLeft" align="right" valign="top"><a id="a5f624e9a95eb0b58dff0ac2a10fb6ed9"></a>
base_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a5f624e9a95eb0b58dff0ac2a10fb6ed9">add_decorator</a> (const std::string &amp;label, const std::string &amp;decorator_type, const std::string &amp;options=&quot;&quot;, const std::string &amp;<a class="el" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>=&quot;\n&quot;)</td></tr>
<tr class="memdesc:a5f624e9a95eb0b58dff0ac2a10fb6ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a newly created decorator to the group <br /></td></tr>
<tr class="separator:a5f624e9a95eb0b58dff0ac2a10fb6ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4c2c18d5da07d5dadfececde56e48e"><td class="memItemLeft" align="right" valign="top"><a id="aec4c2c18d5da07d5dadfececde56e48e"></a>
<a class="el" href="namespacecgv_1_1gui.html#aa04f44687debf1768006e544f64815b8">button_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#aec4c2c18d5da07d5dadfececde56e48e">add_button</a> (const std::string &amp;label, const std::string &amp;options=&quot;&quot;, const std::string &amp;<a class="el" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>=&quot;\n&quot;)</td></tr>
<tr class="memdesc:aec4c2c18d5da07d5dadfececde56e48e"><td class="mdescLeft">&#160;</td><td class="mdescRight">use the current gui driver to append a new button with the given label <br /></td></tr>
<tr class="separator:aec4c2c18d5da07d5dadfececde56e48e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131206860106d3d07078508006151b7e"><td class="memTemplParams" colspan="2"><a id="a131206860106d3d07078508006151b7e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a131206860106d3d07078508006151b7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; <a class="el" href="classcgv_1_1gui_1_1view.html">view</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a131206860106d3d07078508006151b7e">add_view</a> (const std::string &amp;label, const T &amp;value, const std::string &amp;gui_type=&quot;&quot;, const std::string &amp;options=&quot;&quot;, const std::string &amp;<a class="el" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>=&quot;\n&quot;)</td></tr>
<tr class="memdesc:a131206860106d3d07078508006151b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">use this to add a new view to the gui with a given value type, gui type and init options <br /></td></tr>
<tr class="separator:a131206860106d3d07078508006151b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5d812a9dc6b4132b67d0077cc6e22f"><td class="memTemplParams" colspan="2"><a id="ace5d812a9dc6b4132b67d0077cc6e22f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ace5d812a9dc6b4132b67d0077cc6e22f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; <a class="el" href="classcgv_1_1gui_1_1control.html">control</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#ace5d812a9dc6b4132b67d0077cc6e22f">add_control</a> (const std::string &amp;label, T &amp;value, const std::string &amp;gui_type=&quot;&quot;, const std::string &amp;options=&quot;&quot;, const std::string &amp;<a class="el" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>=&quot;\n&quot;)</td></tr>
<tr class="memdesc:ace5d812a9dc6b4132b67d0077cc6e22f"><td class="mdescLeft">&#160;</td><td class="mdescRight">use this to add a new control to the gui with a given value type, gui type and init options <br /></td></tr>
<tr class="separator:ace5d812a9dc6b4132b67d0077cc6e22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accde83e8bacb794c0c912334c5a743e4"><td class="memTemplParams" colspan="2"><a id="accde83e8bacb794c0c912334c5a743e4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:accde83e8bacb794c0c912334c5a743e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; <a class="el" href="classcgv_1_1gui_1_1control.html">control</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#accde83e8bacb794c0c912334c5a743e4">add_control</a> (const std::string &amp;label, <a class="el" href="structcgv_1_1gui_1_1control__provider.html">control_provider</a>&lt; T &gt; *<a class="el" href="classcgv_1_1gui_1_1provider.html">provider</a>, const std::string &amp;gui_type=&quot;&quot;, const std::string &amp;options=&quot;&quot;, const std::string &amp;<a class="el" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>=&quot;\n&quot;, void *user_data=0)</td></tr>
<tr class="memdesc:accde83e8bacb794c0c912334c5a743e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">use this to add a new control to the gui, where the control is implemented with a control provider class <br /></td></tr>
<tr class="separator:accde83e8bacb794c0c912334c5a743e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b62a00070bd3dcdb8962da4f1921b0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af1b62a00070bd3dcdb8962da4f1921b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; <a class="el" href="classcgv_1_1gui_1_1control.html">control</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#af1b62a00070bd3dcdb8962da4f1921b0">add_member_control</a> (<a class="el" href="classcgv_1_1base_1_1base.html">cgv::base::base</a> *base_ptr, const std::string &amp;label, T &amp;value, const std::string &amp;gui_type=&quot;&quot;, const std::string &amp;options=&quot;&quot;, const std::string &amp;<a class="el" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>=&quot;\n&quot;)</td></tr>
<tr class="memdesc:af1b62a00070bd3dcdb8962da4f1921b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">add control with callback to cgv::base::on_set method on <a class="el" href="classcgv_1_1gui_1_1control.html#a49af8e128fc1e8443b95adbddfed009a" title="this signal is sent after the user triggered a change of value and the check_value succeeded.">cgv::gui::control::value_change</a>  <a href="classcgv_1_1gui_1_1provider.html#af1b62a00070bd3dcdb8962da4f1921b0">More...</a><br /></td></tr>
<tr class="separator:af1b62a00070bd3dcdb8962da4f1921b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d52460406852908aeaceb573cbd00e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a71d52460406852908aeaceb573cbd00e">add_tree_node</a> (const std::string &amp;label, bool &amp;toggle, int level, const std::string &amp;a=&quot;\n&quot;, gui_group_ptr ggp=<a class="el" href="namespacecgv_1_1gui.html#a24b531058de9d4333ab8541c302587d7">gui_group_ptr</a>())</td></tr>
<tr class="memdesc:a71d52460406852908aeaceb573cbd00e"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a collapsable node to the gui (deprecated)  <a href="classcgv_1_1gui_1_1provider.html#a71d52460406852908aeaceb573cbd00e">More...</a><br /></td></tr>
<tr class="separator:a71d52460406852908aeaceb573cbd00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ba041ea08c3e6e3a93e76995f706aa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a62ba041ea08c3e6e3a93e76995f706aa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a62ba041ea08c3e6e3a93e76995f706aa">begin_tree_node</a> (const std::string &amp;label, const T &amp;value, bool initial_visibility=false, const std::string &amp;options=&quot;&quot;, <a class="el" href="namespacecgv_1_1gui.html#a24b531058de9d4333ab8541c302587d7">gui_group_ptr</a> ggp=<a class="el" href="namespacecgv_1_1gui.html#a24b531058de9d4333ab8541c302587d7">gui_group_ptr</a>())</td></tr>
<tr class="memdesc:a62ba041ea08c3e6e3a93e76995f706aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin a sub tree of a tree structured gui.  <a href="classcgv_1_1gui_1_1provider.html#a62ba041ea08c3e6e3a93e76995f706aa">More...</a><br /></td></tr>
<tr class="separator:a62ba041ea08c3e6e3a93e76995f706aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bac0aa7c0467b606a3cbe9311f3d17c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9bac0aa7c0467b606a3cbe9311f3d17c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a9bac0aa7c0467b606a3cbe9311f3d17c">end_tree_node</a> (const T &amp;value)</td></tr>
<tr class="separator:a9bac0aa7c0467b606a3cbe9311f3d17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb085cf7522a281e61dd30041654c8c"><td class="memTemplParams" colspan="2"><a id="aadb085cf7522a281e61dd30041654c8c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aadb085cf7522a281e61dd30041654c8c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#aadb085cf7522a281e61dd30041654c8c">is_tree_node_visible</a> (const T &amp;value) const</td></tr>
<tr class="memdesc:aadb085cf7522a281e61dd30041654c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether the sub tree attached to a value is visible <br /></td></tr>
<tr class="separator:aadb085cf7522a281e61dd30041654c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb70e048faeac605a62847f681c201b"><td class="memTemplParams" colspan="2"><a id="a3bb70e048faeac605a62847f681c201b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3bb70e048faeac605a62847f681c201b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a3bb70e048faeac605a62847f681c201b">set_tree_node_visibility</a> (const T &amp;value, bool is_visible)</td></tr>
<tr class="memdesc:a3bb70e048faeac605a62847f681c201b"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the visibility status of sub tree attached to a value. This calls the post_recreate method if needed. <br /></td></tr>
<tr class="separator:a3bb70e048faeac605a62847f681c201b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a782d2dc8ba7aab891b7139bc8f5be"><td class="memItemLeft" align="right" valign="top"><a id="a21a782d2dc8ba7aab891b7139bc8f5be"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a21a782d2dc8ba7aab891b7139bc8f5be">begin_tree_node_void</a> (const std::string &amp;label, const void *value_ptr, int index=-1, bool initial_visibility=false, const std::string &amp;options=&quot;&quot;, <a class="el" href="namespacecgv_1_1gui.html#a24b531058de9d4333ab8541c302587d7">gui_group_ptr</a> ggp=<a class="el" href="namespacecgv_1_1gui.html#a24b531058de9d4333ab8541c302587d7">gui_group_ptr</a>())</td></tr>
<tr class="memdesc:a21a782d2dc8ba7aab891b7139bc8f5be"><td class="mdescLeft">&#160;</td><td class="mdescRight">void version of the templated functions <br /></td></tr>
<tr class="separator:a21a782d2dc8ba7aab891b7139bc8f5be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b8490e597634729bb37cb370483de7d"><td class="memItemLeft" align="right" valign="top"><a id="a7b8490e597634729bb37cb370483de7d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>end_tree_node_void</b> (const void *value_ptr, int index=-1)</td></tr>
<tr class="separator:a7b8490e597634729bb37cb370483de7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4ae3f1f4b0582371447cceb86d286e"><td class="memItemLeft" align="right" valign="top"><a id="a6c4ae3f1f4b0582371447cceb86d286e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_tree_node_visible_void</b> (const void *value_ptr, int index) const</td></tr>
<tr class="separator:a6c4ae3f1f4b0582371447cceb86d286e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f634cc86cdcb2a65aa1921bd461a1fe"><td class="memItemLeft" align="right" valign="top"><a id="a8f634cc86cdcb2a65aa1921bd461a1fe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_tree_node_visibility_void</b> (const void *value_ptr, int index, bool is_visible)</td></tr>
<tr class="separator:a8f634cc86cdcb2a65aa1921bd461a1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05025e09df1d16f40678661b83c79bc8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a05025e09df1d16f40678661b83c79bc8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a05025e09df1d16f40678661b83c79bc8">add_gui</a> (const std::string &amp;label, T &amp;value, const std::string &amp;gui_type=&quot;&quot;, const std::string &amp;options=&quot;&quot;)</td></tr>
<tr class="memdesc:a05025e09df1d16f40678661b83c79bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a composed gui of the given gui_type for the given value.  <a href="classcgv_1_1gui_1_1provider.html#a05025e09df1d16f40678661b83c79bc8">More...</a><br /></td></tr>
<tr class="separator:a05025e09df1d16f40678661b83c79bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e722ce8fd3bd48387d8ee5761498189"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9e722ce8fd3bd48387d8ee5761498189"><td class="memTemplItemLeft" align="right" valign="top">static bool &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a9e722ce8fd3bd48387d8ee5761498189">ref_tree_node_visible_flag</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a9e722ce8fd3bd48387d8ee5761498189"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a reference to the boolean flag, that tells whether the tree node for the passed value is visible  <a href="classcgv_1_1gui_1_1provider.html#a9e722ce8fd3bd48387d8ee5761498189">More...</a><br /></td></tr>
<tr class="separator:a9e722ce8fd3bd48387d8ee5761498189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001e91968dadb3c01162f00bfb101edc"><td class="memItemLeft" align="right" valign="top"><a id="a001e91968dadb3c01162f00bfb101edc"></a>
static bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>ref_tree_node_visible_flag_void</b> (const void *value_ptr, int index=-1)</td></tr>
<tr class="separator:a001e91968dadb3c01162f00bfb101edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
callbacks</h2></td></tr>
<tr class="memitem:ac21e975a89b32dcbbe9bdb39b4f452ca"><td class="memItemLeft" align="right" valign="top"><a id="ac21e975a89b32dcbbe9bdb39b4f452ca"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#ac21e975a89b32dcbbe9bdb39b4f452ca">on_select</a> ()</td></tr>
<tr class="memdesc:ac21e975a89b32dcbbe9bdb39b4f452ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">called by selection_change_cb whenever the gui of this provider is selected <br /></td></tr>
<tr class="separator:ac21e975a89b32dcbbe9bdb39b4f452ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d49da0a9a5f434b920c33d42139621"><td class="memItemLeft" align="right" valign="top"><a id="ac6d49da0a9a5f434b920c33d42139621"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#ac6d49da0a9a5f434b920c33d42139621">on_deselect</a> ()</td></tr>
<tr class="memdesc:ac6d49da0a9a5f434b920c33d42139621"><td class="mdescLeft">&#160;</td><td class="mdescRight">called by selection_change_cb whenever the gui of this provider is deselected <br /></td></tr>
<tr class="separator:ac6d49da0a9a5f434b920c33d42139621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30ecc2b9412b158cbe774babaacd402"><td class="memItemLeft" align="right" valign="top"><a id="af30ecc2b9412b158cbe774babaacd402"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#af30ecc2b9412b158cbe774babaacd402">selection_change_cb</a> (<a class="el" href="namespacecgv_1_1base.html#a580333ed27888f5e8c61452a44545f51">cgv::base::base_ptr</a> new_child, bool selected)</td></tr>
<tr class="memdesc:af30ecc2b9412b158cbe774babaacd402"><td class="mdescLeft">&#160;</td><td class="mdescRight">this is called by the gui group when the selection changes <br /></td></tr>
<tr class="separator:af30ecc2b9412b158cbe774babaacd402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6807d6d7fff24fd1d895cf67fd3e1331"><td class="memItemLeft" align="right" valign="top"><a id="a6807d6d7fff24fd1d895cf67fd3e1331"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a6807d6d7fff24fd1d895cf67fd3e1331">provider</a> ()</td></tr>
<tr class="memdesc:a6807d6d7fff24fd1d895cf67fd3e1331"><td class="mdescLeft">&#160;</td><td class="mdescRight">default construction <br /></td></tr>
<tr class="separator:a6807d6d7fff24fd1d895cf67fd3e1331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c059c10d5b754e7e8ca02be639bead6"><td class="memItemLeft" align="right" valign="top"><a id="a7c059c10d5b754e7e8ca02be639bead6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a7c059c10d5b754e7e8ca02be639bead6">~provider</a> ()</td></tr>
<tr class="memdesc:a7c059c10d5b754e7e8ca02be639bead6"><td class="mdescLeft">&#160;</td><td class="mdescRight">ensure to remove posted recreation callbacks <br /></td></tr>
<tr class="separator:a7c059c10d5b754e7e8ca02be639bead6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd40cd68e7f4339a603af99ebbf40108"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#abd40cd68e7f4339a603af99ebbf40108">get_gui_name</a> () const</td></tr>
<tr class="memdesc:abd40cd68e7f4339a603af99ebbf40108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derive a name for this instance that can be used in the gui as heading.  <a href="classcgv_1_1gui_1_1provider.html#abd40cd68e7f4339a603af99ebbf40108">More...</a><br /></td></tr>
<tr class="separator:abd40cd68e7f4339a603af99ebbf40108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f68d3402bf77c9705f1fd010a4f6390"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a9f68d3402bf77c9705f1fd010a4f6390">get_parent_type</a> () const</td></tr>
<tr class="memdesc:a9f68d3402bf77c9705f1fd010a4f6390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the group type that should be used by the class embedding the gui of the provider.  <a href="classcgv_1_1gui_1_1provider.html#a9f68d3402bf77c9705f1fd010a4f6390">More...</a><br /></td></tr>
<tr class="separator:a9f68d3402bf77c9705f1fd010a4f6390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6abf8d523c9ac4d79b54ceba5edd3727"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a6abf8d523c9ac4d79b54ceba5edd3727">ensure_selected_in_tab_group_parent</a> ()</td></tr>
<tr class="memdesc:a6abf8d523c9ac4d79b54ceba5edd3727"><td class="mdescLeft">&#160;</td><td class="mdescRight">ensure that my UI is selected in the parent group in case this is a tab group, otherwise return false  <a href="classcgv_1_1gui_1_1provider.html#a6abf8d523c9ac4d79b54ceba5edd3727">More...</a><br /></td></tr>
<tr class="separator:a6abf8d523c9ac4d79b54ceba5edd3727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841e8ef471bf376be1c3fa97179cd218"><td class="memItemLeft" align="right" valign="top"><a id="a841e8ef471bf376be1c3fa97179cd218"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a841e8ef471bf376be1c3fa97179cd218">update_member</a> (void *member_ptr)</td></tr>
<tr class="memdesc:a841e8ef471bf376be1c3fa97179cd218"><td class="mdescLeft">&#160;</td><td class="mdescRight">call this to update all views and controls of a member <br /></td></tr>
<tr class="separator:a841e8ef471bf376be1c3fa97179cd218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f205b0f9fb19663ded86d329a88678"><td class="memItemLeft" align="right" valign="top"><a id="a54f205b0f9fb19663ded86d329a88678"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a54f205b0f9fb19663ded86d329a88678">update_all_members</a> ()</td></tr>
<tr class="memdesc:a54f205b0f9fb19663ded86d329a88678"><td class="mdescLeft">&#160;</td><td class="mdescRight">call this to update all views and controls of all member <br /></td></tr>
<tr class="separator:a54f205b0f9fb19663ded86d329a88678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f386dcbc43a7409fd2f3f655c938e5d"><td class="memItemLeft" align="right" valign="top"><a id="a1f386dcbc43a7409fd2f3f655c938e5d"></a>
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a1f386dcbc43a7409fd2f3f655c938e5d">get_menu_path</a> () const</td></tr>
<tr class="memdesc:a1f386dcbc43a7409fd2f3f655c938e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a path in the main menu to select the gui <br /></td></tr>
<tr class="separator:a1f386dcbc43a7409fd2f3f655c938e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad662c36ff5c1e73c79a938c4adbab952"><td class="memItemLeft" align="right" valign="top"><a id="ad662c36ff5c1e73c79a938c4adbab952"></a>
virtual <a class="el" href="classcgv_1_1gui_1_1shortcut.html">shortcut</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#ad662c36ff5c1e73c79a938c4adbab952">get_shortcut</a> () const</td></tr>
<tr class="memdesc:ad662c36ff5c1e73c79a938c4adbab952"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a shortcut to activate the gui without menu navigation <br /></td></tr>
<tr class="separator:ad662c36ff5c1e73c79a938c4adbab952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2f0b6c734c04d3c90a1c51ffbc0de9"><td class="memItemLeft" align="right" valign="top"><a id="a1d2f0b6c734c04d3c90a1c51ffbc0de9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a1d2f0b6c734c04d3c90a1c51ffbc0de9">create_gui</a> ()=0</td></tr>
<tr class="memdesc:a1d2f0b6c734c04d3c90a1c51ffbc0de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">you must overload this for gui creation <br /></td></tr>
<tr class="separator:a1d2f0b6c734c04d3c90a1c51ffbc0de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71df33b57067886a8c264ed9eb672f5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#ab71df33b57067886a8c264ed9eb672f5">recreate_gui</a> ()</td></tr>
<tr class="memdesc:ab71df33b57067886a8c264ed9eb672f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recreate the gui of this instance right now.  <a href="classcgv_1_1gui_1_1provider.html#ab71df33b57067886a8c264ed9eb672f5">More...</a><br /></td></tr>
<tr class="separator:ab71df33b57067886a8c264ed9eb672f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91a5b7508ca2f8a995a7101a80cab76"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#aa91a5b7508ca2f8a995a7101a80cab76">post_recreate_gui</a> ()</td></tr>
<tr class="memdesc:aa91a5b7508ca2f8a995a7101a80cab76"><td class="mdescLeft">&#160;</td><td class="mdescRight">delayed recreation of gui  <a href="classcgv_1_1gui_1_1provider.html#aa91a5b7508ca2f8a995a7101a80cab76">More...</a><br /></td></tr>
<tr class="separator:aa91a5b7508ca2f8a995a7101a80cab76"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>derive from this class to provide a gui to the current viewer </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a05025e09df1d16f40678661b83c79bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05025e09df1d16f40678661b83c79bc8">&#9670;&nbsp;</a></span>add_gui()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::gui::provider::add_gui </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>gui_type</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a composed gui of the given gui_type for the given value. </p>
<p>This function returns false if no cgv::base::gui_creator has been registered for the given gui_type. The plugin cg_ext contains registers gui_creators for the most important types of the framework. The supported values for the options parameter are specific for the gui_type. Currently these are not documented and can only be found in the source code of the cg_ext plugin. </p>

</div>
</div>
<a id="af1b62a00070bd3dcdb8962da4f1921b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b62a00070bd3dcdb8962da4f1921b0">&#9670;&nbsp;</a></span>add_member_control()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt;<a class="el" href="classcgv_1_1gui_1_1control.html">control</a>&lt;T&gt; &gt; cgv::gui::provider::add_member_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcgv_1_1base_1_1base.html">cgv::base::base</a> *&#160;</td>
          <td class="paramname"><em>base_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>gui_type</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>align</em> = <code>&quot;\n&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add control with callback to cgv::base::on_set method on <a class="el" href="classcgv_1_1gui_1_1control.html#a49af8e128fc1e8443b95adbddfed009a" title="this signal is sent after the user triggered a change of value and the check_value succeeded.">cgv::gui::control::value_change</a> </p>
<p>use this method to add a control of a member and a callback to the on_set method of the <a class="el" href="classcgv_1_1base_1_1base.html">cgv::base::base</a> class. </p>

</div>
</div>
<a id="a71d52460406852908aeaceb573cbd00e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71d52460406852908aeaceb573cbd00e">&#9670;&nbsp;</a></span>add_tree_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::gui::provider::add_tree_node </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>toggle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a</em> = <code>&quot;\n&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecgv_1_1gui.html#a24b531058de9d4333ab8541c302587d7">gui_group_ptr</a>&#160;</td>
          <td class="paramname"><em>ggp</em> = <code><a class="el" href="namespacecgv_1_1gui.html#a24b531058de9d4333ab8541c302587d7">gui_group_ptr</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add a collapsable node to the gui (deprecated) </p>
<p>This method is one possibility to support tree like guis with nodes that can be opened or closed. The other prefarable possibitly builds on the functions <a class="el" href="classcgv_1_1gui_1_1provider.html#a62ba041ea08c3e6e3a93e76995f706aa" title="Begin a sub tree of a tree structured gui.">begin_tree_node()</a> and <a class="el" href="classcgv_1_1gui_1_1provider.html#a9bac0aa7c0467b606a3cbe9311f3d17c">end_tree_node()</a>. </p><pre class="fragment">Each node is represented by a heading with the text provided in the first parameter and of heading 
level specified in the first parameter. The state of the node is stored in a boolean variable
"toggle" that must be supplied by the implementation of the provider. The toggle needs to be
initialized in the constructor and is used in the create_gui method to only provide the gui of
the subtree if toggle is true. Every time the status of the node is changed, the whole gui is
rebuild with the post_recreate_gui method. The value of the toggle is also the return parameter 
of add_tree_node such the typical code inside the create_gui method looks
like
</pre> <div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="classcgv_1_1gui_1_1provider.html#a71d52460406852908aeaceb573cbd00e">add_tree_node</a>(<span class="stringliteral">&quot;Node&quot;</span>, toggle, 2)) {</div>
<div class="line">   <a class="code" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>(<span class="stringliteral">&quot;\a&quot;</span>); <span class="comment">// indent gui elements of tree node</span></div>
<div class="line">   <span class="comment">// create gui of subtree</span></div>
<div class="line">   </div>
<div class="line">   <a class="code" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>(<span class="stringliteral">&quot;\b&quot;</span>); <span class="comment">// undo indentation</span></div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a62ba041ea08c3e6e3a93e76995f706aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ba041ea08c3e6e3a93e76995f706aa">&#9670;&nbsp;</a></span>begin_tree_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::gui::provider::begin_tree_node </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>initial_visibility</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecgv_1_1gui.html#a24b531058de9d4333ab8541c302587d7">gui_group_ptr</a>&#160;</td>
          <td class="paramname"><em>ggp</em> = <code><a class="el" href="namespacecgv_1_1gui.html#a24b531058de9d4333ab8541c302587d7">gui_group_ptr</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begin a sub tree of a tree structured gui. </p>
<p>This function addes a toggle button and a heading for the tree node. The toggle button can be used to show or hide the subtree below the tree node. The heading shows simply the label parameter. The function returns the visibility state of the subtree below the tree node. Therefore its contents should only be specified if the function returns true. In that case one needs to terminate the gui elements added for the tree node with the end_tree_node function. A typical example would be </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="classcgv_1_1gui_1_1provider.html#a62ba041ea08c3e6e3a93e76995f706aa">begin_tree_node</a>(<span class="stringliteral">&quot;Node&quot;</span>, composed_value)) {</div>
<div class="line">   <a class="code" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>(<span class="stringliteral">&quot;\a&quot;</span>); <span class="comment">// indent gui elements of tree node</span></div>
<div class="line">   <span class="comment">// create gui of composed_value</span></div>
<div class="line">   </div>
<div class="line">   <a class="code" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>(<span class="stringliteral">&quot;\b&quot;</span>); <span class="comment">// undo indentation</span></div>
<div class="line">   <a class="code" href="classcgv_1_1gui_1_1provider.html#a9bac0aa7c0467b606a3cbe9311f3d17c">end_tree_node</a>(composed_value);</div>
<div class="line">}</div>
</div><!-- fragment --><p> The state of the toggle button is attached to a boolean flag that is globally managed by the provider. If your this pointer can be converted to <a class="el" href="classcgv_1_1base_1_1base.html">cgv::base::base</a>, the on_set callback with a pointer to the flag is called when the user toggles the tree node. To check in the on_set callback for the tree node toggle one can get a reference to the boolean flag with the ref_tree_node_visible_flag method.</p>
<p>To allocate the boolean flag the reference to a value controlled by the tree node is specified. The pointer to the controlled value is used as key for a map that manages the toggle states of all tree node buttons. If there is no superior structure whose value is controlled by the tree node, one can specify any of the values controled by the tree node. It is just important that no two tree nodes use the same value and that the pointer to the value cannot change. The latter is for example the case, when one uses an entry in a std::vector that can change size and reallocate its values. Then one should use the std::vector itself as value. In order to be able to distinguish the different elements of a vector one can extend the key from a value reference to a pair of a value reference plus an index. The index is then the index of the vector element. This is done by specifying with_index(value, idx) in the value argument. An example could look as follows: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="classcgv_1_1gui_1_1provider.html#a62ba041ea08c3e6e3a93e76995f706aa">begin_tree_node</a>(<span class="stringliteral">&quot;Node&quot;</span>, vec)) {</div>
<div class="line">   <a class="code" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>(<span class="stringliteral">&quot;\a&quot;</span>); <span class="comment">// indent gui elements of tree node</span></div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;vec.size; ++i) {</div>
<div class="line">                <span class="keywordflow">if</span> (<a class="code" href="classcgv_1_1gui_1_1provider.html#a62ba041ea08c3e6e3a93e76995f706aa">begin_tree_node</a>(std::string(<span class="stringliteral">&quot;element &quot;</span>)+<a class="code" href="namespacecgv_1_1utils.html#a9584ae56050ff7dd2b881c2b60efd55b">cgv::utils::to_string</a>(i), <a class="code" href="namespacecgv_1_1gui.html#aa887b469731f8956d0eaefd8801fc4a3">with_index</a>(vec,i))) {</div>
<div class="line">                   <a class="code" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>(<span class="stringliteral">&quot;\a&quot;</span>); <span class="comment">// indent gui elements of tree node for vector element</span></div>
<div class="line">                   <span class="comment">// create gui of vector element</span></div>
<div class="line">   </div>
<div class="line">                   <a class="code" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>(<span class="stringliteral">&quot;\b&quot;</span>); <span class="comment">// undo indentation</span></div>
<div class="line">                   <a class="code" href="classcgv_1_1gui_1_1provider.html#a9bac0aa7c0467b606a3cbe9311f3d17c">end_tree_node</a>(<a class="code" href="namespacecgv_1_1gui.html#aa887b469731f8956d0eaefd8801fc4a3">with_index</a>(vec,i));</div>
<div class="line">                }</div>
<div class="line">        }</div>
<div class="line">        <a class="code" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>(<span class="stringliteral">&quot;\b&quot;</span>); <span class="comment">// undo indentation</span></div>
<div class="line">        <a class="code" href="classcgv_1_1gui_1_1provider.html#a9bac0aa7c0467b606a3cbe9311f3d17c">end_tree_node</a>(vec);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a90fe8e7ea3ff452a8148cc779111512a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90fe8e7ea3ff452a8148cc779111512a">&#9670;&nbsp;</a></span>concat_enum_def()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string cgv::gui::provider::concat_enum_def </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>additional_first_name</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>additional_last_name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add a new group to the given parent group, not supported yet </p>
<p>concatenate names in string to enum declaration and optionally prepend or append given additional names</p>
<p>Add group with the gui of another object inside.</p>
<p>Add a new group, where the group elements are defined by another object that must be derived from provider. You can use the same group types as in the add_group method. concatenate names in string to enum declaration and optionally prepend or append given additional names </p>

</div>
</div>
<a id="a9bac0aa7c0467b606a3cbe9311f3d17c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bac0aa7c0467b606a3cbe9311f3d17c">&#9670;&nbsp;</a></span>end_tree_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cgv::gui::provider::end_tree_node </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>template specialization that allows to specify value reference plus node_instance by using the result of the function with_instance(value,idx) for the value argument finish a sub tree begun with begin_tree_node <br  />
</p>
<p>This functions should be called only if the corresponding call to begin_tree_node returned true. </p>

</div>
</div>
<a id="a6abf8d523c9ac4d79b54ceba5edd3727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6abf8d523c9ac4d79b54ceba5edd3727">&#9670;&nbsp;</a></span>ensure_selected_in_tab_group_parent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::gui::provider::ensure_selected_in_tab_group_parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ensure that my UI is selected in the parent group in case this is a tab group, otherwise return false </p>
<p>ensure that my UI is selected in the closest parent that is a tab group </p>

</div>
</div>
<a id="ac9e752ce7a60f2e4e978a54125fa036e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e752ce7a60f2e4e978a54125fa036e">&#9670;&nbsp;</a></span>find_control()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt;<a class="el" href="classcgv_1_1gui_1_1control.html">control</a>&lt;T&gt; &gt; cgv::gui::provider::find_control </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>idx_ptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find a control of a given class member </p>
<p>find the next control of the given value in the current group. If the index pointer is given, start at the index to which the pointer points and set this index to the index of the child index of the found control </p>

</div>
</div>
<a id="af4350ea3d268a289aff9a9b792d8eb7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4350ea3d268a289aff9a9b792d8eb7f">&#9670;&nbsp;</a></span>find_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt;<a class="el" href="classcgv_1_1gui_1_1view.html">view</a>&lt;T&gt; &gt; cgv::gui::provider::find_view </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>idx_ptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find a view of a given class member </p>
<p>find the next view of the given value in the current group. If the index pointer is given, start at the index to which the pointer points and set this index to the index of the child index of the found view </p>

</div>
</div>
<a id="abd40cd68e7f4339a603af99ebbf40108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd40cd68e7f4339a603af99ebbf40108">&#9670;&nbsp;</a></span>get_gui_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string cgv::gui::provider::get_gui_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derive a name for this instance that can be used in the gui as heading. </p>
<p>This method uses the following strategy to automatically determine the name shown in guis for a provider instance:</p><ul>
<li>try to cast the object into <a class="el" href="classcgv_1_1base_1_1named.html">cgv::base::named</a>, if successful, use get_name() method</li>
<li>check whether <a class="el" href="classcgv_1_1gui_1_1provider.html#a1f386dcbc43a7409fd2f3f655c938e5d" title="return a path in the main menu to select the gui">get_menu_path()</a> results in a path or name. In case of a path, use the last entry of the path as name.</li>
<li>try to cast to <a class="el" href="classcgv_1_1base_1_1base.html">cgv::base::base</a> and use get_type_name().</li>
<li>return "unnamed" otherwise</li>
</ul>
<p>this method uses the following strategy to automatically determine the name shown in guis for a provider instance:</p><ul>
<li>try to cast the object into <a class="el" href="classcgv_1_1base_1_1named.html">cgv::base::named</a>, if successful, use get_name() method</li>
<li>check whether <a class="el" href="classcgv_1_1gui_1_1provider.html#a1f386dcbc43a7409fd2f3f655c938e5d" title="return a path in the main menu to select the gui">get_menu_path()</a> results in a path or name. In case of a path, use the last entry of the path as name.</li>
<li>try to cast to <a class="el" href="classcgv_1_1base_1_1base.html">cgv::base::base</a> and use get_type_name().</li>
<li>return "unnamed" otherwise </li>
</ul>

</div>
</div>
<a id="a9f68d3402bf77c9705f1fd010a4f6390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f68d3402bf77c9705f1fd010a4f6390">&#9670;&nbsp;</a></span>get_parent_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string cgv::gui::provider::get_parent_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the group type that should be used by the class embedding the gui of the provider. </p>
<p>The default is to use a group of type "align_group". Overload this virtual method to use a different group type, such as layout group. </p>

</div>
</div>
<a id="aa91a5b7508ca2f8a995a7101a80cab76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa91a5b7508ca2f8a995a7101a80cab76">&#9670;&nbsp;</a></span>post_recreate_gui()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cgv::gui::provider::post_recreate_gui </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>delayed recreation of gui </p>
<p>schedule the recreation of the gui for the next time the program is idle. This mechanism is implemented in a thread save way. </p>

</div>
</div>
<a id="ab71df33b57067886a8c264ed9eb672f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab71df33b57067886a8c264ed9eb672f5">&#9670;&nbsp;</a></span>recreate_gui()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cgv::gui::provider::recreate_gui </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recreate the gui of this instance right now. </p>
<p>Use this method to recreate the gui, dont call create gui directly. Be careful when calling the method from a functor that is attached to a gui element generated by this provider. This can cause the gui element to be destroyed before the callback triggering the recreate_gui method has been completely finished, what might make the program crash. Use the post_recreate_gui method instead. </p>

</div>
</div>
<a id="a9e722ce8fd3bd48387d8ee5761498189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e722ce8fd3bd48387d8ee5761498189">&#9670;&nbsp;</a></span>ref_tree_node_visible_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool&amp; cgv::gui::provider::ref_tree_node_visible_flag </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a reference to the boolean flag, that tells whether the tree node for the passed value is visible </p>
<p>T can be with_index(v,i) as in the begin_tree_node function. You typically need this function in an on_set callback to check whether the user has toggled a tree node </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>cgv/gui/<a class="el" href="provider_8h_source.html">provider.h</a></li>
<li>cgv/gui/provider.cxx</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="aclasscgv_1_1gui_1_1provider_html_a71d52460406852908aeaceb573cbd00e"><div class="ttname"><a href="classcgv_1_1gui_1_1provider.html#a71d52460406852908aeaceb573cbd00e">cgv::gui::provider::add_tree_node</a></div><div class="ttdeci">bool add_tree_node(const std::string &amp;label, bool &amp;toggle, int level, const std::string &amp;a=&quot;\n&quot;, gui_group_ptr ggp=gui_group_ptr())</div><div class="ttdoc">add a collapsable node to the gui (deprecated)</div><div class="ttdef"><b>Definition:</b> provider.cxx:183</div></div>
<div class="ttc" id="aclasscgv_1_1gui_1_1provider_html_a9bac0aa7c0467b606a3cbe9311f3d17c"><div class="ttname"><a href="classcgv_1_1gui_1_1provider.html#a9bac0aa7c0467b606a3cbe9311f3d17c">cgv::gui::provider::end_tree_node</a></div><div class="ttdeci">void end_tree_node(const T &amp;value)</div><div class="ttdef"><b>Definition:</b> provider.h:222</div></div>
<div class="ttc" id="anamespacecgv_1_1gui_html_aa887b469731f8956d0eaefd8801fc4a3"><div class="ttname"><a href="namespacecgv_1_1gui.html#aa887b469731f8956d0eaefd8801fc4a3">cgv::gui::with_index</a></div><div class="ttdeci">with_index_struct&lt; T &gt; with_index(const T &amp;_value, int _index)</div><div class="ttdoc">helper function to support value references as well as value references with index for the tree_node ...</div><div class="ttdef"><b>Definition:</b> provider.h:28</div></div>
<div class="ttc" id="aclasscgv_1_1gui_1_1provider_html_a28af4e659bdd1825f3829263e15ce5ae"><div class="ttname"><a href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">cgv::gui::provider::align</a></div><div class="ttdeci">void align(const std::string &amp;_align)</div><div class="ttdoc">send pure alignment information</div><div class="ttdef"><b>Definition:</b> provider.cxx:36</div></div>
<div class="ttc" id="anamespacecgv_1_1utils_html_a9584ae56050ff7dd2b881c2b60efd55b"><div class="ttname"><a href="namespacecgv_1_1utils.html#a9584ae56050ff7dd2b881c2b60efd55b">cgv::utils::to_string</a></div><div class="ttdeci">std::string to_string(const std::string &amp;v, unsigned int w, unsigned int p)</div><div class="ttdoc">specialization of conversion from string to strings</div><div class="ttdef"><b>Definition:</b> convert_string.cxx:7</div></div>
<div class="ttc" id="aclasscgv_1_1gui_1_1provider_html_a62ba041ea08c3e6e3a93e76995f706aa"><div class="ttname"><a href="classcgv_1_1gui_1_1provider.html#a62ba041ea08c3e6e3a93e76995f706aa">cgv::gui::provider::begin_tree_node</a></div><div class="ttdeci">bool begin_tree_node(const std::string &amp;label, const T &amp;value, bool initial_visibility=false, const std::string &amp;options=&quot;&quot;, gui_group_ptr ggp=gui_group_ptr())</div><div class="ttdoc">Begin a sub tree of a tree structured gui.</div><div class="ttdef"><b>Definition:</b> provider.h:212</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecgv.html">cgv</a></li><li class="navelem"><a class="el" href="namespacecgv_1_1gui.html">gui</a></li><li class="navelem"><a class="el" href="classcgv_1_1gui_1_1provider.html">provider</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
