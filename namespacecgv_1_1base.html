<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cgv: cgv::base Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cgv
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacecgv_1_1base.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">cgv::base Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>the base namespace holds the base hierarchy, support for plugin registration and signals  
<a href="namespacecgv_1_1base.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1action.html">action</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The action class is used in tree traversals together with the traverser.  <a href="classcgv_1_1base_1_1action.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1extract__policy__struct.html">extract_policy_struct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1extract__policy__struct_3_01true_00_01X_01_4.html">extract_policy_struct&lt; true, X &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base__method__action.html">base_method_action</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for all actions that use methods of class X  <a href="classcgv_1_1base_1_1base__method__action.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1method__action.html">method_action</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for all method actions that take a single argument of type T1 in their signature  <a href="classcgv_1_1base_1_1method__action.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1single__method__action.html">single_method_action</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">complete implementation of method actions that only call one method when entering a node  <a href="classcgv_1_1base_1_1single__method__action.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1matched__method__action.html">matched_method_action</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">complete implementation of method actions that call a begin and end method when entering and leaving a node  <a href="classcgv_1_1base_1_1matched__method__action.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1method__action__2.html">method_action_2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for all method actions that take a single argument of type T1 in their signature  <a href="classcgv_1_1base_1_1method__action__2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1single__method__action__2.html">single_method_action_2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">complete implementation of method actions that only call one method when entering a node  <a href="classcgv_1_1base_1_1single__method__action__2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1attach__slot.html">attach_slot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">interface for an attachment slot that can store a base pointer  <a href="classcgv_1_1base_1_1attach__slot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1property__declaration__reflection__handler.html">property_declaration_reflection_handler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1call__reflection__handler.html">call_reflection_handler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1cast__helper__base.html">cast_helper_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1cast__helper.html">cast_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1cast__const__helper__base.html">cast_const_helper_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1cast__const__helper.html">cast_const_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html">base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for all classes that can be registered with support for dynamic properties (see also section <a class="el" href="baseNS.html#baseSEC">Base Hierarchy</a> of page <a class="el" href="baseNS.html">Namespace cgv::base</a>).  <a href="classcgv_1_1base_1_1base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1abst__property__access.html">abst_property_access</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1standard__type__property__access.html">standard_type_property_access</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1emulated__property__access.html">emulated_property_access</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1property__access.html">property_access</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1property__access_3_01int8__type_01_4.html">property_access&lt; int8_type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1property__access_3_01int16__type_01_4.html">property_access&lt; int16_type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1property__access_3_01int32__type_01_4.html">property_access&lt; int32_type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1property__access_3_01int64__type_01_4.html">property_access&lt; int64_type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1property__access_3_01uint8__type_01_4.html">property_access&lt; uint8_type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1property__access_3_01uint16__type_01_4.html">property_access&lt; uint16_type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1property__access_3_01uint32__type_01_4.html">property_access&lt; uint32_type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1property__access_3_01uint64__type_01_4.html">property_access&lt; uint64_type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1property__access_3_01float_01_4.html">property_access&lt; float &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1property__access_3_01double_01_4.html">property_access&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1property__access_3_01bool_01_4.html">property_access&lt; bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1property__access_3_01std_1_1string_01_4.html">property_access&lt; std::string &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base__generator.html">base_generator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implements a dynamic object, that can be composed of independent variables, which are handled as properties of the <a class="el" href="classcgv_1_1base_1_1base__generator.html" title="implements a dynamic object, that can be composed of independent variables, which are handled as prop...">base_generator</a> and published through the property interface of the base class.  <a href="classcgv_1_1base_1_1base__generator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1console.html">console</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">interface to the console of the application with implementation of the property interface  <a href="classcgv_1_1base_1_1console.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1find__action.html">find_action</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">simple action implementation that adds nodes implementing X to a results vector  <a href="classcgv_1_1base_1_1find__action.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1group.html">group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The group class is a node with children.  <a href="classcgv_1_1base_1_1group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1cast__helper_3_01group_01_4.html">cast_helper&lt; group &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1cast__const__helper_3_01group_01_4.html">cast_const_helper&lt; group &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1user__feedback.html">user_feedback</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">function pointers implementing user feedback functionality of <a class="el" href="namespacecgv_1_1base.html#a518b8f3181ba953056ea659173571304" title="same as find_data_file() but in case file is not found, it is downloaded from the provided url and st...">find_or_download_data_file()</a> function  <a href="structcgv_1_1base_1_1user__feedback.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1named.html">named</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for all gui types  <a href="classcgv_1_1base_1_1named.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1cast__helper_3_01named_01_4.html">cast_helper&lt; named &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1cast__const__helper_3_01named_01_4.html">cast_const_helper&lt; named &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1node.html">node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The node class keeps a pointer to its parent.  <a href="classcgv_1_1base_1_1node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1cast__helper_3_01node_01_4.html">cast_helper&lt; node &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1cast__const__helper_3_01node_01_4.html">cast_const_helper&lt; node &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1registration__info.html">registration_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1registration__order__info.html">registration_order_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1object__collection.html">object_collection</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1registration__order__definition.html">registration_order_definition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper class whose constructor calls the <code><a class="el" href="namespacecgv_1_1base.html#ada908977e738c6da6230a698912bebc4" title="specify a partial order of objects for registration">define_registration_order()</a></code> function  <a href="structcgv_1_1base_1_1registration__order__definition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1object__constructor.html">object_constructor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract base class of helpers to perform delayed registration and creation of objects in case that the registration is currently disabled  <a href="structcgv_1_1base_1_1object__constructor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1object__constructor__impl.html">object_constructor_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1object__constructor__impl__1.html">object_constructor_impl_1</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1object__constructor__impl__2.html">object_constructor_impl_2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1object__registration.html">object_registration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience class to register an object of the given class type  <a href="structcgv_1_1base_1_1object__registration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1object__registration__1.html">object_registration_1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience class to register an object of the given class type with one constructor argument  <a href="structcgv_1_1base_1_1object__registration__1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1object__registration__2.html">object_registration_2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience class to register an object of the given class type with two constructor arguments  <a href="structcgv_1_1base_1_1object__registration__2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1server.html">server</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">interfaces that add provides very basic functionality.  <a href="structcgv_1_1base_1_1server.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1driver.html">driver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">interfaces that add several listeners and objects.  <a href="structcgv_1_1base_1_1driver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1registration__listener.html">registration_listener</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">interfaces that allows to listen to registration events.  <a href="structcgv_1_1base_1_1registration__listener.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1factory.html">factory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">interface for a factory that allows to create objects derived from <a class="el" href="classcgv_1_1base_1_1base.html" title="base class for all classes that can be registered with support for dynamic properties (see also secti...">cgv::base::base</a>  <a href="structcgv_1_1base_1_1factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1factory__impl.html">factory_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implementation of factory for objects of type T using the standard constructor  <a href="structcgv_1_1base_1_1factory__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1factory__impl__1.html">factory_impl_1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implementation of factory for objects of type T using a constructor with one argument of type CA  <a href="structcgv_1_1base_1_1factory__impl__1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1factory__impl__2.html">factory_impl_2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implementation of factory for objects of type T using a constructor with two arguments of types CA1 and CA2  <a href="structcgv_1_1base_1_1factory__impl__2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1factory__registration.html">factory_registration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience class to register a factory of the given class type  <a href="structcgv_1_1base_1_1factory__registration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1factory__registration__1.html">factory_registration_1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience class to register a factory of the given class type that uses a constructor with one argument of type CA  <a href="structcgv_1_1base_1_1factory__registration__1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1factory__registration__2.html">factory_registration_2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience class to register a factory of the given class type that uses a constructor with one argument of type CA  <a href="structcgv_1_1base_1_1factory__registration__2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1test.html">test</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure used to register a test function  <a href="classcgv_1_1base_1_1test.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1test__registration.html">test_registration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">declare an instance of <a class="el" href="structcgv_1_1base_1_1test__registration.html" title="declare an instance of test_registration as static variable in order to register a test function in a...">test_registration</a> as static variable in order to register a test function in a test plugin  <a href="structcgv_1_1base_1_1test__registration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1resource__file__info.html">resource_file_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">information registered with each resource file  <a href="structcgv_1_1base_1_1resource__file__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1resource__file__registration.html">resource_file_registration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience class to register a resource file  <a href="structcgv_1_1base_1_1resource__file__registration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1resource__string__registration.html">resource_string_registration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience class to register a resource string  <a href="structcgv_1_1base_1_1resource__string__registration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1argument__handler.html">argument_handler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">interface for objects that process unknown command line arguments  <a href="structcgv_1_1base_1_1argument__handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1command__info.html">command_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a structure to store an analized command  <a href="structcgv_1_1base_1_1command__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1config__file__observer.html">config_file_observer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract interface for observers of config files.  <a href="structcgv_1_1base_1_1config__file__observer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1config__file__driver.html">config_file_driver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract interface for a config file driver that handles permanent registration and gui config files.  <a href="structcgv_1_1base_1_1config__file__driver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1use__handler.html">use_handler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1no__handler.html">no_handler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1traverse__policy.html">traverse_policy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">nodes should inherit from this policy class to allow selective tree traversals  <a href="classcgv_1_1base_1_1traverse__policy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1traverse__callback__handler.html">traverse_callback_handler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">interface of a handler for traverse callbacks  <a href="classcgv_1_1base_1_1traverse__callback__handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1traverser.html">traverser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class used to traverse a tree structure  <a href="classcgv_1_1base_1_1traverser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a580333ed27888f5e8c61452a44545f51"><td class="memItemLeft" align="right" valign="top"><a id="a580333ed27888f5e8c61452a44545f51"></a>
typedef <a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; <a class="el" href="classcgv_1_1base_1_1base.html">base</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a580333ed27888f5e8c61452a44545f51">base_ptr</a></td></tr>
<tr class="memdesc:a580333ed27888f5e8c61452a44545f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">ref counted pointer to base <br /></td></tr>
<tr class="separator:a580333ed27888f5e8c61452a44545f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee0e7ce76f41bd6555327d9e3d9e502"><td class="memItemLeft" align="right" valign="top"><a id="abee0e7ce76f41bd6555327d9e3d9e502"></a>
typedef <a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; const <a class="el" href="classcgv_1_1base_1_1base.html">base</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#abee0e7ce76f41bd6555327d9e3d9e502">const_base_ptr</a></td></tr>
<tr class="memdesc:abee0e7ce76f41bd6555327d9e3d9e502"><td class="mdescLeft">&#160;</td><td class="mdescRight">ref counted pointer to const base <br /></td></tr>
<tr class="separator:abee0e7ce76f41bd6555327d9e3d9e502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a483e13cc8a05eab04f07848e4e2ab4c8"><td class="memItemLeft" align="right" valign="top"><a id="a483e13cc8a05eab04f07848e4e2ab4c8"></a>
typedef <a class="el" href="classcgv_1_1data_1_1ref__ptr.html">cgv::data::ref_ptr</a>&lt; <a class="el" href="classcgv_1_1base_1_1console.html">console</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a483e13cc8a05eab04f07848e4e2ab4c8">console_ptr</a></td></tr>
<tr class="memdesc:a483e13cc8a05eab04f07848e4e2ab4c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to console <br /></td></tr>
<tr class="separator:a483e13cc8a05eab04f07848e4e2ab4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2501796ba207ee4454afee3d0ad7921"><td class="memItemLeft" align="right" valign="top"><a id="ac2501796ba207ee4454afee3d0ad7921"></a>
typedef <a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; <a class="el" href="classcgv_1_1base_1_1group.html">group</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#ac2501796ba207ee4454afee3d0ad7921">group_ptr</a></td></tr>
<tr class="memdesc:ac2501796ba207ee4454afee3d0ad7921"><td class="mdescLeft">&#160;</td><td class="mdescRight">ref counted pointer to a node <br /></td></tr>
<tr class="separator:ac2501796ba207ee4454afee3d0ad7921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e8e877cbf782dcf8f019bc1816a59f"><td class="memItemLeft" align="right" valign="top"><a id="a46e8e877cbf782dcf8f019bc1816a59f"></a>
typedef <a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; const <a class="el" href="classcgv_1_1base_1_1group.html">group</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a46e8e877cbf782dcf8f019bc1816a59f">const_group_ptr</a></td></tr>
<tr class="memdesc:a46e8e877cbf782dcf8f019bc1816a59f"><td class="mdescLeft">&#160;</td><td class="mdescRight">ref counted pointer to a node <br /></td></tr>
<tr class="separator:a46e8e877cbf782dcf8f019bc1816a59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfcd30049d34b52e335da99b47c3979d"><td class="memItemLeft" align="right" valign="top"><a id="abfcd30049d34b52e335da99b47c3979d"></a>
typedef <a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; <a class="el" href="classcgv_1_1base_1_1named.html">named</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#abfcd30049d34b52e335da99b47c3979d">named_ptr</a></td></tr>
<tr class="memdesc:abfcd30049d34b52e335da99b47c3979d"><td class="mdescLeft">&#160;</td><td class="mdescRight">ref counted pointer to a node <br /></td></tr>
<tr class="separator:abfcd30049d34b52e335da99b47c3979d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1c8267eac5b54dcab53b3adb1fa357"><td class="memItemLeft" align="right" valign="top"><a id="acc1c8267eac5b54dcab53b3adb1fa357"></a>
typedef <a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; const <a class="el" href="classcgv_1_1base_1_1named.html">named</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#acc1c8267eac5b54dcab53b3adb1fa357">const_named_ptr</a></td></tr>
<tr class="memdesc:acc1c8267eac5b54dcab53b3adb1fa357"><td class="mdescLeft">&#160;</td><td class="mdescRight">ref counted pointer to a const node <br /></td></tr>
<tr class="separator:acc1c8267eac5b54dcab53b3adb1fa357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a876ea103d1a70f0477574fd136a99192"><td class="memItemLeft" align="right" valign="top"><a id="a876ea103d1a70f0477574fd136a99192"></a>
typedef <a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; <a class="el" href="classcgv_1_1base_1_1node.html">node</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a876ea103d1a70f0477574fd136a99192">node_ptr</a></td></tr>
<tr class="memdesc:a876ea103d1a70f0477574fd136a99192"><td class="mdescLeft">&#160;</td><td class="mdescRight">ref counted pointer to a node <br /></td></tr>
<tr class="separator:a876ea103d1a70f0477574fd136a99192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b0172515fe3213763efbcec3d45c76"><td class="memItemLeft" align="right" valign="top"><a id="a12b0172515fe3213763efbcec3d45c76"></a>
typedef <a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; const <a class="el" href="classcgv_1_1base_1_1node.html">node</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a12b0172515fe3213763efbcec3d45c76">const_node_ptr</a></td></tr>
<tr class="memdesc:a12b0172515fe3213763efbcec3d45c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">ref counted pointer to a const node <br /></td></tr>
<tr class="separator:a12b0172515fe3213763efbcec3d45c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a746925f26d076c26742b2dc558cbae36"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a746925f26d076c26742b2dc558cbae36">TraversePolicy</a> { <br />
&#160;&#160;<b>TP_ALL</b>
, <a class="el" href="namespacecgv_1_1base.html#a746925f26d076c26742b2dc558cbae36a4dd87fc30d8a2e369fe315eb9ccde557">TP_ONLY_FOCUS</a>
, <a class="el" href="namespacecgv_1_1base.html#a746925f26d076c26742b2dc558cbae36a69ee76315433dc44f8bfa441afefa249">TP_FIRST_FOCUS</a>
, <a class="el" href="namespacecgv_1_1base.html#a746925f26d076c26742b2dc558cbae36a169ba2fab3a13ea551eb8d8800e459bb">TP_AUTO_FOCUS</a>
, <br />
&#160;&#160;<a class="el" href="namespacecgv_1_1base.html#a746925f26d076c26742b2dc558cbae36a7b2b5c718b50e4241491dcb951599a8b">TP_STOP_ON_SUCCESS</a> = 8
, <a class="el" href="namespacecgv_1_1base.html#a746925f26d076c26742b2dc558cbae36a33806b12ea827401e0a110036ddbeabe">TP_STOP_ON_FAILURE</a> = 16
<br />
 }</td></tr>
<tr class="memdesc:a746925f26d076c26742b2dc558cbae36"><td class="mdescLeft">&#160;</td><td class="mdescRight">different traversal policies  <a href="namespacecgv_1_1base.html#a746925f26d076c26742b2dc558cbae36">More...</a><br /></td></tr>
<tr class="separator:a746925f26d076c26742b2dc558cbae36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e996b7f5a3a74779d9cee38497ba673"><td class="memItemLeft" align="right" valign="top"><a id="a2e996b7f5a3a74779d9cee38497ba673"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a2e996b7f5a3a74779d9cee38497ba673">TraverseStrategy</a> { <b>TS_DEPTH_FIRST</b>
, <b>TS_BREADTH_FIRST</b>
 }</td></tr>
<tr class="memdesc:a2e996b7f5a3a74779d9cee38497ba673"><td class="mdescLeft">&#160;</td><td class="mdescRight">not yet implemented <br /></td></tr>
<tr class="separator:a2e996b7f5a3a74779d9cee38497ba673"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a33c3982af255622d93a69be50f3b2e06"><td class="memTemplParams" colspan="2"><a id="a33c3982af255622d93a69be50f3b2e06"></a>
template&lt;typename T1 , class X , typename R &gt; </td></tr>
<tr class="memitem:a33c3982af255622d93a69be50f3b2e06"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1base_1_1single__method__action.html">single_method_action</a>&lt; X, R, T1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a33c3982af255622d93a69be50f3b2e06">make_action</a> (T1 _v1, R(X::*_on_begin)(T1), bool _default_result_begin=false, bool _default_result_end=false)</td></tr>
<tr class="memdesc:a33c3982af255622d93a69be50f3b2e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function to construct an action from a signature and one method that is called when a node is entered <br /></td></tr>
<tr class="separator:a33c3982af255622d93a69be50f3b2e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c60002b6fe7ac3ea746b589f43d75af"><td class="memTemplParams" colspan="2"><a id="a4c60002b6fe7ac3ea746b589f43d75af"></a>
template&lt;typename T1 , class X , typename R1 , typename R2 &gt; </td></tr>
<tr class="memitem:a4c60002b6fe7ac3ea746b589f43d75af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1base_1_1matched__method__action.html">matched_method_action</a>&lt; X, R1, R2, T1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a4c60002b6fe7ac3ea746b589f43d75af">make_action</a> (T1 _v1, R1(X::*_on_begin)(T1), R2(X::*_on_end)(T1), bool _default_result_begin=false, bool _default_result_end=false)</td></tr>
<tr class="memdesc:a4c60002b6fe7ac3ea746b589f43d75af"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function to construct an action from a signature and two methods that are called when a node is entered and when it is left again <br /></td></tr>
<tr class="separator:a4c60002b6fe7ac3ea746b589f43d75af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9586bffe7837806145302b7f933ea8"><td class="memTemplParams" colspan="2"><a id="a4d9586bffe7837806145302b7f933ea8"></a>
template&lt;typename T1 , typename T2 , class X , typename R &gt; </td></tr>
<tr class="memitem:a4d9586bffe7837806145302b7f933ea8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1base_1_1single__method__action__2.html">single_method_action_2</a>&lt; X, R, T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a4d9586bffe7837806145302b7f933ea8">make_action_2</a> (T1 _v1, T2 _v2, R(X::*_on_begin)(T1, T2), bool _default_result_begin=false, bool _default_result_end=false)</td></tr>
<tr class="memdesc:a4d9586bffe7837806145302b7f933ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function to construct an action from a signature and one method that is called when a node is entered <br /></td></tr>
<tr class="separator:a4d9586bffe7837806145302b7f933ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56137cd8bf24c23f7f6ef15a417bbdd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#ac56137cd8bf24c23f7f6ef15a417bbdd">attach</a> (<a class="el" href="namespacecgv_1_1base.html#a580333ed27888f5e8c61452a44545f51">base_ptr</a> slot_object, <a class="el" href="namespacecgv_1_1base.html#a580333ed27888f5e8c61452a44545f51">base_ptr</a> attachment_object, void *user_data)</td></tr>
<tr class="memdesc:ac56137cd8bf24c23f7f6ef15a417bbdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">function to attach an object to an object of type <a class="el" href="classcgv_1_1base_1_1attach__slot.html" title="interface for an attachment slot that can store a base pointer">attach_slot</a>.  <a href="namespacecgv_1_1base.html#ac56137cd8bf24c23f7f6ef15a417bbdd">More...</a><br /></td></tr>
<tr class="separator:ac56137cd8bf24c23f7f6ef15a417bbdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30413a45bface135588e0b7a117acff"><td class="memItemLeft" align="right" valign="top"><a id="ac30413a45bface135588e0b7a117acff"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>attach</b> (<a class="el" href="namespacecgv_1_1base.html#a580333ed27888f5e8c61452a44545f51">base_ptr</a> slot_object, <a class="el" href="namespacecgv_1_1base.html#a580333ed27888f5e8c61452a44545f51">base_ptr</a> attachment_object, int user_data)</td></tr>
<tr class="separator:ac30413a45bface135588e0b7a117acff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3f23268db7fec467dfd98ab36094f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecgv_1_1base.html#a580333ed27888f5e8c61452a44545f51">base_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a1e3f23268db7fec467dfd98ab36094f5">get_attachment</a> (<a class="el" href="namespacecgv_1_1base.html#a580333ed27888f5e8c61452a44545f51">base_ptr</a> slot_object)</td></tr>
<tr class="memdesc:a1e3f23268db7fec467dfd98ab36094f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">query the attachment of an <a class="el" href="classcgv_1_1base_1_1attach__slot.html" title="interface for an attachment slot that can store a base pointer">attach_slot</a> object.  <a href="namespacecgv_1_1base.html#a1e3f23268db7fec467dfd98ab36094f5">More...</a><br /></td></tr>
<tr class="separator:a1e3f23268db7fec467dfd98ab36094f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec69e775624f1ca64e001ff8b1254344"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#aec69e775624f1ca64e001ff8b1254344">get_attachment_data</a> (<a class="el" href="namespacecgv_1_1base.html#a580333ed27888f5e8c61452a44545f51">base_ptr</a> slot_object)</td></tr>
<tr class="memdesc:aec69e775624f1ca64e001ff8b1254344"><td class="mdescLeft">&#160;</td><td class="mdescRight">query the user data of the attachment of an <a class="el" href="classcgv_1_1base_1_1attach__slot.html" title="interface for an attachment slot that can store a base pointer">attach_slot</a> object.  <a href="namespacecgv_1_1base.html#aec69e775624f1ca64e001ff8b1254344">More...</a><br /></td></tr>
<tr class="separator:aec69e775624f1ca64e001ff8b1254344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac067f48134e3993e216158740fd5d535"><td class="memItemLeft" align="right" valign="top"><a id="ac067f48134e3993e216158740fd5d535"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>get_attachment_data_int</b> (<a class="el" href="namespacecgv_1_1base.html#a580333ed27888f5e8c61452a44545f51">base_ptr</a> slot_object)</td></tr>
<tr class="separator:ac067f48134e3993e216158740fd5d535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63edc5ab309dd943500adb7801deeb2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac63edc5ab309dd943500adb7801deeb2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#ac63edc5ab309dd943500adb7801deeb2">has_property</a> (const std::string &amp;options, const std::string &amp;property, T &amp;value, bool report_error=true)</td></tr>
<tr class="memdesc:ac63edc5ab309dd943500adb7801deeb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">simple parsing support to access values of properties in a string of property assignment  <a href="namespacecgv_1_1base.html#ac63edc5ab309dd943500adb7801deeb2">More...</a><br /></td></tr>
<tr class="separator:ac63edc5ab309dd943500adb7801deeb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9306cf99f175197cf29de2b547b5cfb9"><td class="memTemplParams" colspan="2"><a id="a9306cf99f175197cf29de2b547b5cfb9"></a>
template&lt;class X &gt; </td></tr>
<tr class="memitem:a9306cf99f175197cf29de2b547b5cfb9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a9306cf99f175197cf29de2b547b5cfb9">find_interface</a> (<a class="el" href="namespacecgv_1_1base.html#a580333ed27888f5e8c61452a44545f51">base_ptr</a> start, std::vector&lt; X * &gt; &amp;result)</td></tr>
<tr class="memdesc:a9306cf99f175197cf29de2b547b5cfb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">collect all nodes that implement interface X <br /></td></tr>
<tr class="separator:a9306cf99f175197cf29de2b547b5cfb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36bdb717a44db6f25d51ffb3a110d6aa"><td class="memTemplParams" colspan="2"><a id="a36bdb717a44db6f25d51ffb3a110d6aa"></a>
template&lt;class X , typename T &gt; </td></tr>
<tr class="memitem:a36bdb717a44db6f25d51ffb3a110d6aa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a36bdb717a44db6f25d51ffb3a110d6aa">ensure_by_find</a> (X *start, T *&amp;pointer, unsigned i=0)</td></tr>
<tr class="memdesc:a36bdb717a44db6f25d51ffb3a110d6aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">traverse the hierarchy to find the i-th instance of type T and set pointer to it but only in case pointer is the nullptr, returns false if pointer was nullptr and no instance of type T was found <br /></td></tr>
<tr class="separator:a36bdb717a44db6f25d51ffb3a110d6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5268c0eef9622585a1539f5d13310548"><td class="memItemLeft" align="right" valign="top"><a id="a5268c0eef9622585a1539f5d13310548"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>find_data_file_rec</b> (const std::string &amp;path, const std::string &amp;file_name)</td></tr>
<tr class="separator:a5268c0eef9622585a1539f5d13310548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee2337a55cabb6641e5c349b3cc1d27"><td class="memItemLeft" align="right" valign="top"><a id="a8ee2337a55cabb6641e5c349b3cc1d27"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>find_data_file_1</b> (const std::string &amp;base_path, const std::string &amp;sub_path, const std::string &amp;file_name, bool recurse)</td></tr>
<tr class="separator:a8ee2337a55cabb6641e5c349b3cc1d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a74a3ac59d4a8e5204b1ef742a39fc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#ad7a74a3ac59d4a8e5204b1ef742a39fc">find_data_file</a> (const std::string &amp;file_name, const std::string &amp;strategy, const std::string &amp;sub_directory=&quot;&quot;, const std::string &amp;master_path=&quot;&quot;)</td></tr>
<tr class="memdesc:ad7a74a3ac59d4a8e5204b1ef742a39fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a file with the given strategy and return the file name extended by the necessary path.  <a href="namespacecgv_1_1base.html#ad7a74a3ac59d4a8e5204b1ef742a39fc">More...</a><br /></td></tr>
<tr class="separator:ad7a74a3ac59d4a8e5204b1ef742a39fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda62b3d37fc0252179d50ff291551be"><td class="memItemLeft" align="right" valign="top"><a id="afda62b3d37fc0252179d50ff291551be"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#afda62b3d37fc0252179d50ff291551be">stdout_message</a> (const std::string &amp;text)</td></tr>
<tr class="memdesc:afda62b3d37fc0252179d50ff291551be"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::cout based implementation of the <code>message</code> function for first argument to the <code><a class="el" href="structcgv_1_1base_1_1user__feedback.html" title="function pointers implementing user feedback functionality of find_or_download_data_file() function">user_feedback</a></code> constructor <br /></td></tr>
<tr class="separator:afda62b3d37fc0252179d50ff291551be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ff9ff796a8f99aaa4efa9b1edaa211"><td class="memItemLeft" align="right" valign="top"><a id="a59ff9ff796a8f99aaa4efa9b1edaa211"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a59ff9ff796a8f99aaa4efa9b1edaa211">stderr_message</a> (const std::string &amp;text)</td></tr>
<tr class="memdesc:a59ff9ff796a8f99aaa4efa9b1edaa211"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::cerr based implementation of the <code>message</code> function for first argument to the <code><a class="el" href="structcgv_1_1base_1_1user__feedback.html" title="function pointers implementing user feedback functionality of find_or_download_data_file() function">user_feedback</a></code> constructor <br /></td></tr>
<tr class="separator:a59ff9ff796a8f99aaa4efa9b1edaa211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad51064d139d1e466114e44ba23ac6c"><td class="memItemLeft" align="right" valign="top"><a id="a6ad51064d139d1e466114e44ba23ac6c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a6ad51064d139d1e466114e44ba23ac6c">std_query</a> (const std::string &amp;text, const std::string &amp;answers, int default_answer)</td></tr>
<tr class="memdesc:a6ad51064d139d1e466114e44ba23ac6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::cout and std::cin based implementation of the <code>query</code> function for second argument to the <code><a class="el" href="structcgv_1_1base_1_1user__feedback.html" title="function pointers implementing user feedback functionality of find_or_download_data_file() function">user_feedback</a></code> constructor <br /></td></tr>
<tr class="separator:a6ad51064d139d1e466114e44ba23ac6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09823546be3c2201d20125b59e10333b"><td class="memItemLeft" align="right" valign="top"><a id="a09823546be3c2201d20125b59e10333b"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a09823546be3c2201d20125b59e10333b">std_ask_dir</a> (const std::string &amp;text, const std::string &amp;path)</td></tr>
<tr class="memdesc:a09823546be3c2201d20125b59e10333b"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::cout and std::cin based implementation of the <code>ask_dir</code> function for third argument to the <code><a class="el" href="structcgv_1_1base_1_1user__feedback.html" title="function pointers implementing user feedback functionality of find_or_download_data_file() function">user_feedback</a></code> constructor <br /></td></tr>
<tr class="separator:a09823546be3c2201d20125b59e10333b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518b8f3181ba953056ea659173571304"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a518b8f3181ba953056ea659173571304">find_or_download_data_file</a> (const std::string &amp;file_name, const std::string &amp;find_strategy, const std::string &amp;url, const std::string &amp;cache_strategy, const std::string &amp;producer, const std::string &amp;sub_directory=&quot;&quot;, const std::string &amp;master_path=&quot;&quot;, <a class="el" href="structcgv_1_1base_1_1user__feedback.html">user_feedback</a> uf=<a class="el" href="structcgv_1_1base_1_1user__feedback.html">user_feedback</a>())</td></tr>
<tr class="memdesc:a518b8f3181ba953056ea659173571304"><td class="mdescLeft">&#160;</td><td class="mdescRight">same as <a class="el" href="namespacecgv_1_1base.html#ad7a74a3ac59d4a8e5204b1ef742a39fc" title="Find a file with the given strategy and return the file name extended by the necessary path.">find_data_file()</a> but in case file is not found, it is downloaded from the provided url and stored in a directory searched for with the parameter <code>cache_strategy</code>.  <a href="namespacecgv_1_1base.html#a518b8f3181ba953056ea659173571304">More...</a><br /></td></tr>
<tr class="separator:a518b8f3181ba953056ea659173571304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2cc4c2946c2fdd5f0dccf3803e08d0f"><td class="memItemLeft" align="right" valign="top"><a id="ad2cc4c2946c2fdd5f0dccf3803e08d0f"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>clean_data_path</b> (const std::string &amp;data_path)</td></tr>
<tr class="separator:ad2cc4c2946c2fdd5f0dccf3803e08d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e30b157762c186c5c0d60359e36b5c"><td class="memItemLeft" align="right" valign="top"><a id="ab6e30b157762c186c5c0d60359e36b5c"></a>
std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#ab6e30b157762c186c5c0d60359e36b5c">ref_data_path_list</a> ()</td></tr>
<tr class="memdesc:ab6e30b157762c186c5c0d60359e36b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a reference to the data path list, which is constructed from the environment variable CGV_DATA <br /></td></tr>
<tr class="separator:ab6e30b157762c186c5c0d60359e36b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c98c559c9c197551a146a91a704e4b"><td class="memItemLeft" align="right" valign="top"><a id="a90c98c559c9c197551a146a91a704e4b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a90c98c559c9c197551a146a91a704e4b">push_file_parent</a> (const std::string &amp;path_or_file_name)</td></tr>
<tr class="memdesc:a90c98c559c9c197551a146a91a704e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract a valid path from the given argument and push it onto the stack of parent paths. This should always be paired with a call to <a class="el" href="namespacecgv_1_1base.html#a8117654ca2eb262f18fc1093c0fdf828" title="pop the latestly pushed parent path from the parent path stack.">pop_file_parent()</a>. <br /></td></tr>
<tr class="separator:a90c98c559c9c197551a146a91a704e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8117654ca2eb262f18fc1093c0fdf828"><td class="memItemLeft" align="right" valign="top"><a id="a8117654ca2eb262f18fc1093c0fdf828"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a8117654ca2eb262f18fc1093c0fdf828">pop_file_parent</a> ()</td></tr>
<tr class="memdesc:a8117654ca2eb262f18fc1093c0fdf828"><td class="mdescLeft">&#160;</td><td class="mdescRight">pop the latestly pushed parent path from the parent path stack. <br /></td></tr>
<tr class="separator:a8117654ca2eb262f18fc1093c0fdf828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f550111b3915df062b0bbda4795f37"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#aa3f550111b3915df062b0bbda4795f37">ref_parent_file_stack</a> ()</td></tr>
<tr class="memdesc:aa3f550111b3915df062b0bbda4795f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a reference to the data path list, which is constructed from the environment variable CGV_DATA  <a href="namespacecgv_1_1base.html#aa3f550111b3915df062b0bbda4795f37">More...</a><br /></td></tr>
<tr class="separator:aa3f550111b3915df062b0bbda4795f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551cf12ea220b803b17f09f04d0ca61f"><td class="memItemLeft" align="right" valign="top"><a id="a551cf12ea220b803b17f09f04d0ca61f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>find_and_extend_system_path</b> (std::string &amp;file_name)</td></tr>
<tr class="separator:a551cf12ea220b803b17f09f04d0ca61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8197d89c413eb148311cd082a5f48b5"><td class="memItemLeft" align="right" valign="top"><a id="ab8197d89c413eb148311cd082a5f48b5"></a>
FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#ab8197d89c413eb148311cd082a5f48b5">open_data_file</a> (const std::string &amp;file_name, const char *mode)</td></tr>
<tr class="memdesc:ab8197d89c413eb148311cd082a5f48b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">open a file with fopen supporting resource files, that have the prefix "res://" <br /></td></tr>
<tr class="separator:ab8197d89c413eb148311cd082a5f48b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26c5e2027679d73a019e1445ca376b0"><td class="memItemLeft" align="right" valign="top"><a id="ab26c5e2027679d73a019e1445ca376b0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#ab26c5e2027679d73a019e1445ca376b0">read_data_file</a> (const std::string &amp;file_name, std::string &amp;content, bool ascii)</td></tr>
<tr class="memdesc:ab26c5e2027679d73a019e1445ca376b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">read ascii file into a string <br /></td></tr>
<tr class="separator:ab26c5e2027679d73a019e1445ca376b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb2083031cea3f3279d75aaac2b2419"><td class="memItemLeft" align="right" valign="top"><a id="aeeb2083031cea3f3279d75aaac2b2419"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#aeeb2083031cea3f3279d75aaac2b2419">data_file_size</a> (const std::string &amp;file_name)</td></tr>
<tr class="memdesc:aeeb2083031cea3f3279d75aaac2b2419"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the file size of a given file with support for resource files, that have the prefix "res://" <br /></td></tr>
<tr class="separator:aeeb2083031cea3f3279d75aaac2b2419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710077a65b53cacae54e2cddbccfb5eb"><td class="memItemLeft" align="right" valign="top"><a id="a710077a65b53cacae54e2cddbccfb5eb"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a710077a65b53cacae54e2cddbccfb5eb">find_file_offset</a> (const std::string &amp;file_name, const char *data, unsigned int data_size)</td></tr>
<tr class="memdesc:a710077a65b53cacae54e2cddbccfb5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the offset of the given data block in the given file <br /></td></tr>
<tr class="separator:a710077a65b53cacae54e2cddbccfb5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3346b0c4dcaed4aeabfe44fa9f833bb3"><td class="memItemLeft" align="right" valign="top"><a id="a3346b0c4dcaed4aeabfe44fa9f833bb3"></a>
<a class="el" href="structcgv_1_1base_1_1object__collection.html">object_collection</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>ref_object_collection</b> ()</td></tr>
<tr class="separator:a3346b0c4dcaed4aeabfe44fa9f833bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6104c23316933b74de2bed918f85f3f1"><td class="memItemLeft" align="right" valign="top"><a id="a6104c23316933b74de2bed918f85f3f1"></a>
std::vector&lt; <a class="el" href="structcgv_1_1base_1_1registration__order__info.html">registration_order_info</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>ref_registration_order_infos</b> ()</td></tr>
<tr class="separator:a6104c23316933b74de2bed918f85f3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6332840c11958632111f8b73472b32e"><td class="memItemLeft" align="right" valign="top"><a id="ac6332840c11958632111f8b73472b32e"></a>
<a class="el" href="structcgv_1_1base_1_1registration__info.html">registration_info</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>ref_info</b> ()</td></tr>
<tr class="separator:ac6332840c11958632111f8b73472b32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96231d3482baebc956228d6e0565884"><td class="memItemLeft" align="right" valign="top"><a id="ab96231d3482baebc956228d6e0565884"></a>
std::vector&lt; std::pair&lt; <a class="el" href="namespacecgv_1_1base.html#a580333ed27888f5e8c61452a44545f51">base_ptr</a>, std::string &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>ref_registration_events</b> ()</td></tr>
<tr class="separator:ab96231d3482baebc956228d6e0565884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4da192dd70b1d5d994593306fdf3bf0"><td class="memItemLeft" align="right" valign="top"><a id="ad4da192dd70b1d5d994593306fdf3bf0"></a>
std::vector&lt; <a class="el" href="namespacecgv_1_1base.html#a580333ed27888f5e8c61452a44545f51">base_ptr</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>ref_listeners</b> ()</td></tr>
<tr class="separator:ad4da192dd70b1d5d994593306fdf3bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40db102a17f6aaaae77e1ced6746be6b"><td class="memItemLeft" align="right" valign="top"><a id="a40db102a17f6aaaae77e1ced6746be6b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>show_split_lines</b> (const std::string &amp;s)</td></tr>
<tr class="separator:a40db102a17f6aaaae77e1ced6746be6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621ec980ef05d7d5d6e67003aa795fdc"><td class="memItemLeft" align="right" valign="top"><a id="a621ec980ef05d7d5d6e67003aa795fdc"></a>
bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>ref_registration_debugging_enabled</b> ()</td></tr>
<tr class="separator:a621ec980ef05d7d5d6e67003aa795fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a518ad08502f6dc272119059624ee85"><td class="memItemLeft" align="right" valign="top"><a id="a4a518ad08502f6dc272119059624ee85"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>show_object_debug_info</b> (<a class="el" href="namespacecgv_1_1base.html#a580333ed27888f5e8c61452a44545f51">cgv::base::base_ptr</a> o)</td></tr>
<tr class="separator:a4a518ad08502f6dc272119059624ee85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e53bf7a9d7dbd6173cf988e3b2b6b92"><td class="memItemLeft" align="right" valign="top"><a id="a0e53bf7a9d7dbd6173cf988e3b2b6b92"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a0e53bf7a9d7dbd6173cf988e3b2b6b92">register_object_internal</a> (<a class="el" href="namespacecgv_1_1base.html#a580333ed27888f5e8c61452a44545f51">base_ptr</a> object, const std::string &amp;options)</td></tr>
<tr class="memdesc:a0e53bf7a9d7dbd6173cf988e3b2b6b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">register an object and send event to all current registration ref_listeners() <br /></td></tr>
<tr class="separator:a0e53bf7a9d7dbd6173cf988e3b2b6b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9cadf53c2c4685204eb00a8d8cb1afd"><td class="memItemLeft" align="right" valign="top"><a id="aa9cadf53c2c4685204eb00a8d8cb1afd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>add_partially_ordered</b> (const std::vector&lt; std::set&lt; unsigned &gt;&gt; &amp;combined_partial_order, std::vector&lt; unsigned &gt; &amp;permutation, std::vector&lt; bool &gt; &amp;appended, std::vector&lt; bool &gt; &amp;delayed, unsigned i)</td></tr>
<tr class="separator:aa9cadf53c2c4685204eb00a8d8cb1afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843f5fdf93ce34b75e83e3ca6dfe0ef5"><td class="memItemLeft" align="right" valign="top"><a id="a843f5fdf93ce34b75e83e3ca6dfe0ef5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sort_registration_events</b> (bool before_contructor_execution)</td></tr>
<tr class="separator:a843f5fdf93ce34b75e83e3ca6dfe0ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae8243ecb0a51ebbf4e90f92aec843a"><td class="memItemLeft" align="right" valign="top"><a id="a7ae8243ecb0a51ebbf4e90f92aec843a"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>get_config_file_name</b> (const std::string &amp;_file_name)</td></tr>
<tr class="separator:a7ae8243ecb0a51ebbf4e90f92aec843a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e7e04cc525adc87b070cd6a5f912be"><td class="memItemLeft" align="right" valign="top"><a id="aa1e7e04cc525adc87b070cd6a5f912be"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>process_command_ext</b> (const <a class="el" href="structcgv_1_1base_1_1command__info.html">command_info</a> &amp;info, bool *persistent=0, <a class="el" href="structcgv_1_1base_1_1config__file__observer.html">config_file_observer</a> *cfo=0, const char *begin=0)</td></tr>
<tr class="separator:aa1e7e04cc525adc87b070cd6a5f912be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e4977e2baff9ae197dae19217b6a23"><td class="memItemLeft" align="right" valign="top"><a id="a29e4977e2baff9ae197dae19217b6a23"></a>
<a class="el" href="structcgv_1_1base_1_1config__file__driver.html">config_file_driver</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><b>ref_config_file_driver</b> ()</td></tr>
<tr class="separator:a29e4977e2baff9ae197dae19217b6a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b956fef830cd1c22a9492ef058879b8"><td class="memItemLeft" align="right" valign="top"><a id="a0b956fef830cd1c22a9492ef058879b8"></a>
<a class="el" href="structcgv_1_1base_1_1config__file__observer.html">config_file_observer</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>find_config_file_observer</b> (const std::string &amp;file_name, const std::string &amp;content)</td></tr>
<tr class="separator:a0b956fef830cd1c22a9492ef058879b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ddf9c063fc873cf927aadea2b0612c"><td class="memItemLeft" align="right" valign="top"><a id="a02ddf9c063fc873cf927aadea2b0612c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>process_config_file_ext</b> (const std::string &amp;_file_name, bool *persistent=0)</td></tr>
<tr class="separator:a02ddf9c063fc873cf927aadea2b0612c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154895408bcc9f6cc718245754e1d675"><td class="memItemLeft" align="right" valign="top"><a id="a154895408bcc9f6cc718245754e1d675"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>show_implementation</b> (bool &amp;implements_shown, const std::string &amp;type_name)</td></tr>
<tr class="separator:a154895408bcc9f6cc718245754e1d675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2655c799aceb9fc94d559dbcf1d3a59"><td class="memItemLeft" align="right" valign="top"><a id="aa2655c799aceb9fc94d559dbcf1d3a59"></a>
<a class="el" href="namespacecgv_1_1base.html#a836526596df30a9ba628d7fd61aa2c76">CommandType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>update_info</b> (<a class="el" href="structcgv_1_1base_1_1command__info.html">command_info</a> *info_ptr, <a class="el" href="namespacecgv_1_1base.html#a836526596df30a9ba628d7fd61aa2c76">CommandType</a> cmd, <a class="el" href="structcgv_1_1utils_1_1token.html">cgv::utils::token</a> *args_tok_ptr=0)</td></tr>
<tr class="separator:aa2655c799aceb9fc94d559dbcf1d3a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7beb1ad3036e85670fc651a1e95c0dba"><td class="memItemLeft" align="right" valign="top"><a id="a7beb1ad3036e85670fc651a1e95c0dba"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>extend_plugin_name</b> (const std::string &amp;fn)</td></tr>
<tr class="separator:a7beb1ad3036e85670fc651a1e95c0dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8d5d47876a892bb6a219bbafd68fb2"><td class="memItemLeft" align="right" valign="top"><a id="a2a8d5d47876a892bb6a219bbafd68fb2"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>load_plugin_platform</b> (const std::string &amp;name)</td></tr>
<tr class="separator:a2a8d5d47876a892bb6a219bbafd68fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de6c572b9912f7cf91ba474a0b42c93"><td class="memItemLeft" align="right" valign="top"><a id="a3de6c572b9912f7cf91ba474a0b42c93"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>record_error_platform</b> (const std::string &amp;dll_name, std::vector&lt; std::string &gt; &amp;errors)</td></tr>
<tr class="separator:a3de6c572b9912f7cf91ba474a0b42c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cab998d2f55de7a741cb22aba508cfe"><td class="memTemplParams" colspan="2"><a id="a1cab998d2f55de7a741cb22aba508cfe"></a>
template&lt;class X &gt; </td></tr>
<tr class="memitem:a1cab998d2f55de7a741cb22aba508cfe"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a1cab998d2f55de7a741cb22aba508cfe">grab_focus</a> (X *instance)</td></tr>
<tr class="memdesc:a1cab998d2f55de7a741cb22aba508cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">try to grab the focus in the path of this node to the root of the tree <br /></td></tr>
<tr class="separator:a1cab998d2f55de7a741cb22aba508cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">processing of command line arguments</div></td></tr>
<tr class="memitem:ad93720e2cf9340ea50de0b91267680d4"><td class="memItemLeft" align="right" valign="top"><a id="ad93720e2cf9340ea50de0b91267680d4"></a>
std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#ad93720e2cf9340ea50de0b91267680d4">ref_prog_name</a> ()</td></tr>
<tr class="memdesc:ad93720e2cf9340ea50de0b91267680d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a refence to the name of the started executable <br /></td></tr>
<tr class="separator:ad93720e2cf9340ea50de0b91267680d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3f2914d2fbd3613a83eaeaf8744513"><td class="memItemLeft" align="right" valign="top"><a id="a4a3f2914d2fbd3613a83eaeaf8744513"></a>
std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a4a3f2914d2fbd3613a83eaeaf8744513">ref_prog_path_prefix</a> ()</td></tr>
<tr class="memdesc:a4a3f2914d2fbd3613a83eaeaf8744513"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a refence to the path prefix of the started executable, this can be prepended for example to dll names <br /></td></tr>
<tr class="separator:a4a3f2914d2fbd3613a83eaeaf8744513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4204680cce6ce77447fcab18a7fab0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a9e4204680cce6ce77447fcab18a7fab0">register_prog_name</a> (const char *prog_name)</td></tr>
<tr class="memdesc:a9e4204680cce6ce77447fcab18a7fab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the file name of the current program.  <a href="namespacecgv_1_1base.html#a9e4204680cce6ce77447fcab18a7fab0">More...</a><br /></td></tr>
<tr class="separator:a9e4204680cce6ce77447fcab18a7fab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9656474bcbb2a4b09c8e557a1e5621c"><td class="memItemLeft" align="right" valign="top"><a id="ab9656474bcbb2a4b09c8e557a1e5621c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#ab9656474bcbb2a4b09c8e557a1e5621c">process_command_line_args</a> (int argc, char **argv)</td></tr>
<tr class="memdesc:ab9656474bcbb2a4b09c8e557a1e5621c"><td class="mdescLeft">&#160;</td><td class="mdescRight">process the command line arguments: extract program name and load all plugins <br /></td></tr>
<tr class="separator:ab9656474bcbb2a4b09c8e557a1e5621c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">loading of plugins</div></td></tr>
<tr class="memitem:a59a17104b8a82638de4aab8ccfb72db2"><td class="memItemLeft" align="right" valign="top"><a id="a59a17104b8a82638de4aab8ccfb72db2"></a>
std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a59a17104b8a82638de4aab8ccfb72db2">ref_plugin_name</a> ()</td></tr>
<tr class="memdesc:a59a17104b8a82638de4aab8ccfb72db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a reference to the currently loaded plugin <br /></td></tr>
<tr class="separator:a59a17104b8a82638de4aab8ccfb72db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf58539e451af7248fa0d2e64bbb48f5"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#acf58539e451af7248fa0d2e64bbb48f5">load_plugin</a> (const std::string &amp;file_name)</td></tr>
<tr class="memdesc:acf58539e451af7248fa0d2e64bbb48f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">load a plugin or dll and return a handle to the plugin, or 0 if loading was not successful.  <a href="namespacecgv_1_1base.html#acf58539e451af7248fa0d2e64bbb48f5">More...</a><br /></td></tr>
<tr class="separator:acf58539e451af7248fa0d2e64bbb48f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e8d418aa5f0c3f548c99cd63d35170"><td class="memItemLeft" align="right" valign="top"><a id="af6e8d418aa5f0c3f548c99cd63d35170"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#af6e8d418aa5f0c3f548c99cd63d35170">unload_plugin</a> (void *handle)</td></tr>
<tr class="memdesc:af6e8d418aa5f0c3f548c99cd63d35170"><td class="mdescLeft">&#160;</td><td class="mdescRight">unload the plugin with the given handle <br /></td></tr>
<tr class="separator:af6e8d418aa5f0c3f548c99cd63d35170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">control over the registration process</div></td></tr>
<tr class="memitem:ada908977e738c6da6230a698912bebc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#ada908977e738c6da6230a698912bebc4">define_registration_order</a> (const std::string &amp;partial_order, bool before_contructor_execution=false, const std::string &amp;when=&quot;always&quot;)</td></tr>
<tr class="memdesc:ada908977e738c6da6230a698912bebc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">specify a partial order of objects for registration  <a href="namespacecgv_1_1base.html#ada908977e738c6da6230a698912bebc4">More...</a><br /></td></tr>
<tr class="separator:ada908977e738c6da6230a698912bebc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b449c961c99bd6ace1d2cb09f876558"><td class="memItemLeft" align="right" valign="top"><a id="a6b449c961c99bd6ace1d2cb09f876558"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a6b449c961c99bd6ace1d2cb09f876558">enable_registration_debugging</a> ()</td></tr>
<tr class="memdesc:a6b449c961c99bd6ace1d2cb09f876558"><td class="mdescLeft">&#160;</td><td class="mdescRight">enable registration debugging <br /></td></tr>
<tr class="separator:a6b449c961c99bd6ace1d2cb09f876558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd883d8e83fdda7701bbb4df7c4a02f"><td class="memItemLeft" align="right" valign="top"><a id="aafd883d8e83fdda7701bbb4df7c4a02f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#aafd883d8e83fdda7701bbb4df7c4a02f">disable_registration_debugging</a> ()</td></tr>
<tr class="memdesc:aafd883d8e83fdda7701bbb4df7c4a02f"><td class="mdescLeft">&#160;</td><td class="mdescRight">disable registration debugging <br /></td></tr>
<tr class="separator:aafd883d8e83fdda7701bbb4df7c4a02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95cf5331cfb8ec9a13997240fbbc1a3a"><td class="memItemLeft" align="right" valign="top"><a id="a95cf5331cfb8ec9a13997240fbbc1a3a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a95cf5331cfb8ec9a13997240fbbc1a3a">is_registration_debugging_enabled</a> ()</td></tr>
<tr class="memdesc:a95cf5331cfb8ec9a13997240fbbc1a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether registration debugging is enabled <br /></td></tr>
<tr class="separator:a95cf5331cfb8ec9a13997240fbbc1a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa839bf46a9e8abb32cfea4964ec91507"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#aa839bf46a9e8abb32cfea4964ec91507">enable_registration</a> ()</td></tr>
<tr class="memdesc:aa839bf46a9e8abb32cfea4964ec91507"><td class="mdescLeft">&#160;</td><td class="mdescRight">enable registration and send all registration events that where emitted during disabled registration  <a href="namespacecgv_1_1base.html#aa839bf46a9e8abb32cfea4964ec91507">More...</a><br /></td></tr>
<tr class="separator:aa839bf46a9e8abb32cfea4964ec91507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b14a0db38dca07762d43ca30f801ac8"><td class="memItemLeft" align="right" valign="top"><a id="a5b14a0db38dca07762d43ca30f801ac8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a5b14a0db38dca07762d43ca30f801ac8">disable_registration</a> ()</td></tr>
<tr class="memdesc:a5b14a0db38dca07762d43ca30f801ac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">if registration is disable, all registration events are stored and sent at the momement when registration is enabled again. This feature is used when loading dlls <br /></td></tr>
<tr class="separator:a5b14a0db38dca07762d43ca30f801ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d35f03b0d843ceb855119ab9beb635"><td class="memItemLeft" align="right" valign="top"><a id="a89d35f03b0d843ceb855119ab9beb635"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a89d35f03b0d843ceb855119ab9beb635">is_registration_enabled</a> ()</td></tr>
<tr class="memdesc:a89d35f03b0d843ceb855119ab9beb635"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether registration is enabled <br /></td></tr>
<tr class="separator:a89d35f03b0d843ceb855119ab9beb635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae3b2736b2b16c7a929f0326d894be1"><td class="memItemLeft" align="right" valign="top"><a id="a4ae3b2736b2b16c7a929f0326d894be1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a4ae3b2736b2b16c7a929f0326d894be1">enable_permanent_registration</a> ()</td></tr>
<tr class="memdesc:a4ae3b2736b2b16c7a929f0326d894be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">register a registration listener that stores pointers to all registered objects <br /></td></tr>
<tr class="separator:a4ae3b2736b2b16c7a929f0326d894be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1394cdecb082f474bd1d84bc3f4455"><td class="memItemLeft" align="right" valign="top"><a id="a3a1394cdecb082f474bd1d84bc3f4455"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a3a1394cdecb082f474bd1d84bc3f4455">unregister_all_objects</a> ()</td></tr>
<tr class="memdesc:a3a1394cdecb082f474bd1d84bc3f4455"><td class="mdescLeft">&#160;</td><td class="mdescRight">unregister all existing objects to clean up <br /></td></tr>
<tr class="separator:a3a1394cdecb082f474bd1d84bc3f4455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ab6cc2e6a5c6013411e8642057fa8b"><td class="memItemLeft" align="right" valign="top"><a id="a90ab6cc2e6a5c6013411e8642057fa8b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a90ab6cc2e6a5c6013411e8642057fa8b">request_exit_from_all_objects</a> ()</td></tr>
<tr class="memdesc:a90ab6cc2e6a5c6013411e8642057fa8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">calls the on_exit_request method for all registered objects and return true if exiting is allowed <br /></td></tr>
<tr class="separator:a90ab6cc2e6a5c6013411e8642057fa8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1214b0c26c2b31e207cc386e7c1aa856"><td class="memItemLeft" align="right" valign="top"><a id="a1214b0c26c2b31e207cc386e7c1aa856"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a1214b0c26c2b31e207cc386e7c1aa856">get_nr_permanently_registered_objects</a> ()</td></tr>
<tr class="memdesc:a1214b0c26c2b31e207cc386e7c1aa856"><td class="mdescLeft">&#160;</td><td class="mdescRight">access to number of permanently registered objects <br /></td></tr>
<tr class="separator:a1214b0c26c2b31e207cc386e7c1aa856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ceca4778b81eaa3a7d0c0e0e8c10c8f"><td class="memItemLeft" align="right" valign="top"><a id="a5ceca4778b81eaa3a7d0c0e0e8c10c8f"></a>
<a class="el" href="namespacecgv_1_1base.html#a580333ed27888f5e8c61452a44545f51">base_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a5ceca4778b81eaa3a7d0c0e0e8c10c8f">get_permanently_registered_object</a> (unsigned i)</td></tr>
<tr class="memdesc:a5ceca4778b81eaa3a7d0c0e0e8c10c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">access to i-th permanently registered object <br /></td></tr>
<tr class="separator:a5ceca4778b81eaa3a7d0c0e0e8c10c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2a931ed984065eaf2bd3ec95624147"><td class="memItemLeft" align="right" valign="top"><a id="a8e2a931ed984065eaf2bd3ec95624147"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a8e2a931ed984065eaf2bd3ec95624147">disable_permanent_registration</a> ()</td></tr>
<tr class="memdesc:a8e2a931ed984065eaf2bd3ec95624147"><td class="mdescLeft">&#160;</td><td class="mdescRight">deregister registration listener and dereference pointers to registered objects <br /></td></tr>
<tr class="separator:a8e2a931ed984065eaf2bd3ec95624147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7e83d1235ad1cef1b948d2e23c7b0e"><td class="memItemLeft" align="right" valign="top"><a id="aee7e83d1235ad1cef1b948d2e23c7b0e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#aee7e83d1235ad1cef1b948d2e23c7b0e">is_permanent_registration_enabled</a> ()</td></tr>
<tr class="memdesc:aee7e83d1235ad1cef1b948d2e23c7b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether permanent registration is enabled <br /></td></tr>
<tr class="separator:aee7e83d1235ad1cef1b948d2e23c7b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5972c6c1a1833e46393f9361ea2b860a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a5972c6c1a1833e46393f9361ea2b860a">enable_registration_event_cleanup</a> ()</td></tr>
<tr class="memdesc:a5972c6c1a1833e46393f9361ea2b860a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable cleanup of registration events (default).  <a href="namespacecgv_1_1base.html#a5972c6c1a1833e46393f9361ea2b860a">More...</a><br /></td></tr>
<tr class="separator:a5972c6c1a1833e46393f9361ea2b860a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed67b035bb486ec604fdc4f8362c747"><td class="memItemLeft" align="right" valign="top"><a id="aeed67b035bb486ec604fdc4f8362c747"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#aeed67b035bb486ec604fdc4f8362c747">disable_registration_event_cleanup</a> ()</td></tr>
<tr class="memdesc:aeed67b035bb486ec604fdc4f8362c747"><td class="mdescLeft">&#160;</td><td class="mdescRight">disable cleanup of registration events (see enable_registration_event_cleanup). <br /></td></tr>
<tr class="separator:aeed67b035bb486ec604fdc4f8362c747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff7ef0d5cef1d3318bfd315e73d7834"><td class="memItemLeft" align="right" valign="top"><a id="a6ff7ef0d5cef1d3318bfd315e73d7834"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a6ff7ef0d5cef1d3318bfd315e73d7834">is_registration_event_cleanup_enabled</a> ()</td></tr>
<tr class="memdesc:a6ff7ef0d5cef1d3318bfd315e73d7834"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether registration cleanup is enabled <br /></td></tr>
<tr class="separator:a6ff7ef0d5cef1d3318bfd315e73d7834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">object registration</div></td></tr>
<tr class="memitem:ad3783da9c295a7c532f2ea35d2a06abb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#ad3783da9c295a7c532f2ea35d2a06abb">register_object</a> (<a class="el" href="namespacecgv_1_1base.html#a580333ed27888f5e8c61452a44545f51">base_ptr</a> object, const std::string &amp;options)</td></tr>
<tr class="memdesc:ad3783da9c295a7c532f2ea35d2a06abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">register an object and send event to all current registration ref_listeners()  <a href="namespacecgv_1_1base.html#ad3783da9c295a7c532f2ea35d2a06abb">More...</a><br /></td></tr>
<tr class="separator:ad3783da9c295a7c532f2ea35d2a06abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6cfc52fcd0ab300675162f464038e45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#aa6cfc52fcd0ab300675162f464038e45">unregister_object</a> (<a class="el" href="namespacecgv_1_1base.html#a580333ed27888f5e8c61452a44545f51">base_ptr</a> object, const std::string &amp;options)</td></tr>
<tr class="memdesc:aa6cfc52fcd0ab300675162f464038e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">unregister an object and send event to all current registration ref_listeners()  <a href="namespacecgv_1_1base.html#aa6cfc52fcd0ab300675162f464038e45">More...</a><br /></td></tr>
<tr class="separator:aa6cfc52fcd0ab300675162f464038e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">configuration and gui files</div></td></tr>
<tr class="memitem:a6f26c596a7d1653508dcf0f1739040da"><td class="memItemLeft" align="right" valign="top"><a id="a6f26c596a7d1653508dcf0f1739040da"></a>
<a class="el" href="namespacecgv_1_1base.html#abfcd30049d34b52e335da99b47c3979d">named_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a6f26c596a7d1653508dcf0f1739040da">find_object_by_name</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a6f26c596a7d1653508dcf0f1739040da"><td class="mdescLeft">&#160;</td><td class="mdescRight">in case permanent registration is active, look for a registered object by name <br /></td></tr>
<tr class="separator:a6f26c596a7d1653508dcf0f1739040da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9a67761bb0d9e72dfb91924fded64f"><td class="memItemLeft" align="right" valign="top"><a id="add9a67761bb0d9e72dfb91924fded64f"></a>
<a class="el" href="namespacecgv_1_1base.html#a580333ed27888f5e8c61452a44545f51">base_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#add9a67761bb0d9e72dfb91924fded64f">find_object_by_type</a> (const std::string &amp;type_name)</td></tr>
<tr class="memdesc:add9a67761bb0d9e72dfb91924fded64f"><td class="mdescLeft">&#160;</td><td class="mdescRight">in case permanent registration is active, look for a registered object by type name <br /></td></tr>
<tr class="separator:add9a67761bb0d9e72dfb91924fded64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a10347f7bb1ff69bcf6a43cd7d2e891"><td class="memItemLeft" align="right" valign="top"><a id="a8a10347f7bb1ff69bcf6a43cd7d2e891"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a8a10347f7bb1ff69bcf6a43cd7d2e891">register_config_file_driver</a> (<a class="el" href="structcgv_1_1base_1_1config__file__driver.html">config_file_driver</a> *cfd)</td></tr>
<tr class="memdesc:a8a10347f7bb1ff69bcf6a43cd7d2e891"><td class="mdescLeft">&#160;</td><td class="mdescRight">method to register a <a class="el" href="structcgv_1_1base_1_1config__file__driver.html" title="abstract interface for a config file driver that handles permanent registration and gui config files.">config_file_driver</a> <br /></td></tr>
<tr class="separator:a8a10347f7bb1ff69bcf6a43cd7d2e891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2406c2621b5dfd2f92d3384e9b14189"><td class="memItemLeft" align="right" valign="top"><a id="af2406c2621b5dfd2f92d3384e9b14189"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#af2406c2621b5dfd2f92d3384e9b14189">process_config_file</a> (const std::string &amp;file_name)</td></tr>
<tr class="memdesc:af2406c2621b5dfd2f92d3384e9b14189"><td class="mdescLeft">&#160;</td><td class="mdescRight">interpret a config file <br /></td></tr>
<tr class="separator:af2406c2621b5dfd2f92d3384e9b14189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6fa99b284a53727252312a9814a263a"><td class="memItemLeft" align="right" valign="top"><a id="ac6fa99b284a53727252312a9814a263a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#ac6fa99b284a53727252312a9814a263a">process_gui_file</a> (const std::string &amp;file_name)</td></tr>
<tr class="memdesc:ac6fa99b284a53727252312a9814a263a"><td class="mdescLeft">&#160;</td><td class="mdescRight">interpret a gui file <br /></td></tr>
<tr class="separator:ac6fa99b284a53727252312a9814a263a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">support for driver, listener and factory registration</div></td></tr>
<tr class="memitem:ad6955e267d77503183deb29807c66220"><td class="memItemLeft" align="right" valign="top"><a id="ad6955e267d77503183deb29807c66220"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>guess_created_type_name</b> (const char *item_text)</td></tr>
<tr class="separator:ad6955e267d77503183deb29807c66220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712a9a905b92e4f0377a0033fc9707f1"><td class="memItemLeft" align="right" valign="top"><a id="a712a9a905b92e4f0377a0033fc9707f1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>register_factory_object</b> (<a class="el" href="namespacecgv_1_1base.html#a580333ed27888f5e8c61452a44545f51">base_ptr</a> fo, const char *item_text, char shortcut)</td></tr>
<tr class="separator:a712a9a905b92e4f0377a0033fc9707f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">processing of commands</div></td></tr>
<tr class="memitem:aa66b1e03845e1311a99a38fd276e7233"><td class="memItemLeft" align="right" valign="top"><a id="aa66b1e03845e1311a99a38fd276e7233"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#aa66b1e03845e1311a99a38fd276e7233">show_all</a> ()</td></tr>
<tr class="memdesc:aa66b1e03845e1311a99a38fd276e7233"><td class="mdescLeft">&#160;</td><td class="mdescRight">show information about all registered members <br /></td></tr>
<tr class="separator:aa66b1e03845e1311a99a38fd276e7233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e0e3861c731016fa00726b7e17eadd1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a5e0e3861c731016fa00726b7e17eadd1">process_command</a> (const std::string &amp;cmd, bool eliminate_quotes=true)</td></tr>
<tr class="memdesc:a5e0e3861c731016fa00726b7e17eadd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">process a command given as string.  <a href="namespacecgv_1_1base.html#a5e0e3861c731016fa00726b7e17eadd1">More...</a><br /></td></tr>
<tr class="separator:a5e0e3861c731016fa00726b7e17eadd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a137ffca4a7cfa331f721e66fdddb8014"><td class="memItemLeft" align="right" valign="top"><a id="a137ffca4a7cfa331f721e66fdddb8014"></a>
class CGV_API&#160;</td><td class="memItemRight" valign="bottom"><b>traverse_policy</b></td></tr>
<tr class="separator:a137ffca4a7cfa331f721e66fdddb8014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad138e494f0c83d38302044b6be4b302b"><td class="memItemLeft" align="right" valign="top"><a id="ad138e494f0c83d38302044b6be4b302b"></a>
class CGV_API&#160;</td><td class="memItemRight" valign="bottom"><b>base</b></td></tr>
<tr class="separator:ad138e494f0c83d38302044b6be4b302b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84098e3e27c55741a5a5347ceb08ecd2"><td class="memItemLeft" align="right" valign="top"><a id="a84098e3e27c55741a5a5347ceb08ecd2"></a>
class CGV_API&#160;</td><td class="memItemRight" valign="bottom"><b>named</b></td></tr>
<tr class="separator:a84098e3e27c55741a5a5347ceb08ecd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7fa38c53b0ffc33d227970caf36005"><td class="memItemLeft" align="right" valign="top"><a id="a7d7fa38c53b0ffc33d227970caf36005"></a>
class CGV_API&#160;</td><td class="memItemRight" valign="bottom"><b>node</b></td></tr>
<tr class="separator:a7d7fa38c53b0ffc33d227970caf36005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3163370d019051e0af98d802e88a4e1b"><td class="memItemLeft" align="right" valign="top"><a id="a3163370d019051e0af98d802e88a4e1b"></a>
class CGV_API&#160;</td><td class="memItemRight" valign="bottom"><b>group</b></td></tr>
<tr class="separator:a3163370d019051e0af98d802e88a4e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">resource file registration</h2></td></tr>
<tr class="memitem:a836526596df30a9ba628d7fd61aa2c76"><td class="memItemLeft" align="right" valign="top"><a id="a836526596df30a9ba628d7fd61aa2c76"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a836526596df30a9ba628d7fd61aa2c76">CommandType</a> { <br />
&#160;&#160;<b>CT_UNKNOWN</b>
, <b>CT_EMPTY</b>
, <b>CT_COMMENT</b>
, <b>CT_SHOW</b>
, <br />
&#160;&#160;<b>CT_PERSISTENT</b>
, <b>CT_INITIAL</b>
, <b>CT_PLUGIN</b>
, <b>CT_CONFIG</b>
, <br />
&#160;&#160;<b>CT_GUI</b>
, <b>CT_NAME</b>
, <b>CT_TYPE</b>
<br />
 }</td></tr>
<tr class="memdesc:a836526596df30a9ba628d7fd61aa2c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">enumerate type for all command types supported in configuration files <br /></td></tr>
<tr class="separator:a836526596df30a9ba628d7fd61aa2c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba72200bc48e79f8a676410773a8345c"><td class="memItemLeft" align="right" valign="top"><a id="aba72200bc48e79f8a676410773a8345c"></a>
std::map&lt; std::string, <a class="el" href="structcgv_1_1base_1_1resource__file__info.html">resource_file_info</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#aba72200bc48e79f8a676410773a8345c">ref_resource_file_map</a> ()</td></tr>
<tr class="memdesc:aba72200bc48e79f8a676410773a8345c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a reference to a mapping of resource file names to resource file infos <br /></td></tr>
<tr class="separator:aba72200bc48e79f8a676410773a8345c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af8d5888d85f940a5190c1f0ff9436b"><td class="memItemLeft" align="right" valign="top"><a id="a8af8d5888d85f940a5190c1f0ff9436b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a8af8d5888d85f940a5190c1f0ff9436b">register_resource_file</a> (const std::string &amp;file_path, unsigned int file_offset, unsigned int file_length, const char *file_data, const std::string &amp;source_file=&quot;&quot;)</td></tr>
<tr class="memdesc:a8af8d5888d85f940a5190c1f0ff9436b"><td class="mdescLeft">&#160;</td><td class="mdescRight">register a resource file <br /></td></tr>
<tr class="separator:a8af8d5888d85f940a5190c1f0ff9436b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a2af3c072c02cfb161f8255dd6a94c"><td class="memItemLeft" align="right" valign="top"><a id="ad2a2af3c072c02cfb161f8255dd6a94c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#ad2a2af3c072c02cfb161f8255dd6a94c">register_resource_string</a> (const std::string &amp;string_name, const char *string_data)</td></tr>
<tr class="memdesc:ad2a2af3c072c02cfb161f8255dd6a94c"><td class="mdescLeft">&#160;</td><td class="mdescRight">register a resource string <br /></td></tr>
<tr class="separator:ad2a2af3c072c02cfb161f8255dd6a94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c6f4c42602d5fdda61e603f5cbe25e"><td class="memItemLeft" align="right" valign="top"><a id="a78c6f4c42602d5fdda61e603f5cbe25e"></a>
<a class="el" href="namespacecgv_1_1base.html#a836526596df30a9ba628d7fd61aa2c76">CommandType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a78c6f4c42602d5fdda61e603f5cbe25e">analyze_command</a> (const <a class="el" href="structcgv_1_1utils_1_1token.html">cgv::utils::token</a> &amp;cmd, bool eliminate_quotes=true, <a class="el" href="structcgv_1_1base_1_1command__info.html">command_info</a> *info_ptr=0)</td></tr>
<tr class="memdesc:a78c6f4c42602d5fdda61e603f5cbe25e"><td class="mdescLeft">&#160;</td><td class="mdescRight">parse a command and optionally store result in the command info, returns the command type <br /></td></tr>
<tr class="separator:a78c6f4c42602d5fdda61e603f5cbe25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db812e195f6d3578be37667b1370ff5"><td class="memItemLeft" align="right" valign="top"><a id="a3db812e195f6d3578be37667b1370ff5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a3db812e195f6d3578be37667b1370ff5">process_command</a> (const <a class="el" href="structcgv_1_1base_1_1command__info.html">command_info</a> &amp;info)</td></tr>
<tr class="memdesc:a3db812e195f6d3578be37667b1370ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">process a command given by a command info structure, return whether command was processed correctly <br /></td></tr>
<tr class="separator:a3db812e195f6d3578be37667b1370ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>the base namespace holds the base hierarchy, support for plugin registration and signals </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a746925f26d076c26742b2dc558cbae36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a746925f26d076c26742b2dc558cbae36">&#9670;&nbsp;</a></span>TraversePolicy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecgv_1_1base.html#a746925f26d076c26742b2dc558cbae36">cgv::base::TraversePolicy</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>different traversal policies </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a746925f26d076c26742b2dc558cbae36a4dd87fc30d8a2e369fe315eb9ccde557"></a>TP_ONLY_FOCUS&#160;</td><td class="fielddoc"><p>traverse all children </p>
</td></tr>
<tr><td class="fieldname"><a id="a746925f26d076c26742b2dc558cbae36a69ee76315433dc44f8bfa441afefa249"></a>TP_FIRST_FOCUS&#160;</td><td class="fielddoc"><p>traverse only the focused child </p>
</td></tr>
<tr><td class="fieldname"><a id="a746925f26d076c26742b2dc558cbae36a169ba2fab3a13ea551eb8d8800e459bb"></a>TP_AUTO_FOCUS&#160;</td><td class="fielddoc"><p>first traverse focused and then the remaining children </p>
</td></tr>
<tr><td class="fieldname"><a id="a746925f26d076c26742b2dc558cbae36a7b2b5c718b50e4241491dcb951599a8b"></a>TP_STOP_ON_SUCCESS&#160;</td><td class="fielddoc"><p>like previous but change focus to the child, where traversal succeeded </p>
</td></tr>
<tr><td class="fieldname"><a id="a746925f26d076c26742b2dc558cbae36a33806b12ea827401e0a110036ddbeabe"></a>TP_STOP_ON_FAILURE&#160;</td><td class="fielddoc"><p>this is an optional flag for traversals with methods that return a bool. If the returned bool is true, traversal stops if this flag is set </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="traverser_8h_source.html#l00013">13</a> of file <a class="el" href="traverser_8h_source.html">traverser.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac56137cd8bf24c23f7f6ef15a417bbdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac56137cd8bf24c23f7f6ef15a417bbdd">&#9670;&nbsp;</a></span>attach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CGV_API bool cgv::base::attach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecgv_1_1base.html#a580333ed27888f5e8c61452a44545f51">base_ptr</a>&#160;</td>
          <td class="paramname"><em>slot_object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecgv_1_1base.html#a580333ed27888f5e8c61452a44545f51">base_ptr</a>&#160;</td>
          <td class="paramname"><em>attachment_object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function to attach an object to an object of type <a class="el" href="classcgv_1_1base_1_1attach__slot.html" title="interface for an attachment slot that can store a base pointer">attach_slot</a>. </p>
<p>Return whether the slot_object implements the <a class="el" href="classcgv_1_1base_1_1attach__slot.html" title="interface for an attachment slot that can store a base pointer">attach_slot</a> interface and could retreive the attachment. </p>

<p class="definition">Definition at line <a class="el" href="attach__slot_8cxx_source.html#l00038">38</a> of file <a class="el" href="attach__slot_8cxx_source.html">attach_slot.cxx</a>.</p>

<p class="reference">References <a class="el" href="attach__slot_8cxx_source.html#l00014">cgv::base::attach_slot::attach()</a>, and <a class="el" href="base_8h_source.html#l00128">cgv::base::base::get_interface()</a>.</p>

</div>
</div>
<a id="ada908977e738c6da6230a698912bebc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada908977e738c6da6230a698912bebc4">&#9670;&nbsp;</a></span>define_registration_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CGV_API cgv::base::define_registration_order </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>partial_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>before_contructor_execution</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>when</em> = <code>&quot;always&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>specify a partial order of objects for registration </p>
<p><code>partial_order</code> is a semicolon separated list of type names that can ignore name spaces. <code>before_constructor_execution</code> tells whether the reordering should happen before constructors of delayed registration events are called. <code>when</code> specifies in which call to <code>enable_registration</code> the reordering should happen. Possible values are</p><ul>
<li>"always"</li>
<li>"program" only once for the enable event of the executed program</li>
<li>"plugins" for enable events of all loaded plugins</li>
<li>&lt;plugin_name&gt; only for the enable event of the plugin with the given name If several partial orders are defined for an enable call, a combined partial order is computed and used to find the order closest to the actual registration order that is in accordance to the combined partial order. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="register_8cxx_source.html#l00247">247</a> of file <a class="el" href="register_8cxx_source.html">register.cxx</a>.</p>

<p class="reference">References <a class="el" href="register_8cxx_source.html#l00247">define_registration_order()</a>.</p>

<p class="reference">Referenced by <a class="el" href="register_8cxx_source.html#l00247">define_registration_order()</a>.</p>

</div>
</div>
<a id="aa839bf46a9e8abb32cfea4964ec91507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa839bf46a9e8abb32cfea4964ec91507">&#9670;&nbsp;</a></span>enable_registration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CGV_API cgv::base::enable_registration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>enable registration and send all registration events that where emitted during disabled registration </p>
<p>Enable registration (default is that registration is disabled).</p>
<p>If registration has been disabled before, send all registration events that where emitted during disabled registration. </p>

<p class="definition">Definition at line <a class="el" href="register_8cxx_source.html#l00381">381</a> of file <a class="el" href="register_8cxx_source.html">register.cxx</a>.</p>

<p class="reference">References <a class="el" href="structcgv_1_1base_1_1object__constructor.html#a9df205baad55e14176d646ab12514c00">cgv::base::object_constructor::construct_object()</a>, <a class="el" href="register_8cxx_source.html#l00381">enable_registration()</a>, <a class="el" href="structcgv_1_1base_1_1object__constructor.html#a2a8df43ff616083096555cce5e743b13">cgv::base::object_constructor::get_constructed_type_name()</a>, <a class="el" href="register_8cxx_source.html#l00376">is_registration_debugging_enabled()</a>, <a class="el" href="register_8cxx_source.html#l00493">is_registration_enabled()</a>, <a class="el" href="register_8cxx_source.html#l00575">is_registration_event_cleanup_enabled()</a>, <a class="el" href="register_8cxx_source.html#l00137">ref_plugin_name()</a>, <a class="el" href="register_8cxx_source.html#l00125">ref_prog_name()</a>, and <a class="el" href="register_8cxx_source.html#l00214">register_object_internal()</a>.</p>

<p class="reference">Referenced by <a class="el" href="register_8cxx_source.html#l00381">enable_registration()</a>, and <a class="el" href="register_8cxx_source.html#l01397">load_plugin()</a>.</p>

</div>
</div>
<a id="a5972c6c1a1833e46393f9361ea2b860a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5972c6c1a1833e46393f9361ea2b860a">&#9670;&nbsp;</a></span>enable_registration_event_cleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CGV_API cgv::base::enable_registration_event_cleanup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable cleanup of registration events (default). </p>
<p>If registration event cleanup is disabled, registration events are not discarded as soon as objects have been registered. This makes objects available to listeners that are registered later. </p>

<p class="definition">Definition at line <a class="el" href="register_8cxx_source.html#l00548">548</a> of file <a class="el" href="register_8cxx_source.html">register.cxx</a>.</p>

<p class="reference">References <a class="el" href="register_8cxx_source.html#l00548">enable_registration_event_cleanup()</a>, <a class="el" href="register_8cxx_source.html#l00376">is_registration_debugging_enabled()</a>, <a class="el" href="register_8cxx_source.html#l00493">is_registration_enabled()</a>, and <a class="el" href="register_8cxx_source.html#l00575">is_registration_event_cleanup_enabled()</a>.</p>

<p class="reference">Referenced by <a class="el" href="register_8cxx_source.html#l00548">enable_registration_event_cleanup()</a>.</p>

</div>
</div>
<a id="ad7a74a3ac59d4a8e5204b1ef742a39fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7a74a3ac59d4a8e5204b1ef742a39fc">&#9670;&nbsp;</a></span>find_data_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CGV_API std::string cgv::base::find_data_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sub_directory</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>master_path</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a file with the given strategy and return the file name extended by the necessary path. </p>
<p>The strategy defines in which search paths the file should be looked for, whether the search paths should be searched recursively and in which order the search paths should be searched (see details below). Optional arguments are a sub_directory and a master_path. For all non recursive searches the sub_directory will be added to each search path and the file is first looked up in the sub_directory. The master_path just defines another search path that can be used by the search strategy.</p>
<p>The search strategy is a string containing one letter for each search command, which are processed in the order of the string. Each capital letter causes a recursive search. The following search commands are available:</p><ul>
<li>r/R ... search resource files (no recursive search necessary as resource files do not have paths) and if found add the prefix "res://" to the file_name</li>
<li>c/C ... search current directory (here no path prefix is used)</li>
<li>m/M ... search master path</li>
<li>d/D ... search all data paths registered in the environment variable CGV_DATA</li>
<li>p/P ... search the path of the parent on the parent path stack that is controlled with <a class="el" href="namespacecgv_1_1base.html#a90c98c559c9c197551a146a91a704e4b" title="extract a valid path from the given argument and push it onto the stack of parent paths....">push_file_parent()</a> and <a class="el" href="namespacecgv_1_1base.html#a8117654ca2eb262f18fc1093c0fdf828" title="pop the latestly pushed parent path from the parent path stack.">pop_file_parent()</a></li>
<li>a/A ... search all anchester paths of the all parents on the parent path stack that is controlled with <a class="el" href="namespacecgv_1_1base.html#a90c98c559c9c197551a146a91a704e4b" title="extract a valid path from the given argument and push it onto the stack of parent paths....">push_file_parent()</a> and <a class="el" href="namespacecgv_1_1base.html#a8117654ca2eb262f18fc1093c0fdf828" title="pop the latestly pushed parent path from the parent path stack.">pop_file_parent()</a> As an example the strategy "cpmD" first looks in the current directory, then in the parent directory, then in the master path and finally recursively in each of the registered data paths. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="import_8cxx_source.html#l00059">59</a> of file <a class="el" href="import_8cxx_source.html">import.cxx</a>.</p>

<p class="reference">References <a class="el" href="import_8cxx_source.html#l00059">find_data_file()</a>, <a class="el" href="import_8cxx_source.html#l00274">ref_data_path_list()</a>, <a class="el" href="import_8cxx_source.html#l00321">ref_parent_file_stack()</a>, and <a class="el" href="register_8cxx_source.html#l00143">ref_resource_file_map()</a>.</p>

<p class="reference">Referenced by <a class="el" href="import_8cxx_source.html#l00059">find_data_file()</a>, <a class="el" href="import_8cxx_source.html#l00159">find_or_download_data_file()</a>, <a class="el" href="vr__render__helpers_8cxx_source.html#l00031">vr::get_vrmesh_render_info()</a>, <a class="el" href="mesh__drawable_8cxx_source.html#l00052">cgv::render::gl::mesh_drawable::read_mesh()</a>, and <a class="el" href="obj__reader_8cxx_source.html#l00311">cgv::media::mesh::obj_reader_base::read_mtl()</a>.</p>

</div>
</div>
<a id="a518b8f3181ba953056ea659173571304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a518b8f3181ba953056ea659173571304">&#9670;&nbsp;</a></span>find_or_download_data_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CGV_API std::string cgv::base::find_or_download_data_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>find_strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cache_strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>producer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sub_directory</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>master_path</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcgv_1_1base_1_1user__feedback.html">user_feedback</a>&#160;</td>
          <td class="paramname"><em>uf</em> = <code><a class="el" href="structcgv_1_1base_1_1user__feedback.html">user_feedback</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>same as <a class="el" href="namespacecgv_1_1base.html#ad7a74a3ac59d4a8e5204b1ef742a39fc" title="Find a file with the given strategy and return the file name extended by the necessary path.">find_data_file()</a> but in case file is not found, it is downloaded from the provided url and stored in a directory searched for with the parameter <code>cache_strategy</code>. </p>
<p>One can use letters as in the <code>strategy</code> parameter to <a class="el" href="namespacecgv_1_1base.html#ad7a74a3ac59d4a8e5204b1ef742a39fc" title="Find a file with the given strategy and return the file name extended by the necessary path.">find_data_file()</a> but recursion and ressources are ignored. With the <code><a class="el" href="structcgv_1_1base_1_1user__feedback.html" title="function pointers implementing user feedback functionality of find_or_download_data_file() function">user_feedback</a></code> argument one can control how messages, queries and asking for a path is cast on to the user. By default an empty user feedback is used. To use std in and out you could use the following as the last parameter:</p>
<p><code> <a class="el" href="structcgv_1_1base_1_1user__feedback.html" title="function pointers implementing user feedback functionality of find_or_download_data_file() function">cgv::base::user_feedback(&amp;cgv::base::stdout_message, &amp;cgv::base::std_query, &amp;cgv::base::std_ask_dir)</a> </code></p>
<p>If a gui driver is available one can use the following alternative after including &lt;<a class="el" href="dialog_8h_source.html">cgv/gui/dialog.h</a>&gt; and &lt;<a class="el" href="file__dialog_8h_source.html">cgv/gui/file_dialog.h</a>&gt;</p>
<p><code> <a class="el" href="structcgv_1_1base_1_1user__feedback.html" title="function pointers implementing user feedback functionality of find_or_download_data_file() function">cgv::base::user_feedback(&amp;cgv::gui::message, &amp;cgv::gui::question, &amp;cgv::gui::directory_save_dialog)</a> </code> </p>

<p class="definition">Definition at line <a class="el" href="import_8cxx_source.html#l00159">159</a> of file <a class="el" href="import_8cxx_source.html">import.cxx</a>.</p>

<p class="reference">References <a class="el" href="import_8h_source.html#l00062">cgv::base::user_feedback::ask_dir</a>, <a class="el" href="import_8cxx_source.html#l00059">find_data_file()</a>, <a class="el" href="import_8cxx_source.html#l00159">find_or_download_data_file()</a>, <a class="el" href="import_8h_source.html#l00058">cgv::base::user_feedback::message</a>, <a class="el" href="import_8h_source.html#l00060">cgv::base::user_feedback::query</a>, <a class="el" href="import_8cxx_source.html#l00274">ref_data_path_list()</a>, and <a class="el" href="import_8cxx_source.html#l00321">ref_parent_file_stack()</a>.</p>

<p class="reference">Referenced by <a class="el" href="import_8cxx_source.html#l00159">find_or_download_data_file()</a>.</p>

</div>
</div>
<a id="a1e3f23268db7fec467dfd98ab36094f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3f23268db7fec467dfd98ab36094f5">&#9670;&nbsp;</a></span>get_attachment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CGV_API <a class="el" href="namespacecgv_1_1base.html#a580333ed27888f5e8c61452a44545f51">base_ptr</a> cgv::base::get_attachment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecgv_1_1base.html#a580333ed27888f5e8c61452a44545f51">base_ptr</a>&#160;</td>
          <td class="paramname"><em>slot_object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>query the attachment of an <a class="el" href="classcgv_1_1base_1_1attach__slot.html" title="interface for an attachment slot that can store a base pointer">attach_slot</a> object. </p>
<p>If the slot_object is not derived from the <a class="el" href="classcgv_1_1base_1_1attach__slot.html" title="interface for an attachment slot that can store a base pointer">attach_slot</a> interface, return an empty base_ptr. </p>

<p class="definition">Definition at line <a class="el" href="attach__slot_8cxx_source.html#l00053">53</a> of file <a class="el" href="attach__slot_8cxx_source.html">attach_slot.cxx</a>.</p>

<p class="reference">References <a class="el" href="attach__slot_8cxx_source.html#l00026">cgv::base::attach_slot::get_attachment()</a>, and <a class="el" href="base_8h_source.html#l00128">cgv::base::base::get_interface()</a>.</p>

</div>
</div>
<a id="aec69e775624f1ca64e001ff8b1254344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec69e775624f1ca64e001ff8b1254344">&#9670;&nbsp;</a></span>get_attachment_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CGV_API void * cgv::base::get_attachment_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecgv_1_1base.html#a580333ed27888f5e8c61452a44545f51">base_ptr</a>&#160;</td>
          <td class="paramname"><em>slot_object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>query the user data of the attachment of an <a class="el" href="classcgv_1_1base_1_1attach__slot.html" title="interface for an attachment slot that can store a base pointer">attach_slot</a> object. </p>
<p>If the slot_object is not derived from the <a class="el" href="classcgv_1_1base_1_1attach__slot.html" title="interface for an attachment slot that can store a base pointer">attach_slot</a> interface, return the null pointer. </p>

<p class="definition">Definition at line <a class="el" href="attach__slot_8cxx_source.html#l00062">62</a> of file <a class="el" href="attach__slot_8cxx_source.html">attach_slot.cxx</a>.</p>

<p class="reference">References <a class="el" href="attach__slot_8cxx_source.html#l00032">cgv::base::attach_slot::get_attachement_data()</a>, and <a class="el" href="base_8h_source.html#l00128">cgv::base::base::get_interface()</a>.</p>

</div>
</div>
<a id="ac63edc5ab309dd943500adb7801deeb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac63edc5ab309dd943500adb7801deeb2">&#9670;&nbsp;</a></span>has_property()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::base::has_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>report_error</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simple parsing support to access values of properties in a string of property assignment </p>
<p>Given an option string (first parameter) with name-value-pairs, i.e. "x=10.4;tooltip='help'" and a property name (second parameter), the function returns whether the option string contains an assignment of the queried property and if yes, the value is stored in the reference given in the third parameter. The type casts supported by the <a class="el" href="structcgv_1_1type_1_1variant.html" title="convenience template to access a value pointed to by a void pointer where the type of the value is gi...">cgv::type::variant</a> type are used when converting to the reference type.</p>
<p>Examples:</p>
<p>true == has_property("x=10.4;tooltip='help'", "x", dbl_var)"       ==&gt; dbl_var = 10.4
true  == has_property("x=10.4;tooltip='help'", "x", str_var)" ==&gt; str_var = "10.4" true == has_property("x=10.4;tooltip='help'", "tooltip", str_var)" ==&gt; str_var = "help"
false == has_property("x=10.4;tooltip='help'", "y", int_var)" ==&gt; int_var ... not changed </p>

<p class="definition">Definition at line <a class="el" href="base__generator_8h_source.html#l00132">132</a> of file <a class="el" href="base__generator_8h_source.html">base_generator.h</a>.</p>

<p class="reference">References <a class="el" href="base__generator_8h_source.html#l00104">cgv::base::base_generator::add()</a>, <a class="el" href="base__generator_8cxx_source.html#l00046">cgv::base::base_generator::changed()</a>, <a class="el" href="base__generator_8h_source.html#l00132">has_property()</a>, and <a class="el" href="base_8cxx_source.html#l00287">cgv::base::base::multi_set()</a>.</p>

<p class="reference">Referenced by <a class="el" href="provider_8cxx_source.html#l00207">cgv::gui::provider::begin_tree_node_void()</a>, and <a class="el" href="base__generator_8h_source.html#l00132">has_property()</a>.</p>

</div>
</div>
<a id="acf58539e451af7248fa0d2e64bbb48f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf58539e451af7248fa0d2e64bbb48f5">&#9670;&nbsp;</a></span>load_plugin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CGV_API void * cgv::base::load_plugin </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>load a plugin or dll and return a handle to the plugin, or 0 if loading was not successful. </p>
<p>During plugin loading the registration is always disabled in order to avoid deadlocks that can arise when a registered object triggers loading of another dll. </p>

<p class="definition">Definition at line <a class="el" href="register_8cxx_source.html#l01397">1397</a> of file <a class="el" href="register_8cxx_source.html">register.cxx</a>.</p>

<p class="reference">References <a class="el" href="tokenizer_8h_source.html#l00121">cgv::utils::bite_all()</a>, <a class="el" href="register_8cxx_source.html#l00480">disable_registration()</a>, <a class="el" href="register_8cxx_source.html#l00381">enable_registration()</a>, <a class="el" href="register_8cxx_source.html#l00493">is_registration_enabled()</a>, <a class="el" href="register_8cxx_source.html#l00137">ref_plugin_name()</a>, <a class="el" href="scan_8cxx_source.html#l00036">cgv::utils::to_lower()</a>, and <a class="el" href="convert__string_8h_source.html#l00018">cgv::utils::to_string()</a>.</p>

</div>
</div>
<a id="a5e0e3861c731016fa00726b7e17eadd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e0e3861c731016fa00726b7e17eadd1">&#9670;&nbsp;</a></span>process_command()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CGV_API cgv::base::process_command </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>eliminate_quotes</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>process a command given as string. </p>
<p>Return whether the command was processed correctly. If eliminate_quotes is set to true, quotes around the command arguments are eliminated. This feature is used for commands specified on the command line, where spaces in the command arguments would split one command into pieces. Quotes are used then to protect the command from splitting.</p>
<p>The following commands are supported:</p><ul>
<li>show all ... print out information on all registered objects</li>
<li>plugin:file_name ... read a plugin</li>
<li>config:file_name ... read a config file</li>
<li>gui:file_name ... read a gui description file</li>
<li>name(xxx):assignment list ... find registered object by name xxx and process assignments on them</li>
<li>type(yyy):assignment list ... find registered object by type yyy and process assignments on them</li>
</ul>
<p>The assigment list in the name and type commands are of the form:</p>
<p>member_name_1=value_1;member_name_2=value_2;... </p>

<p class="definition">Definition at line <a class="el" href="register_8cxx_source.html#l01274">1274</a> of file <a class="el" href="register_8cxx_source.html">register.cxx</a>.</p>

<p class="reference">References <a class="el" href="register_8cxx_source.html#l00992">analyze_command()</a>.</p>

</div>
</div>
<a id="aa3f550111b3915df062b0bbda4795f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3f550111b3915df062b0bbda4795f37">&#9670;&nbsp;</a></span>ref_parent_file_stack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CGV_API std::vector&lt; std::string &gt; &amp; cgv::base::ref_parent_file_stack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return a reference to the data path list, which is constructed from the environment variable CGV_DATA </p>
<p>return a reference to the parent file stack controlled with <a class="el" href="namespacecgv_1_1base.html#a90c98c559c9c197551a146a91a704e4b" title="extract a valid path from the given argument and push it onto the stack of parent paths....">push_file_parent()</a> and <a class="el" href="namespacecgv_1_1base.html#a8117654ca2eb262f18fc1093c0fdf828" title="pop the latestly pushed parent path from the parent path stack.">pop_file_parent()</a>, where the last vector element is the latestly pushed one </p>

<p class="definition">Definition at line <a class="el" href="import_8cxx_source.html#l00321">321</a> of file <a class="el" href="import_8cxx_source.html">import.cxx</a>.</p>

<p class="reference">References <a class="el" href="import_8cxx_source.html#l00321">ref_parent_file_stack()</a>.</p>

<p class="reference">Referenced by <a class="el" href="import_8cxx_source.html#l00059">find_data_file()</a>, <a class="el" href="import_8cxx_source.html#l00159">find_or_download_data_file()</a>, <a class="el" href="import_8cxx_source.html#l00314">pop_file_parent()</a>, <a class="el" href="import_8cxx_source.html#l00295">push_file_parent()</a>, and <a class="el" href="import_8cxx_source.html#l00321">ref_parent_file_stack()</a>.</p>

</div>
</div>
<a id="ad3783da9c295a7c532f2ea35d2a06abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3783da9c295a7c532f2ea35d2a06abb">&#9670;&nbsp;</a></span>register_object()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CGV_API cgv::base::register_object </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecgv_1_1base.html#a580333ed27888f5e8c61452a44545f51">base_ptr</a>&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>register an object and send event to all current registration ref_listeners() </p>
<p>register an object.</p>
<p>This will send an event to all currently registered registration listeners. The options parameter can be used to select a specific listener. </p>

<p class="definition">Definition at line <a class="el" href="register_8cxx_source.html#l00581">581</a> of file <a class="el" href="register_8cxx_source.html">register.cxx</a>.</p>

<p class="reference">References <a class="el" href="structcgv_1_1base_1_1object__constructor.html#a9df205baad55e14176d646ab12514c00">cgv::base::object_constructor::construct_object()</a>, <a class="el" href="base_8h_source.html#l00128">cgv::base::base::get_interface()</a>, <a class="el" href="register_8cxx_source.html#l00376">is_registration_debugging_enabled()</a>, <a class="el" href="register_8cxx_source.html#l00493">is_registration_enabled()</a>, <a class="el" href="register_8cxx_source.html#l00575">is_registration_event_cleanup_enabled()</a>, <a class="el" href="register_8cxx_source.html#l00581">register_object()</a>, <a class="el" href="structcgv_1_1base_1_1registration__listener.html#a0a3daf45e8d5b759649f2ea2c637535b">cgv::base::registration_listener::register_object()</a>, and <a class="el" href="register_8cxx_source.html#l00214">register_object_internal()</a>.</p>

<p class="reference">Referenced by <a class="el" href="register_8h_source.html#l00310">cgv::base::factory_registration&lt; T &gt;::factory_registration()</a>, <a class="el" href="register_8h_source.html#l00333">cgv::base::factory_registration_1&lt; T, CA &gt;::factory_registration_1()</a>, <a class="el" href="register_8h_source.html#l00356">cgv::base::factory_registration_2&lt; T, CA1, CA2 &gt;::factory_registration_2()</a>, <a class="el" href="base__provider__generator_8cxx_source.html#l00184">cgv::gui::base_provider_generator::generate_object_gui()</a>, <a class="el" href="register_8h_source.html#l00161">cgv::base::object_registration&lt; T &gt;::object_registration()</a>, <a class="el" href="register_8h_source.html#l00174">cgv::base::object_registration_1&lt; T, CA &gt;::object_registration_1()</a>, <a class="el" href="register_8h_source.html#l00187">cgv::base::object_registration_2&lt; T, CA1, CA2 &gt;::object_registration_2()</a>, <a class="el" href="register_8cxx_source.html#l00581">register_object()</a>, <a class="el" href="register_8cxx_source.html#l00214">register_object_internal()</a>, <a class="el" href="register_8cxx_source.html#l00841">cgv::base::factory::set_void()</a>, and <a class="el" href="register_8cxx_source.html#l00817">cgv::base::test_registration::test_registration()</a>.</p>

</div>
</div>
<a id="a9e4204680cce6ce77447fcab18a7fab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4204680cce6ce77447fcab18a7fab0">&#9670;&nbsp;</a></span>register_prog_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CGV_API void cgv::base::register_prog_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prog_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the file name of the current program. </p>
<p>simply pass argv[0] in the main procedure. This is done automatically in the process_command_line_args function. </p>

<p class="definition">Definition at line <a class="el" href="register_8cxx_source.html#l00915">915</a> of file <a class="el" href="register_8cxx_source.html">register.cxx</a>.</p>

<p class="reference">References <a class="el" href="register_8cxx_source.html#l00125">ref_prog_name()</a>, and <a class="el" href="register_8cxx_source.html#l00131">ref_prog_path_prefix()</a>.</p>

<p class="reference">Referenced by <a class="el" href="register_8cxx_source.html#l01283">process_command_line_args()</a>.</p>

</div>
</div>
<a id="aa6cfc52fcd0ab300675162f464038e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6cfc52fcd0ab300675162f464038e45">&#9670;&nbsp;</a></span>unregister_object()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CGV_API cgv::base::unregister_object </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecgv_1_1base.html#a580333ed27888f5e8c61452a44545f51">base_ptr</a>&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unregister an object and send event to all current registration ref_listeners() </p>
<p>unregister an object and send event to all currently registered registration listeners </p>

<p class="definition">Definition at line <a class="el" href="register_8cxx_source.html#l00617">617</a> of file <a class="el" href="register_8cxx_source.html">register.cxx</a>.</p>

<p class="reference">References <a class="el" href="register_8cxx_source.html#l00376">is_registration_debugging_enabled()</a>, and <a class="el" href="register_8cxx_source.html#l00617">unregister_object()</a>.</p>

<p class="reference">Referenced by <a class="el" href="register_8cxx_source.html#l00617">unregister_object()</a>, and <a class="el" href="base__provider__generator_8cxx_source.html#l00221">cgv::gui::base_provider_generator::unregister_object()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecgv.html">cgv</a></li><li class="navelem"><a class="el" href="namespacecgv_1_1base.html">base</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
