<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cgv: cgv::utils::tokenizer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cgv
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classcgv_1_1utils_1_1tokenizer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classcgv_1_1utils_1_1tokenizer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cgv::utils::tokenizer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>the tokenizer allows to split text into tokens in a convenient way.  
 <a href="classcgv_1_1utils_1_1tokenizer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="tokenizer_8h_source.html">tokenizer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cgv::utils::tokenizer:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcgv_1_1utils_1_1tokenizer.png" usemap="#cgv::utils::tokenizer_map" alt=""/>
  <map id="cgv::utils::tokenizer_map" name="cgv::utils::tokenizer_map">
<area href="structcgv_1_1utils_1_1token.html" title="representation of a token in a text by two pointers begin and end, that point to the first character ..." alt="cgv::utils::token" shape="rect" coords="0,0,118,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af6e62fd1715f4fa12cb35e758d0e8ad0"><td class="memItemLeft" align="right" valign="top"><a id="af6e62fd1715f4fa12cb35e758d0e8ad0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1utils_1_1tokenizer.html#af6e62fd1715f4fa12cb35e758d0e8ad0">tokenizer</a> ()</td></tr>
<tr class="memdesc:af6e62fd1715f4fa12cb35e758d0e8ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct empty tokenizer <br /></td></tr>
<tr class="separator:af6e62fd1715f4fa12cb35e758d0e8ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde384ab1579f3259214ec83dfda7443"><td class="memItemLeft" align="right" valign="top"><a id="acde384ab1579f3259214ec83dfda7443"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1utils_1_1tokenizer.html#acde384ab1579f3259214ec83dfda7443">tokenizer</a> (const <a class="el" href="structcgv_1_1utils_1_1token.html">token</a> &amp;)</td></tr>
<tr class="memdesc:acde384ab1579f3259214ec83dfda7443"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct from token <br /></td></tr>
<tr class="separator:acde384ab1579f3259214ec83dfda7443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadcad70c4a05e5c83d9dd10f72b7b41a"><td class="memItemLeft" align="right" valign="top"><a id="aadcad70c4a05e5c83d9dd10f72b7b41a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1utils_1_1tokenizer.html#aadcad70c4a05e5c83d9dd10f72b7b41a">tokenizer</a> (const char *)</td></tr>
<tr class="memdesc:aadcad70c4a05e5c83d9dd10f72b7b41a"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct from character string <br /></td></tr>
<tr class="separator:aadcad70c4a05e5c83d9dd10f72b7b41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9dfb4249ae626b16d878c6a2acd2db"><td class="memItemLeft" align="right" valign="top"><a id="a1f9dfb4249ae626b16d878c6a2acd2db"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1utils_1_1tokenizer.html#a1f9dfb4249ae626b16d878c6a2acd2db">tokenizer</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a1f9dfb4249ae626b16d878c6a2acd2db"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct from string <br /></td></tr>
<tr class="separator:a1f9dfb4249ae626b16d878c6a2acd2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0ef41126a2f4331487d06978d2100d"><td class="memItemLeft" align="right" valign="top"><a id="abe0ef41126a2f4331487d06978d2100d"></a>
<a class="el" href="classcgv_1_1utils_1_1tokenizer.html">tokenizer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1utils_1_1tokenizer.html#abe0ef41126a2f4331487d06978d2100d">set_ws</a> (const std::string &amp;ws)</td></tr>
<tr class="memdesc:abe0ef41126a2f4331487d06978d2100d"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the list of white spaces, that separate tokens and are skipped <br /></td></tr>
<tr class="separator:abe0ef41126a2f4331487d06978d2100d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6e12433df772b5eb085361edf2e77d"><td class="memItemLeft" align="right" valign="top"><a id="afd6e12433df772b5eb085361edf2e77d"></a>
<a class="el" href="classcgv_1_1utils_1_1tokenizer.html">tokenizer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1utils_1_1tokenizer.html#afd6e12433df772b5eb085361edf2e77d">set_skip</a> (const std::string &amp;open, const std::string &amp;close)</td></tr>
<tr class="memdesc:afd6e12433df772b5eb085361edf2e77d"><td class="mdescLeft">&#160;</td><td class="mdescRight">set several character pairs that enclose tokens that are not split <br /></td></tr>
<tr class="separator:afd6e12433df772b5eb085361edf2e77d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa97017b2f5dff2fe49026177f0ea7d4d"><td class="memItemLeft" align="right" valign="top"><a id="aa97017b2f5dff2fe49026177f0ea7d4d"></a>
<a class="el" href="classcgv_1_1utils_1_1tokenizer.html">tokenizer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1utils_1_1tokenizer.html#aa97017b2f5dff2fe49026177f0ea7d4d">set_skip</a> (const std::string &amp;open, const std::string &amp;close, const std::string &amp;escape)</td></tr>
<tr class="memdesc:aa97017b2f5dff2fe49026177f0ea7d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">set several character pairs that enclose tokens that are not split and one escape character for each pair <br /></td></tr>
<tr class="separator:aa97017b2f5dff2fe49026177f0ea7d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41503182d19cd454cbf927c5ca20117b"><td class="memItemLeft" align="right" valign="top"><a id="a41503182d19cd454cbf927c5ca20117b"></a>
<a class="el" href="classcgv_1_1utils_1_1tokenizer.html">tokenizer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1utils_1_1tokenizer.html#a41503182d19cd454cbf927c5ca20117b">set_sep</a> (const std::string &amp;sep, bool merge)</td></tr>
<tr class="memdesc:a41503182d19cd454cbf927c5ca20117b"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the list of separators and specify whether succeeding separators are merged into single tokens <br /></td></tr>
<tr class="separator:a41503182d19cd454cbf927c5ca20117b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaccdd4514172239d7f5eaa4b487a6ce"><td class="memItemLeft" align="right" valign="top"><a id="abaccdd4514172239d7f5eaa4b487a6ce"></a>
<a class="el" href="classcgv_1_1utils_1_1tokenizer.html">tokenizer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1utils_1_1tokenizer.html#abaccdd4514172239d7f5eaa4b487a6ce">set_sep</a> (const std::string &amp;sep)</td></tr>
<tr class="memdesc:abaccdd4514172239d7f5eaa4b487a6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the list of separators <br /></td></tr>
<tr class="separator:abaccdd4514172239d7f5eaa4b487a6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2f9d31e8ab750deeb519fec7e0f05a"><td class="memItemLeft" align="right" valign="top"><a id="abc2f9d31e8ab750deeb519fec7e0f05a"></a>
<a class="el" href="classcgv_1_1utils_1_1tokenizer.html">tokenizer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1utils_1_1tokenizer.html#abc2f9d31e8ab750deeb519fec7e0f05a">set_sep_merge</a> (bool merge)</td></tr>
<tr class="memdesc:abc2f9d31e8ab750deeb519fec7e0f05a"><td class="mdescLeft">&#160;</td><td class="mdescRight">specify whether succeeding separators are merged into single tokens <br /></td></tr>
<tr class="separator:abc2f9d31e8ab750deeb519fec7e0f05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd0c51bc5d55591e59e90685fcfe055"><td class="memItemLeft" align="right" valign="top"><a id="addd0c51bc5d55591e59e90685fcfe055"></a>
<a class="el" href="structcgv_1_1utils_1_1token.html">token</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1utils_1_1tokenizer.html#addd0c51bc5d55591e59e90685fcfe055">bite</a> ()</td></tr>
<tr class="memdesc:addd0c51bc5d55591e59e90685fcfe055"><td class="mdescLeft">&#160;</td><td class="mdescRight">bite away a single token from the front <br /></td></tr>
<tr class="separator:addd0c51bc5d55591e59e90685fcfe055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25223c944612a421b243bf621de6c12"><td class="memItemLeft" align="right" valign="top"><a id="af25223c944612a421b243bf621de6c12"></a>
<a class="el" href="structcgv_1_1utils_1_1token.html">token</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1utils_1_1tokenizer.html#af25223c944612a421b243bf621de6c12">reverse_bite</a> ()</td></tr>
<tr class="memdesc:af25223c944612a421b243bf621de6c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">bite away a single token from the back <br /></td></tr>
<tr class="separator:af25223c944612a421b243bf621de6c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170754c988696d5f2a754bb6ef2ee2e1"><td class="memItemLeft" align="right" valign="top"><a id="a170754c988696d5f2a754bb6ef2ee2e1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1utils_1_1tokenizer.html#a170754c988696d5f2a754bb6ef2ee2e1">reverse_skip_whitespaces</a> ()</td></tr>
<tr class="memdesc:a170754c988696d5f2a754bb6ef2ee2e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">skip whitespaces at the back <br /></td></tr>
<tr class="separator:a170754c988696d5f2a754bb6ef2ee2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010d4a0b24f5fa6d186bef28ed5e4f53"><td class="memItemLeft" align="right" valign="top"><a id="a010d4a0b24f5fa6d186bef28ed5e4f53"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1utils_1_1tokenizer.html#a010d4a0b24f5fa6d186bef28ed5e4f53">skip_whitespaces</a> ()</td></tr>
<tr class="memdesc:a010d4a0b24f5fa6d186bef28ed5e4f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">skip whitespaces at the front <br /></td></tr>
<tr class="separator:a010d4a0b24f5fa6d186bef28ed5e4f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88819bc6f1798950fc69946634747f5"><td class="memItemLeft" align="right" valign="top"><a id="ac88819bc6f1798950fc69946634747f5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1utils_1_1tokenizer.html#ac88819bc6f1798950fc69946634747f5">skip_ws_check_empty</a> ()</td></tr>
<tr class="memdesc:ac88819bc6f1798950fc69946634747f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">skip whitespaces at the front and return whether the complete text has been processed <br /></td></tr>
<tr class="separator:ac88819bc6f1798950fc69946634747f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca0d8ed9022709dd98d95a356f853a9"><td class="memItemLeft" align="right" valign="top"><a id="adca0d8ed9022709dd98d95a356f853a9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1utils_1_1tokenizer.html#adca0d8ed9022709dd98d95a356f853a9">reverse_skip_ws_check_empty</a> ()</td></tr>
<tr class="memdesc:adca0d8ed9022709dd98d95a356f853a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">skip whitespaces at the back and return whether the complete text has been processed <br /></td></tr>
<tr class="separator:adca0d8ed9022709dd98d95a356f853a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee94fed89d9c312e643d01892a9771a"><td class="memItemLeft" align="right" valign="top"><a id="a3ee94fed89d9c312e643d01892a9771a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1utils_1_1tokenizer.html#a3ee94fed89d9c312e643d01892a9771a">balanced_bite</a> (<a class="el" href="structcgv_1_1utils_1_1token.html">token</a> &amp;result, const std::string &amp;open_parenthesis, const std::string &amp;close_parenthesis, bool wait_for_sep=false)</td></tr>
<tr class="memdesc:a3ee94fed89d9c312e643d01892a9771a"><td class="mdescLeft">&#160;</td><td class="mdescRight">bite one token until all potentially nested opended parenthesis have been closed again <br /></td></tr>
<tr class="separator:a3ee94fed89d9c312e643d01892a9771a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a63af3bc04b79c5ac4312aa6912729"><td class="memItemLeft" align="right" valign="top"><a id="a69a63af3bc04b79c5ac4312aa6912729"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1utils_1_1token.html#a69a63af3bc04b79c5ac4312aa6912729">get_length</a> () const</td></tr>
<tr class="memdesc:a69a63af3bc04b79c5ac4312aa6912729"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the length of the token in number of characters <br /></td></tr>
<tr class="separator:a69a63af3bc04b79c5ac4312aa6912729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e06c57774bb6d34436ff2e0ea22442"><td class="memItemLeft" align="right" valign="top"><a id="aa8e06c57774bb6d34436ff2e0ea22442"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1utils_1_1token.html#aa8e06c57774bb6d34436ff2e0ea22442">size</a> () const</td></tr>
<tr class="memdesc:aa8e06c57774bb6d34436ff2e0ea22442"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the length of the token in number of characters <br /></td></tr>
<tr class="separator:aa8e06c57774bb6d34436ff2e0ea22442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb459d58bbc7d00ba91dfc42dbd5fca"><td class="memItemLeft" align="right" valign="top"><a id="a0eb459d58bbc7d00ba91dfc42dbd5fca"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1utils_1_1token.html#a0eb459d58bbc7d00ba91dfc42dbd5fca">empty</a> () const</td></tr>
<tr class="memdesc:a0eb459d58bbc7d00ba91dfc42dbd5fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether the token is empty <br /></td></tr>
<tr class="separator:a0eb459d58bbc7d00ba91dfc42dbd5fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32eb820b4d06b2337785920351daa82f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1utils_1_1token.html#a32eb820b4d06b2337785920351daa82f">skip</a> (const std::string &amp;skip_chars)</td></tr>
<tr class="memdesc:a32eb820b4d06b2337785920351daa82f"><td class="mdescLeft">&#160;</td><td class="mdescRight">set begin by skipping all instances of the given character set  <a href="structcgv_1_1utils_1_1token.html#a32eb820b4d06b2337785920351daa82f">More...</a><br /></td></tr>
<tr class="separator:a32eb820b4d06b2337785920351daa82f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31c4e3c695ed4ad2ce0b69d09c2cf45"><td class="memItemLeft" align="right" valign="top"><a id="ab31c4e3c695ed4ad2ce0b69d09c2cf45"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1utils_1_1token.html#ab31c4e3c695ed4ad2ce0b69d09c2cf45">reverse_skip</a> (const std::string &amp;skip_chars)</td></tr>
<tr class="memdesc:ab31c4e3c695ed4ad2ce0b69d09c2cf45"><td class="mdescLeft">&#160;</td><td class="mdescRight">set end by skipping all instances of the given character set <br /></td></tr>
<tr class="separator:ab31c4e3c695ed4ad2ce0b69d09c2cf45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c686c3345b275faa5bacb0245a1af9"><td class="memItemLeft" align="right" valign="top"><a id="a76c686c3345b275faa5bacb0245a1af9"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1utils_1_1token.html#a76c686c3345b275faa5bacb0245a1af9">operator[]</a> (unsigned int i) const</td></tr>
<tr class="memdesc:a76c686c3345b275faa5bacb0245a1af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the i-th character of the token <br /></td></tr>
<tr class="separator:a76c686c3345b275faa5bacb0245a1af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2174dd7b2d7f1072366285c6958f6513"><td class="memItemLeft" align="right" valign="top"><a id="a2174dd7b2d7f1072366285c6958f6513"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1utils_1_1token.html#a2174dd7b2d7f1072366285c6958f6513">operator==</a> (const char *s) const</td></tr>
<tr class="memdesc:a2174dd7b2d7f1072366285c6958f6513"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare to const char* <br /></td></tr>
<tr class="separator:a2174dd7b2d7f1072366285c6958f6513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da075532aa3e381c677a10941e2fc7c"><td class="memItemLeft" align="right" valign="top"><a id="a4da075532aa3e381c677a10941e2fc7c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1utils_1_1token.html#a4da075532aa3e381c677a10941e2fc7c">operator==</a> (const std::string &amp;s) const</td></tr>
<tr class="memdesc:a4da075532aa3e381c677a10941e2fc7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare to string <br /></td></tr>
<tr class="separator:a4da075532aa3e381c677a10941e2fc7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2121933f46f315734a1994eafeff2b"><td class="memItemLeft" align="right" valign="top"><a id="a9a2121933f46f315734a1994eafeff2b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1utils_1_1token.html#a9a2121933f46f315734a1994eafeff2b">operator!=</a> (const char *s) const</td></tr>
<tr class="memdesc:a9a2121933f46f315734a1994eafeff2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare to const char* <br /></td></tr>
<tr class="separator:a9a2121933f46f315734a1994eafeff2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36887dce50ff1ef44d8f6341ce99b387"><td class="memItemLeft" align="right" valign="top"><a id="a36887dce50ff1ef44d8f6341ce99b387"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1utils_1_1token.html#a36887dce50ff1ef44d8f6341ce99b387">operator!=</a> (const std::string &amp;s) const</td></tr>
<tr class="memdesc:a36887dce50ff1ef44d8f6341ce99b387"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare to string <br /></td></tr>
<tr class="separator:a36887dce50ff1ef44d8f6341ce99b387"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a8795f9f939f15d61b4114c370a670344"><td class="memItemLeft" align="right" valign="top"><a id="a8795f9f939f15d61b4114c370a670344"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1utils_1_1token.html#a8795f9f939f15d61b4114c370a670344">begin</a></td></tr>
<tr class="memdesc:a8795f9f939f15d61b4114c370a670344"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointers that define the range of characters <br /></td></tr>
<tr class="separator:a8795f9f939f15d61b4114c370a670344"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>the tokenizer allows to split text into tokens in a convenient way. </p>
<p>It supports splitting at white spaces and single or multi charactor separators. Furthermore, it supports enclosing character pairs like parantheses or string separators that skip white spaces and separators between enclosing pairs.</p>
<p>By default white spaces are set to space, tab, newline. The list of separators and skip character pairs is empty by default.</p>
<p>A tokenizer can be constructed from a string, a cont char* or a token. The resulting tokens are stored as two pointers to the begin and after the end of the token. No new memory is allocated and the tokens are only valid as long as the string or const char* is valid from which the tokenizer has been construct.</p>
<p>In the simplest usage, the tokenizer generates a vector of tokens through the bite_all function. Suppose you want to split the string str="Hello tokenizer." at the white spaces into two tokens &lt;Hello&gt; and &lt;tokenizer.&gt;. Notice that no token contains the white space separating the tokens. The following code performs this task: </p><div class="fragment"><div class="line">std::vector&lt;token&gt; toks;</div>
<div class="line">bite_all(<a class="code" href="classcgv_1_1utils_1_1tokenizer.html#af6e62fd1715f4fa12cb35e758d0e8ad0">tokenizer</a>(str), toks);</div>
<div class="ttc" id="aclasscgv_1_1utils_1_1tokenizer_html_af6e62fd1715f4fa12cb35e758d0e8ad0"><div class="ttname"><a href="classcgv_1_1utils_1_1tokenizer.html#af6e62fd1715f4fa12cb35e758d0e8ad0">cgv::utils::tokenizer::tokenizer</a></div><div class="ttdeci">tokenizer()</div><div class="ttdoc">construct empty tokenizer</div><div class="ttdef"><b>Definition:</b> <a href="tokenizer_8cxx_source.html#l00016">tokenizer.cxx:16</a></div></div>
</div><!-- fragment --><p> If you want to also cut the dot into a separate token, just set the list of separators with the set_sep method: </p><div class="fragment"><div class="line">std::vector&lt;token&gt; toks;</div>
<div class="line">bite_all(<a class="code" href="classcgv_1_1utils_1_1tokenizer.html#af6e62fd1715f4fa12cb35e758d0e8ad0">tokenizer</a>(str).<a class="code" href="classcgv_1_1utils_1_1tokenizer.html#a41503182d19cd454cbf927c5ca20117b">set_sep</a>(<span class="stringliteral">&quot;.&quot;</span>), toks);</div>
<div class="ttc" id="aclasscgv_1_1utils_1_1tokenizer_html_a41503182d19cd454cbf927c5ca20117b"><div class="ttname"><a href="classcgv_1_1utils_1_1tokenizer.html#a41503182d19cd454cbf927c5ca20117b">cgv::utils::tokenizer::set_sep</a></div><div class="ttdeci">tokenizer &amp; set_sep(const std::string &amp;sep, bool merge)</div><div class="ttdoc">set the list of separators and specify whether succeeding separators are merged into single tokens</div><div class="ttdef"><b>Definition:</b> <a href="tokenizer_8cxx_source.html#l00059">tokenizer.cxx:59</a></div></div>
</div><!-- fragment --><p> The result are three tokens: &lt;Hello&gt;, &lt;tokenizer&gt; and &lt;.&gt;. If you want to split a semicolon separated list with tokens that can contain white spaces and ignoring the semicolons, you can set the semicolon character as the only white space: </p><div class="fragment"><div class="line">std::vector&lt;token&gt; toks;</div>
<div class="line">bite_all(<a class="code" href="classcgv_1_1utils_1_1tokenizer.html#af6e62fd1715f4fa12cb35e758d0e8ad0">tokenizer</a>(str).<a class="code" href="classcgv_1_1utils_1_1tokenizer.html#abe0ef41126a2f4331487d06978d2100d">set_ws</a>(<span class="stringliteral">&quot;;&quot;</span>), toks);</div>
<div class="ttc" id="aclasscgv_1_1utils_1_1tokenizer_html_abe0ef41126a2f4331487d06978d2100d"><div class="ttname"><a href="classcgv_1_1utils_1_1tokenizer.html#abe0ef41126a2f4331487d06978d2100d">cgv::utils::tokenizer::set_ws</a></div><div class="ttdeci">tokenizer &amp; set_ws(const std::string &amp;ws)</div><div class="ttdoc">set the list of white spaces, that separate tokens and are skipped</div><div class="ttdef"><b>Definition:</b> <a href="tokenizer_8cxx_source.html#l00038">tokenizer.cxx:38</a></div></div>
</div><!-- fragment --><p> The previous code would split the string "a and b;c and d" into two tokens  and <code>.</code></p>
<p><code> If you want to not split into tokens in between strings enclosed by &lt;'&gt; and in between paranthesis, you can several skip character pairs: </p><div class="fragment"><div class="line">std::vector&lt;token&gt; toks;</div>
<div class="line">bite_all(<a class="code" href="classcgv_1_1utils_1_1tokenizer.html#af6e62fd1715f4fa12cb35e758d0e8ad0">tokenizer</a>(str).<a class="code" href="classcgv_1_1utils_1_1tokenizer.html#a41503182d19cd454cbf927c5ca20117b">set_sep</a>(<span class="stringliteral">&quot;[]&quot;</span>).<a class="code" href="classcgv_1_1utils_1_1tokenizer.html#afd6e12433df772b5eb085361edf2e77d">set_skip</a>(<span class="stringliteral">&quot;&#39;({&quot;</span>, <span class="stringliteral">&quot;&#39;)}&quot;</span>), toks);</div>
<div class="ttc" id="aclasscgv_1_1utils_1_1tokenizer_html_afd6e12433df772b5eb085361edf2e77d"><div class="ttname"><a href="classcgv_1_1utils_1_1tokenizer.html#afd6e12433df772b5eb085361edf2e77d">cgv::utils::tokenizer::set_skip</a></div><div class="ttdeci">tokenizer &amp; set_skip(const std::string &amp;open, const std::string &amp;close)</div><div class="ttdoc">set several character pairs that enclose tokens that are not split</div><div class="ttdef"><b>Definition:</b> <a href="tokenizer_8cxx_source.html#l00044">tokenizer.cxx:44</a></div></div>
</div><!-- fragment --><p> The previous code example would split the string "'a b'[{c d}]" into four tokens: &lt;'a b'&gt;, &lt;[&gt;, &lt;{c d}&gt; and &lt;]&gt;. Note that you can apply several setter methods to the tokenizer in a sequence as each setter returns a reference to the tokenizer itself similar to the stream operators. </code></p>

<p class="definition">Definition at line <a class="el" href="tokenizer_8h_source.html#l00067">67</a> of file <a class="el" href="tokenizer_8h_source.html">tokenizer.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a32eb820b4d06b2337785920351daa82f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32eb820b4d06b2337785920351daa82f">&#9670;&nbsp;</a></span>skip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void token::skip </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>skip_chars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set begin by skipping all instances of the given character set </p>
<p>return the length of the token in number of characters</p>
<p>return the length of the token in number of characters return whether the token is empty set begin by skipping all instances of the given character set </p>

<p class="definition">Definition at line <a class="el" href="token_8cxx_source.html#l00033">33</a> of file <a class="el" href="token_8cxx_source.html">token.cxx</a>.</p>

<p class="reference">References <a class="el" href="token_8h_source.html#l00018">cgv::utils::token::begin</a>, and <a class="el" href="scan_8cxx_source.html#l00274">cgv::utils::is_element()</a>.</p>

<p class="reference">Referenced by <a class="el" href="tokenizer_8cxx_source.html#l00302">skip_whitespaces()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>cgv/utils/<a class="el" href="tokenizer_8h_source.html">tokenizer.h</a></li>
<li>cgv/utils/<a class="el" href="tokenizer_8cxx_source.html">tokenizer.cxx</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecgv.html">cgv</a></li><li class="navelem"><a class="el" href="namespacecgv_1_1utils.html">utils</a></li><li class="navelem"><a class="el" href="classcgv_1_1utils_1_1tokenizer.html">tokenizer</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
