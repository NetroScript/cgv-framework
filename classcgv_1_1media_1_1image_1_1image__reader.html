<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cgv: cgv::media::image::image_reader Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cgv
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classcgv_1_1media_1_1image_1_1image__reader.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classcgv_1_1media_1_1image_1_1image__reader-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cgv::media::image::image_reader Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>the image reader chooses a specific reader automatically based on the extension of the given file name.  
 <a href="classcgv_1_1media_1_1image_1_1image__reader.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="image__reader_8h_source.html">image_reader.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cgv::media::image::image_reader:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcgv_1_1media_1_1image_1_1image__reader.png" usemap="#cgv::media::image::image_5Freader_map" alt=""/>
  <map id="cgv::media::image::image_5Freader_map" name="cgv::media::image::image_5Freader_map">
<area href="classcgv_1_1base_1_1base.html" title="base class for all classes that can be registered with support for dynamic properties (see also secti..." alt="cgv::base::base" shape="rect" coords="102,56,297,80"/>
<area href="classcgv_1_1data_1_1ref__counted.html" title="if you derive your class from this class, a ref_ptr will do reference counting in the inhereted ref_c..." alt="cgv::data::ref_counted" shape="rect" coords="0,0,195,24"/>
<area href="structcgv_1_1reflect_1_1self__reflection__tag.html" title="Derive from this class to announce implementation of the method self_reflect." alt="cgv::reflect::self_reflection_tag" shape="rect" coords="205,0,400,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abe89ffd5db0943e20d19bc3494e25e88"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#abe89ffd5db0943e20d19bc3494e25e88">image_reader</a> (<a class="el" href="classcgv_1_1data_1_1data__format.html">data_format</a> &amp;file_format, std::vector&lt; <a class="el" href="classcgv_1_1data_1_1data__format.html">data_format</a> &gt; *<a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#aa4b99d1b652a7329368dc5c5f81fb367">palette_formats</a>=0)</td></tr>
<tr class="memdesc:abe89ffd5db0943e20d19bc3494e25e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct an image reader from a reference to a data format instance in which the format of the image file will be stored after a call to the open method.  <a href="classcgv_1_1media_1_1image_1_1image__reader.html#abe89ffd5db0943e20d19bc3494e25e88">More...</a><br /></td></tr>
<tr class="separator:abe89ffd5db0943e20d19bc3494e25e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06b7ffbf23bf2af4914da0b8db85ce6"><td class="memItemLeft" align="right" valign="top"><a id="ab06b7ffbf23bf2af4914da0b8db85ce6"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#ab06b7ffbf23bf2af4914da0b8db85ce6">get_type_name</a> () const</td></tr>
<tr class="memdesc:ab06b7ffbf23bf2af4914da0b8db85ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload to return the type name of this object <br /></td></tr>
<tr class="separator:ab06b7ffbf23bf2af4914da0b8db85ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6cd9178f2412fcc7e3068cf76cb1611"><td class="memItemLeft" align="right" valign="top"><a id="ae6cd9178f2412fcc7e3068cf76cb1611"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#ae6cd9178f2412fcc7e3068cf76cb1611">get_property_declarations</a> ()</td></tr>
<tr class="memdesc:ae6cd9178f2412fcc7e3068cf76cb1611"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a semicolon separated list of property declarations of the form "name:type", by default an empty list is returned <br /></td></tr>
<tr class="separator:ae6cd9178f2412fcc7e3068cf76cb1611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e38c3c10b14f18522b7052416422cc5"><td class="memItemLeft" align="right" valign="top"><a id="a2e38c3c10b14f18522b7052416422cc5"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#a2e38c3c10b14f18522b7052416422cc5">get_last_error</a> () const</td></tr>
<tr class="memdesc:a2e38c3c10b14f18522b7052416422cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a reference to the last error message <br /></td></tr>
<tr class="separator:a2e38c3c10b14f18522b7052416422cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac871d242183818bcacb62613a6907611"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#ac871d242183818bcacb62613a6907611">read_image</a> (const std::string &amp;file_name, <a class="el" href="classcgv_1_1data_1_1data__view.html">data_view</a> &amp;dv, std::vector&lt; <a class="el" href="classcgv_1_1data_1_1data__view.html">data_view</a> &gt; *palettes=0)</td></tr>
<tr class="memdesc:ac871d242183818bcacb62613a6907611"><td class="mdescLeft">&#160;</td><td class="mdescRight">read the whole image into the given data view.  <a href="classcgv_1_1media_1_1image_1_1image__reader.html#ac871d242183818bcacb62613a6907611">More...</a><br /></td></tr>
<tr class="separator:ac871d242183818bcacb62613a6907611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a96f9ca692b4ce82e776aabdce3351"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#a46a96f9ca692b4ce82e776aabdce3351">read_image</a> (const std::string &amp;file_name, const <a class="el" href="classcgv_1_1data_1_1data__view.html">data_view</a> &amp;dv, const std::vector&lt; <a class="el" href="classcgv_1_1data_1_1data__view.html">data_view</a> &gt; *palettes=0)</td></tr>
<tr class="memdesc:a46a96f9ca692b4ce82e776aabdce3351"><td class="mdescLeft">&#160;</td><td class="mdescRight">read the image into the given data view that must have the correct format and an allocated data pointer.  <a href="classcgv_1_1media_1_1image_1_1image__reader.html#a46a96f9ca692b4ce82e776aabdce3351">More...</a><br /></td></tr>
<tr class="separator:a46a96f9ca692b4ce82e776aabdce3351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e432a1d23297e019079b5dbd83e8db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#aa7e432a1d23297e019079b5dbd83e8db">open</a> (const std::string &amp;file_name)</td></tr>
<tr class="memdesc:aa7e432a1d23297e019079b5dbd83e8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">open the file and read the image header in order to determine the data format of the file, which is stored in the data format specified in the constructor  <a href="classcgv_1_1media_1_1image_1_1image__reader.html#aa7e432a1d23297e019079b5dbd83e8db">More...</a><br /></td></tr>
<tr class="separator:aa7e432a1d23297e019079b5dbd83e8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b29aba3062357f7a1c8315f428b559"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1data_1_1data__format.html">data_format</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#a97b29aba3062357f7a1c8315f428b559">get_file_format</a> () const</td></tr>
<tr class="memdesc:a97b29aba3062357f7a1c8315f428b559"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the data format of the image file  <a href="classcgv_1_1media_1_1image_1_1image__reader.html#a97b29aba3062357f7a1c8315f428b559">More...</a><br /></td></tr>
<tr class="separator:a97b29aba3062357f7a1c8315f428b559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297ce1fc2f75d1328e0ddd1be2d8917b"><td class="memItemLeft" align="right" valign="top"><a id="a297ce1fc2f75d1328e0ddd1be2d8917b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#a297ce1fc2f75d1328e0ddd1be2d8917b">supports_multiple_images</a> () const</td></tr>
<tr class="memdesc:a297ce1fc2f75d1328e0ddd1be2d8917b"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the file can contain several images <br /></td></tr>
<tr class="separator:a297ce1fc2f75d1328e0ddd1be2d8917b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299afdd92563b01422ae3d4b88b32e5d"><td class="memItemLeft" align="right" valign="top"><a id="a299afdd92563b01422ae3d4b88b32e5d"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#a299afdd92563b01422ae3d4b88b32e5d">get_nr_images</a> () const</td></tr>
<tr class="memdesc:a299afdd92563b01422ae3d4b88b32e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the number of images in the file, what can cause the whole file to be scanned <br /></td></tr>
<tr class="separator:a299afdd92563b01422ae3d4b88b32e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dea520977d6412453e42e3550e16b7c"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#a4dea520977d6412453e42e3550e16b7c">get_image_duration</a> () const</td></tr>
<tr class="memdesc:a4dea520977d6412453e42e3550e16b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the duration of the current image in seconds, if returned value is 0, no duration is available  <a href="classcgv_1_1media_1_1image_1_1image__reader.html#a4dea520977d6412453e42e3550e16b7c">More...</a><br /></td></tr>
<tr class="separator:a4dea520977d6412453e42e3550e16b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18763a40a7245c344b161a9b1c2dc6d8"><td class="memItemLeft" align="right" valign="top"><a id="a18763a40a7245c344b161a9b1c2dc6d8"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#a18763a40a7245c344b161a9b1c2dc6d8">get_current_image</a> () const</td></tr>
<tr class="memdesc:a18763a40a7245c344b161a9b1c2dc6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the index of the current image <br /></td></tr>
<tr class="separator:a18763a40a7245c344b161a9b1c2dc6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0be98c3744dfdaf12936e1f2cba9292"><td class="memItemLeft" align="right" valign="top"><a id="ac0be98c3744dfdaf12936e1f2cba9292"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#ac0be98c3744dfdaf12936e1f2cba9292">seek_image</a> (unsigned idx)</td></tr>
<tr class="memdesc:ac0be98c3744dfdaf12936e1f2cba9292"><td class="mdescLeft">&#160;</td><td class="mdescRight">jump to a specific image and return whether this was successful <br /></td></tr>
<tr class="separator:ac0be98c3744dfdaf12936e1f2cba9292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f47f588ac70c2c9f7fb733d6bd9cff0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#a5f47f588ac70c2c9f7fb733d6bd9cff0">read_palette</a> (unsigned int i, <a class="el" href="classcgv_1_1data_1_1data__view.html">data_view</a> &amp;dv)</td></tr>
<tr class="memdesc:a5f47f588ac70c2c9f7fb733d6bd9cff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">read the i-th palette in case of a paletted file format, and handle the data view as in the read_image method the standard implementation returns false  <a href="classcgv_1_1media_1_1image_1_1image__reader.html#a5f47f588ac70c2c9f7fb733d6bd9cff0">More...</a><br /></td></tr>
<tr class="separator:a5f47f588ac70c2c9f7fb733d6bd9cff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601be4379303d149dc43d3c382e92dcf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#a601be4379303d149dc43d3c382e92dcf">read_palette</a> (unsigned int i, const <a class="el" href="classcgv_1_1data_1_1data__view.html">data_view</a> &amp;dv)</td></tr>
<tr class="memdesc:a601be4379303d149dc43d3c382e92dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">read the i-th palette in case of a paletted file format, and handle the data view as in the read_image method the standard implementation returns false  <a href="classcgv_1_1media_1_1image_1_1image__reader.html#a601be4379303d149dc43d3c382e92dcf">More...</a><br /></td></tr>
<tr class="separator:a601be4379303d149dc43d3c382e92dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29e189b8a2da2409e9b9ba119108f7b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#af29e189b8a2da2409e9b9ba119108f7b">supports_per_line_read</a> () const</td></tr>
<tr class="memdesc:af29e189b8a2da2409e9b9ba119108f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether the reader supports per line reading (only valid after successfully opening an image file)  <a href="classcgv_1_1media_1_1image_1_1image__reader.html#af29e189b8a2da2409e9b9ba119108f7b">More...</a><br /></td></tr>
<tr class="separator:af29e189b8a2da2409e9b9ba119108f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ba97597b2df4857888b006b695ea92"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#af4ba97597b2df4857888b006b695ea92">read_line</a> (<a class="el" href="classcgv_1_1data_1_1data__view.html">data_view</a> &amp;dv)</td></tr>
<tr class="memdesc:af4ba97597b2df4857888b006b695ea92"><td class="mdescLeft">&#160;</td><td class="mdescRight">read the next line into the given data view.  <a href="classcgv_1_1media_1_1image_1_1image__reader.html#af4ba97597b2df4857888b006b695ea92">More...</a><br /></td></tr>
<tr class="separator:af4ba97597b2df4857888b006b695ea92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265b84b8171b89cba0747f99e9e50058"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#a265b84b8171b89cba0747f99e9e50058">read_line</a> (const <a class="el" href="classcgv_1_1data_1_1data__view.html">data_view</a> &amp;dv)</td></tr>
<tr class="memdesc:a265b84b8171b89cba0747f99e9e50058"><td class="mdescLeft">&#160;</td><td class="mdescRight">read line into a preallocated data view of the correct format  <a href="classcgv_1_1media_1_1image_1_1image__reader.html#a265b84b8171b89cba0747f99e9e50058">More...</a><br /></td></tr>
<tr class="separator:a265b84b8171b89cba0747f99e9e50058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abadd93d051939e353e40d674718ebf1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#abadd93d051939e353e40d674718ebf1b">read_image</a> (<a class="el" href="classcgv_1_1data_1_1data__view.html">data_view</a> &amp;dv, std::vector&lt; <a class="el" href="classcgv_1_1data_1_1data__view.html">data_view</a> &gt; *palettes=0)</td></tr>
<tr class="memdesc:abadd93d051939e353e40d674718ebf1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">read an opened image data and palettes into a data views that are optionally allocated.  <a href="classcgv_1_1media_1_1image_1_1image__reader.html#abadd93d051939e353e40d674718ebf1b">More...</a><br /></td></tr>
<tr class="separator:abadd93d051939e353e40d674718ebf1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c76b7a71ad26a1f621ad209d980fc57"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#a2c76b7a71ad26a1f621ad209d980fc57">read_image</a> (const <a class="el" href="classcgv_1_1data_1_1data__view.html">data_view</a> &amp;dv, const std::vector&lt; <a class="el" href="classcgv_1_1data_1_1data__view.html">data_view</a> &gt; *palettes=0)</td></tr>
<tr class="memdesc:a2c76b7a71ad26a1f621ad209d980fc57"><td class="mdescLeft">&#160;</td><td class="mdescRight">read image to a data_view with the correct format and an allocated pointer  <a href="classcgv_1_1media_1_1image_1_1image__reader.html#a2c76b7a71ad26a1f621ad209d980fc57">More...</a><br /></td></tr>
<tr class="separator:a2c76b7a71ad26a1f621ad209d980fc57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dcb64349ead610304e739e09997099e"><td class="memItemLeft" align="right" valign="top"><a id="a6dcb64349ead610304e739e09997099e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#a6dcb64349ead610304e739e09997099e">close</a> ()</td></tr>
<tr class="memdesc:a6dcb64349ead610304e739e09997099e"><td class="mdescLeft">&#160;</td><td class="mdescRight">close the image file <br /></td></tr>
<tr class="separator:a6dcb64349ead610304e739e09997099e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a9ca57ee7e6364153cda52223b8501"><td class="memItemLeft" align="right" valign="top"><a id="a79a9ca57ee7e6364153cda52223b8501"></a>
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a79a9ca57ee7e6364153cda52223b8501">get_default_options</a> () const</td></tr>
<tr class="memdesc:a79a9ca57ee7e6364153cda52223b8501"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload to provide default options for registration <br /></td></tr>
<tr class="separator:a79a9ca57ee7e6364153cda52223b8501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec86a78e596c9c4fb203fcad98fb6afd"><td class="memItemLeft" align="right" valign="top"><a id="aec86a78e596c9c4fb203fcad98fb6afd"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#aec86a78e596c9c4fb203fcad98fb6afd">get_name_or_type_name</a> () const</td></tr>
<tr class="memdesc:aec86a78e596c9c4fb203fcad98fb6afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">determine name of instance by checking <a class="el" href="classcgv_1_1base_1_1named.html" title="base class for all gui types">cgv::base::named</a> interface and in failure fallback to <a class="el" href="classcgv_1_1base_1_1base.html#a6e64a898476591f7246e522652abfa4c" title="overload to return the type name of this object. By default the type interface is queried over get_ty...">get_type_name()</a> <br /></td></tr>
<tr class="separator:aec86a78e596c9c4fb203fcad98fb6afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f074aea5bf4b0bfeb00845750d27623"><td class="memItemLeft" align="right" valign="top"><a id="a2f074aea5bf4b0bfeb00845750d27623"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a2f074aea5bf4b0bfeb00845750d27623">on_register</a> ()</td></tr>
<tr class="memdesc:a2f074aea5bf4b0bfeb00845750d27623"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload to handle register events that is sent after the instance has been registered <br /></td></tr>
<tr class="separator:a2f074aea5bf4b0bfeb00845750d27623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3db0f57373229e66422eeeb6750ebc"><td class="memItemLeft" align="right" valign="top"><a id="a0b3db0f57373229e66422eeeb6750ebc"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a0b3db0f57373229e66422eeeb6750ebc">unregister</a> ()</td></tr>
<tr class="memdesc:a0b3db0f57373229e66422eeeb6750ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload to handle unregistration of instances <br /></td></tr>
<tr class="separator:a0b3db0f57373229e66422eeeb6750ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313232084b52192201cecaf4ae257ee8"><td class="memItemLeft" align="right" valign="top"><a id="a313232084b52192201cecaf4ae257ee8"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a313232084b52192201cecaf4ae257ee8">on_exit_request</a> ()</td></tr>
<tr class="memdesc:a313232084b52192201cecaf4ae257ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload to handle the appication exit request, return true if exiting is allowed and false otherwise <br /></td></tr>
<tr class="separator:a313232084b52192201cecaf4ae257ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95bafefa81ebfa3206014eb198e49459"><td class="memItemLeft" align="right" valign="top"><a id="a95bafefa81ebfa3206014eb198e49459"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a95bafefa81ebfa3206014eb198e49459">stream_stats</a> (std::ostream &amp;)</td></tr>
<tr class="memdesc:a95bafefa81ebfa3206014eb198e49459"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload to show the content of this object <br /></td></tr>
<tr class="separator:a95bafefa81ebfa3206014eb198e49459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2b95a4802d2a4fc33b556726e0656f"><td class="memItemLeft" align="right" valign="top"><a id="a6d2b95a4802d2a4fc33b556726e0656f"></a>
virtual <a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; named, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a6d2b95a4802d2a4fc33b556726e0656f">get_named</a> ()</td></tr>
<tr class="memdesc:a6d2b95a4802d2a4fc33b556726e0656f"><td class="mdescLeft">&#160;</td><td class="mdescRight">cast upward to named <br /></td></tr>
<tr class="separator:a6d2b95a4802d2a4fc33b556726e0656f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5198433016d177ca57f4c24c3427eca"><td class="memItemLeft" align="right" valign="top"><a id="ac5198433016d177ca57f4c24c3427eca"></a>
virtual <a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; node, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#ac5198433016d177ca57f4c24c3427eca">get_node</a> ()</td></tr>
<tr class="memdesc:ac5198433016d177ca57f4c24c3427eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">cast upward to node <br /></td></tr>
<tr class="separator:ac5198433016d177ca57f4c24c3427eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6c94f5eb8784c955f687984cbb70ae"><td class="memItemLeft" align="right" valign="top"><a id="acd6c94f5eb8784c955f687984cbb70ae"></a>
virtual <a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; group, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#acd6c94f5eb8784c955f687984cbb70ae">get_group</a> ()</td></tr>
<tr class="memdesc:acd6c94f5eb8784c955f687984cbb70ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">cast upward to group <br /></td></tr>
<tr class="separator:acd6c94f5eb8784c955f687984cbb70ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0c5b45da256e0696602feaf69a5cf3"><td class="memItemLeft" align="right" valign="top"><a id="acb0c5b45da256e0696602feaf69a5cf3"></a>
virtual <a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; const named, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#acb0c5b45da256e0696602feaf69a5cf3">get_named_const</a> () const</td></tr>
<tr class="memdesc:acb0c5b45da256e0696602feaf69a5cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">const cast upward to named <br /></td></tr>
<tr class="separator:acb0c5b45da256e0696602feaf69a5cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0c21c14a4322c3edcce6018ab1c608"><td class="memItemLeft" align="right" valign="top"><a id="a5c0c21c14a4322c3edcce6018ab1c608"></a>
virtual <a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; const node, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a5c0c21c14a4322c3edcce6018ab1c608">get_node_const</a> () const</td></tr>
<tr class="memdesc:a5c0c21c14a4322c3edcce6018ab1c608"><td class="mdescLeft">&#160;</td><td class="mdescRight">const cast upward to node <br /></td></tr>
<tr class="separator:a5c0c21c14a4322c3edcce6018ab1c608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8229995c361dc313cecd1ca42ded82ae"><td class="memItemLeft" align="right" valign="top"><a id="a8229995c361dc313cecd1ca42ded82ae"></a>
virtual <a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; const group, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a8229995c361dc313cecd1ca42ded82ae">get_group_const</a> () const</td></tr>
<tr class="memdesc:a8229995c361dc313cecd1ca42ded82ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">const cast upward to group <br /></td></tr>
<tr class="separator:a8229995c361dc313cecd1ca42ded82ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6401d6fb8aa227bd28cacc7e42b39e2b"><td class="memTemplParams" colspan="2"><a id="a6401d6fb8aa227bd28cacc7e42b39e2b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6401d6fb8aa227bd28cacc7e42b39e2b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; T, true &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a6401d6fb8aa227bd28cacc7e42b39e2b">cast</a> ()</td></tr>
<tr class="memdesc:a6401d6fb8aa227bd28cacc7e42b39e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">cast to arbitrary class, but use the casts to named, node and group from the interface <br /></td></tr>
<tr class="separator:a6401d6fb8aa227bd28cacc7e42b39e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4ce80d45ccfdc5100f7ddd2f33b64d"><td class="memTemplParams" colspan="2"><a id="a5e4ce80d45ccfdc5100f7ddd2f33b64d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a5e4ce80d45ccfdc5100f7ddd2f33b64d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; const T, true &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a5e4ce80d45ccfdc5100f7ddd2f33b64d">cast_const</a> ()</td></tr>
<tr class="memdesc:a5e4ce80d45ccfdc5100f7ddd2f33b64d"><td class="mdescLeft">&#160;</td><td class="mdescRight">const cast to arbitrary class, but use the casts to named, node and group from the interface <br /></td></tr>
<tr class="separator:a5e4ce80d45ccfdc5100f7ddd2f33b64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b866151a23c63b3e8029849e71a796"><td class="memTemplParams" colspan="2"><a id="aa2b866151a23c63b3e8029849e71a796"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa2b866151a23c63b3e8029849e71a796"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#aa2b866151a23c63b3e8029849e71a796">get_interface</a> ()</td></tr>
<tr class="memdesc:aa2b866151a23c63b3e8029849e71a796"><td class="mdescLeft">&#160;</td><td class="mdescRight">use dynamic type cast to check for the given interface <br /></td></tr>
<tr class="separator:aa2b866151a23c63b3e8029849e71a796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322bdd4891db870dafaba22e40d99bff"><td class="memTemplParams" colspan="2"><a id="a322bdd4891db870dafaba22e40d99bff"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a322bdd4891db870dafaba22e40d99bff"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a322bdd4891db870dafaba22e40d99bff">get_const_interface</a> () const</td></tr>
<tr class="memdesc:a322bdd4891db870dafaba22e40d99bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">use dynamic type cast to check for the given interface <br /></td></tr>
<tr class="separator:a322bdd4891db870dafaba22e40d99bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1dd0ff6fa2baf3dc2149d3acfecd45"><td class="memItemLeft" align="right" valign="top"><a id="a3e1dd0ff6fa2baf3dc2149d3acfecd45"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a3e1dd0ff6fa2baf3dc2149d3acfecd45">update</a> ()</td></tr>
<tr class="memdesc:a3e1dd0ff6fa2baf3dc2149d3acfecd45"><td class="mdescLeft">&#160;</td><td class="mdescRight">this virtual update allows for example to ask a view to update the viewed value. The default implementation is empty. <br /></td></tr>
<tr class="separator:a3e1dd0ff6fa2baf3dc2149d3acfecd45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed62898813a55528e2b4c2c9e57cdf15"><td class="memItemLeft" align="right" valign="top"><a id="aed62898813a55528e2b4c2c9e57cdf15"></a>
virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#aed62898813a55528e2b4c2c9e57cdf15">get_user_data</a> () const</td></tr>
<tr class="memdesc:aed62898813a55528e2b4c2c9e57cdf15"><td class="mdescLeft">&#160;</td><td class="mdescRight">this virtual method allows to pass application specific data for internal purposes <br /></td></tr>
<tr class="separator:aed62898813a55528e2b4c2c9e57cdf15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b5dba890a068acef62d9c026c05320"><td class="memItemLeft" align="right" valign="top"><a id="a67b5dba890a068acef62d9c026c05320"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1data_1_1ref__counted.html#a67b5dba890a068acef62d9c026c05320">get_ref_count</a> () const</td></tr>
<tr class="memdesc:a67b5dba890a068acef62d9c026c05320"><td class="mdescLeft">&#160;</td><td class="mdescRight">read access to current count <br /></td></tr>
<tr class="separator:a67b5dba890a068acef62d9c026c05320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">property interface</div></td></tr>
<tr class="memitem:aa0fe4266b74ebe49de68faaab3ca7a7a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#aa0fe4266b74ebe49de68faaab3ca7a7a">self_reflect</a> (<a class="el" href="classcgv_1_1reflect_1_1reflection__handler.html">cgv::reflect::reflection_handler</a> &amp;)</td></tr>
<tr class="memdesc:aa0fe4266b74ebe49de68faaab3ca7a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">used for simple self reflection  <a href="classcgv_1_1base_1_1base.html#aa0fe4266b74ebe49de68faaab3ca7a7a">More...</a><br /></td></tr>
<tr class="separator:aa0fe4266b74ebe49de68faaab3ca7a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d54b3a4cef6b98b98b0d97d41cad410"><td class="memItemLeft" align="right" valign="top"><a id="a6d54b3a4cef6b98b98b0d97d41cad410"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a6d54b3a4cef6b98b98b0d97d41cad410">on_set</a> (void *member_ptr)</td></tr>
<tr class="memdesc:a6d54b3a4cef6b98b98b0d97d41cad410"><td class="mdescLeft">&#160;</td><td class="mdescRight">this callback is called when the set_void method has changed a member and can be overloaded in derived class <br /></td></tr>
<tr class="separator:a6d54b3a4cef6b98b98b0d97d41cad410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6746cd9f70fefe5a4f2b72534869fcc3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a6746cd9f70fefe5a4f2b72534869fcc3">call_void</a> (const std::string &amp;method, const std::vector&lt; std::string &gt; &amp;param_value_types, const std::vector&lt; const void * &gt; &amp;param_value_ptrs, const std::string &amp;result_type=&quot;&quot;, void *result_value_ptr=0)</td></tr>
<tr class="memdesc:a6746cd9f70fefe5a4f2b72534869fcc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract interface to call an action  <a href="classcgv_1_1base_1_1base.html#a6746cd9f70fefe5a4f2b72534869fcc3">More...</a><br /></td></tr>
<tr class="separator:a6746cd9f70fefe5a4f2b72534869fcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff38549b7f5c57918898543e78a416d"><td class="memItemLeft" align="right" valign="top"><a id="a1ff38549b7f5c57918898543e78a416d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a1ff38549b7f5c57918898543e78a416d">set</a> (const std::string &amp;property, const char *value)</td></tr>
<tr class="memdesc:a1ff38549b7f5c57918898543e78a416d"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialization of set method to support const char* as strings <br /></td></tr>
<tr class="separator:a1ff38549b7f5c57918898543e78a416d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1b6b56455165d769b580d4006eba17"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abd1b6b56455165d769b580d4006eba17"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#abd1b6b56455165d769b580d4006eba17">set</a> (const std::string &amp;property, const T &amp;value)</td></tr>
<tr class="memdesc:abd1b6b56455165d769b580d4006eba17"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a property of the element to the given value and perform standard conversions if necessary.  <a href="classcgv_1_1base_1_1base.html#abd1b6b56455165d769b580d4006eba17">More...</a><br /></td></tr>
<tr class="separator:abd1b6b56455165d769b580d4006eba17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5978e45464c3fdd3083426c4b21ed28a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5978e45464c3fdd3083426c4b21ed28a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a5978e45464c3fdd3083426c4b21ed28a">get</a> (const std::string &amp;property)</td></tr>
<tr class="memdesc:a5978e45464c3fdd3083426c4b21ed28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">query a property of the element and perform standard conversions if necessary.  <a href="classcgv_1_1base_1_1base.html#a5978e45464c3fdd3083426c4b21ed28a">More...</a><br /></td></tr>
<tr class="separator:a5978e45464c3fdd3083426c4b21ed28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfaded48bb322a4b77350ca73c9e1a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#afbfaded48bb322a4b77350ca73c9e1a2">multi_set</a> (const std::string &amp;property_assignments, bool report_error=true)</td></tr>
<tr class="memdesc:afbfaded48bb322a4b77350ca73c9e1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">set several properties  <a href="classcgv_1_1base_1_1base.html#afbfaded48bb322a4b77350ca73c9e1a2">More...</a><br /></td></tr>
<tr class="separator:afbfaded48bb322a4b77350ca73c9e1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad796aa58a0b7d9c52d724a99366f58ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#ad796aa58a0b7d9c52d724a99366f58ae">is_property</a> (const std::string &amp;property_name, std::string *<a class="el" href="structcgv_1_1type_1_1info_1_1type__name.html">type_name</a>=0)</td></tr>
<tr class="memdesc:ad796aa58a0b7d9c52d724a99366f58ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if the given name specifies a property.  <a href="classcgv_1_1base_1_1base.html#ad796aa58a0b7d9c52d724a99366f58ae">More...</a><br /></td></tr>
<tr class="separator:ad796aa58a0b7d9c52d724a99366f58ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad121ecb072de62a4ab4a180bc9d183bb"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#ad121ecb072de62a4ab4a180bc9d183bb">find_member_ptr</a> (const std::string &amp;property_name, std::string *<a class="el" href="structcgv_1_1type_1_1info_1_1type__name.html">type_name</a>=0)</td></tr>
<tr class="memdesc:ad121ecb072de62a4ab4a180bc9d183bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">find a member pointer by name.  <a href="classcgv_1_1base_1_1base.html#ad121ecb072de62a4ab4a180bc9d183bb">More...</a><br /></td></tr>
<tr class="separator:ad121ecb072de62a4ab4a180bc9d183bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a9a466ccd0592fce2eb3d5e2b1e4fdea8"><td class="memItemLeft" align="right" valign="top"><a id="a9a466ccd0592fce2eb3d5e2b1e4fdea8"></a>
static const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#a9a466ccd0592fce2eb3d5e2b1e4fdea8">get_supported_extensions</a> (char sep=';')</td></tr>
<tr class="memdesc:a9a466ccd0592fce2eb3d5e2b1e4fdea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a string with a list of supported extensions, where the list entries are separated with the passed character that defaults to a semicolon <br /></td></tr>
<tr class="separator:a9a466ccd0592fce2eb3d5e2b1e4fdea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4300692a9dd706fafb21c4707b57e360"><td class="memItemLeft" align="right" valign="top"><a id="a4300692a9dd706fafb21c4707b57e360"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#a4300692a9dd706fafb21c4707b57e360">construct_filter_string</a> ()</td></tr>
<tr class="memdesc:a4300692a9dd706fafb21c4707b57e360"><td class="mdescLeft">&#160;</td><td class="mdescRight">use this to generate a file_open_dialog or file_save_dialog <br /></td></tr>
<tr class="separator:a4300692a9dd706fafb21c4707b57e360"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa31653a404d2100655e91db9c00cfda1"><td class="memItemLeft" align="right" valign="top"><a id="aa31653a404d2100655e91db9c00cfda1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#aa31653a404d2100655e91db9c00cfda1">set_void</a> (const std::string &amp;property, const std::string &amp;type, const void *value)</td></tr>
<tr class="memdesc:aa31653a404d2100655e91db9c00cfda1"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract interface for the setter, by default it simply returns false <br /></td></tr>
<tr class="separator:aa31653a404d2100655e91db9c00cfda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96a1e4519bc87a517b5149ba27095e0"><td class="memItemLeft" align="right" valign="top"><a id="aa96a1e4519bc87a517b5149ba27095e0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#aa96a1e4519bc87a517b5149ba27095e0">get_void</a> (const std::string &amp;property, const std::string &amp;type, void *value)</td></tr>
<tr class="memdesc:aa96a1e4519bc87a517b5149ba27095e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract interface for the getter, by default it simply returns false <br /></td></tr>
<tr class="separator:aa96a1e4519bc87a517b5149ba27095e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abceffe95f08d3fc13cf9286cf360e705"><td class="memItemLeft" align="right" valign="top"><a id="abceffe95f08d3fc13cf9286cf360e705"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1data_1_1ref__counted.html#abceffe95f08d3fc13cf9286cf360e705">set_ref_count</a> (int c) const</td></tr>
<tr class="memdesc:abceffe95f08d3fc13cf9286cf360e705"><td class="mdescLeft">&#160;</td><td class="mdescRight">write access is also const to allow ref counted pointers to const instances <br /></td></tr>
<tr class="separator:abceffe95f08d3fc13cf9286cf360e705"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:ad8d0e6ffe70e6d8adc43876dfca2e84a"><td class="memTemplParams" colspan="2"><a id="ad8d0e6ffe70e6d8adc43876dfca2e84a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad8d0e6ffe70e6d8adc43876dfca2e84a"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; T, true &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#ad8d0e6ffe70e6d8adc43876dfca2e84a">cast_dynamic</a> (base *b)</td></tr>
<tr class="memdesc:ad8d0e6ffe70e6d8adc43876dfca2e84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">use dynamic cast for upcast to given class <br /></td></tr>
<tr class="separator:ad8d0e6ffe70e6d8adc43876dfca2e84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a9ddc1db8060bc3db63e484d33d6d92d7"><td class="memItemLeft" align="right" valign="top"><a id="a9ddc1db8060bc3db63e484d33d6d92d7"></a>
<a class="el" href="classcgv_1_1data_1_1data__format.html">data_format</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#a9ddc1db8060bc3db63e484d33d6d92d7">file_format_ptr</a></td></tr>
<tr class="memdesc:a9ddc1db8060bc3db63e484d33d6d92d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">store the data format <br /></td></tr>
<tr class="separator:a9ddc1db8060bc3db63e484d33d6d92d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b99d1b652a7329368dc5c5f81fb367"><td class="memItemLeft" align="right" valign="top"><a id="aa4b99d1b652a7329368dc5c5f81fb367"></a>
std::vector&lt; <a class="el" href="classcgv_1_1data_1_1data__format.html">data_format</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#aa4b99d1b652a7329368dc5c5f81fb367">palette_formats</a></td></tr>
<tr class="memdesc:aa4b99d1b652a7329368dc5c5f81fb367"><td class="mdescLeft">&#160;</td><td class="mdescRight">store a pointer to the palette format vector <br /></td></tr>
<tr class="separator:aa4b99d1b652a7329368dc5c5f81fb367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab041be814b1f7e6b1320809bf9b189e1"><td class="memItemLeft" align="right" valign="top"><a id="ab041be814b1f7e6b1320809bf9b189e1"></a>
<a class="el" href="classcgv_1_1media_1_1image_1_1abst__image__reader.html">abst_image_reader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#ab041be814b1f7e6b1320809bf9b189e1">rd</a></td></tr>
<tr class="memdesc:ab041be814b1f7e6b1320809bf9b189e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">store a pointer to the chosen reader <br /></td></tr>
<tr class="separator:ab041be814b1f7e6b1320809bf9b189e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0177b30a41f7c5154316310ffd8c51b0"><td class="memItemLeft" align="right" valign="top"><a id="a0177b30a41f7c5154316310ffd8c51b0"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#a0177b30a41f7c5154316310ffd8c51b0">last_error</a></td></tr>
<tr class="memdesc:a0177b30a41f7c5154316310ffd8c51b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">last error message in case no reader is available <br /></td></tr>
<tr class="separator:a0177b30a41f7c5154316310ffd8c51b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>the image reader chooses a specific reader automatically based on the extension of the given file name. </p>
<p>In the open method it sets the format passed by reference to the reader in the constructor. </p>

<p class="definition">Definition at line <a class="el" href="image__reader_8h_source.html#l00063">63</a> of file <a class="el" href="image__reader_8h_source.html">image_reader.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abe89ffd5db0943e20d19bc3494e25e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe89ffd5db0943e20d19bc3494e25e88">&#9670;&nbsp;</a></span>image_reader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cgv::media::image::image_reader::image_reader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcgv_1_1data_1_1data__format.html">data_format</a> &amp;&#160;</td>
          <td class="paramname"><em>file_format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcgv_1_1data_1_1data__format.html">data_format</a> &gt; *&#160;</td>
          <td class="paramname"><em>palette_formats</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>construct an image reader from a reference to a data format instance in which the format of the image file will be stored after a call to the open method. </p>
<p>construct an image <a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html" title="the image reader chooses a specific reader automatically based on the extension of the given file nam...">image_reader</a> from a file name</p>
<p>If also images with palettes should be handled, provide also a vector of data formats for the palettes. By default no vector is provided such that the reader converts paletted image formats to non paletted ones. In case palettes are used, the components in the file_format will be '0', '1', ... for the components that reference the i-th palette. </p>

<p class="definition">Definition at line <a class="el" href="image__reader_8cxx_source.html#l00078">78</a> of file <a class="el" href="image__reader_8cxx_source.html">image_reader.cxx</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6746cd9f70fefe5a4f2b72534869fcc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6746cd9f70fefe5a4f2b72534869fcc3">&#9670;&nbsp;</a></span>call_void()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::base::base::call_void </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>param_value_types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>param_value_ptrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>result_type</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>result_value_ptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>abstract interface to call an action </p>
<p>overload to implement the execution of a method based on the method name and the given parameters</p>
<p>, i.e. a class method based on the action name and the given parameters. The default implementation uses the <a class="el" href="classcgv_1_1base_1_1base.html#aa0fe4266b74ebe49de68faaab3ca7a7a" title="used for simple self reflection">self_reflect()</a> method to dispatch this call. If not found, the get_void method returns false. </p>

<p class="definition">Definition at line <a class="el" href="base_8cxx_source.html#l00168">168</a> of file <a class="el" href="base_8cxx_source.html">base.cxx</a>.</p>

</div>
</div>
<a id="ad121ecb072de62a4ab4a180bc9d183bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad121ecb072de62a4ab4a180bc9d183bb">&#9670;&nbsp;</a></span>find_member_ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * cgv::base::base::find_member_ptr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>property_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>type_name</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find a member pointer by name. </p>
<p>If not found the null pointer is returned. If the type name string pointer is provided, the type of the property is copied to the referenced string. </p>

<p class="definition">Definition at line <a class="el" href="base_8cxx_source.html#l00360">360</a> of file <a class="el" href="base_8cxx_source.html">base.cxx</a>.</p>

<p class="reference">References <a class="el" href="find__reflection__handler_8cxx_source.html#l00047">cgv::reflect::find_reflection_handler::found_target()</a>, <a class="el" href="find__reflection__handler_8cxx_source.html#l00059">cgv::reflect::find_reflection_handler::get_member_ptr()</a>, <a class="el" href="find__reflection__handler_8cxx_source.html#l00072">cgv::reflect::find_reflection_handler::get_reflection_traits()</a>, and <a class="el" href="structcgv_1_1reflect_1_1abst__reflection__traits.html#aa00b01c2252909e01eb154c6170df6d2">cgv::reflect::abst_reflection_traits::get_type_name()</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__handler_8cxx_source.html#l00022">cgv::gui::event_handler::add_key_control()</a>.</p>

</div>
</div>
<a id="a5978e45464c3fdd3083426c4b21ed28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5978e45464c3fdd3083426c4b21ed28a">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T cgv::base::base::get </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>property</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>query a property of the element and perform standard conversions if necessary. </p>
<p>This templated version simply extracts the type of the value from the reference and calls the <a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#aa31653a404d2100655e91db9c00cfda1" title="abstract interface for the setter, by default it simply returns false">set_void()</a> method. Note that this only works if the template cgv::type::info::type_name&lt;T&gt; is overloaded for the value type. </p>

<p class="definition">Definition at line <a class="el" href="base_8h_source.html#l00192">192</a> of file <a class="el" href="base_8h_source.html">base.h</a>.</p>

</div>
</div>
<a id="a97b29aba3062357f7a1c8315f428b559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b29aba3062357f7a1c8315f428b559">&#9670;&nbsp;</a></span>get_file_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcgv_1_1data_1_1data__format.html">data_format</a> * cgv::media::image::image_reader::get_file_format </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the data format of the image file </p>
<p>return the image info </p>

<p class="definition">Definition at line <a class="el" href="image__reader_8cxx_source.html#l00167">167</a> of file <a class="el" href="image__reader_8cxx_source.html">image_reader.cxx</a>.</p>

<p class="reference">References <a class="el" href="image__reader_8h_source.html#l00067">file_format_ptr</a>.</p>

</div>
</div>
<a id="a4dea520977d6412453e42e3550e16b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dea520977d6412453e42e3550e16b7c">&#9670;&nbsp;</a></span>get_image_duration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float cgv::media::image::image_reader::get_image_duration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the duration of the current image in seconds, if returned value is 0, no duration is available </p>
<p>return the duration of the current image in seconds </p>

<p class="definition">Definition at line <a class="el" href="image__reader_8cxx_source.html#l00187">187</a> of file <a class="el" href="image__reader_8cxx_source.html">image_reader.cxx</a>.</p>

<p class="reference">References <a class="el" href="image__reader_8cxx_source.html#l00028">cgv::media::image::abst_image_reader::get_image_duration()</a>, and <a class="el" href="image__reader_8h_source.html#l00071">rd</a>.</p>

<p class="reference">Referenced by <a class="el" href="gl__tools_8cxx_source.html#l00049">cgv::render::gl::read_image_to_textures()</a>, and <a class="el" href="image__drawable_8cxx_source.html#l00162">cgv::render::gl::image_drawable::save_images()</a>.</p>

</div>
</div>
<a id="ad796aa58a0b7d9c52d724a99366f58ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad796aa58a0b7d9c52d724a99366f58ae">&#9670;&nbsp;</a></span>is_property()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::base::base::is_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>property_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>type_name</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check if the given name specifies a property. </p>
<p>If the type name string pointer is provided, the type of the property is copied to the referenced string. </p>

<p class="definition">Definition at line <a class="el" href="base_8cxx_source.html#l00336">336</a> of file <a class="el" href="base_8cxx_source.html">base.cxx</a>.</p>

<p class="reference">References <a class="el" href="tokenizer_8h_source.html#l00121">cgv::utils::bite_all()</a>, and <a class="el" href="convert__string_8h_source.html#l00018">cgv::utils::to_string()</a>.</p>

</div>
</div>
<a id="afbfaded48bb322a4b77350ca73c9e1a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbfaded48bb322a4b77350ca73c9e1a2">&#9670;&nbsp;</a></span>multi_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cgv::base::base::multi_set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>property_assignments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>report_error</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set several properties </p>
<p>set several properties, which are defined as colon separated assignments, where the types are derived automatically</p>
<p>, which are defined as colon separated assignments, where the types are derived automatically to bool, int, double or std::string. </p>

<p class="definition">Definition at line <a class="el" href="base_8cxx_source.html#l00287">287</a> of file <a class="el" href="base_8cxx_source.html">base.cxx</a>.</p>

<p class="reference">References <a class="el" href="tokenizer_8h_source.html#l00121">cgv::utils::bite_all()</a>, <a class="el" href="scan_8cxx_source.html#l00017">cgv::utils::is_digit()</a>, <a class="el" href="scan_8cxx_source.html#l00353">cgv::utils::is_integer()</a>, and <a class="el" href="convert__string_8h_source.html#l00018">cgv::utils::to_string()</a>.</p>

<p class="reference">Referenced by <a class="el" href="base__generator_8h_source.html#l00132">cgv::base::has_property()</a>, and <a class="el" href="texture_8cxx_source.html#l00429">cgv::render::texture::write_to_file()</a>.</p>

</div>
</div>
<a id="aa7e432a1d23297e019079b5dbd83e8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7e432a1d23297e019079b5dbd83e8db">&#9670;&nbsp;</a></span>open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::media::image::image_reader::open </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>open the file and read the image header in order to determine the data format of the file, which is stored in the data format specified in the constructor </p>
<p>open the file and read the image header in order to determine the data format </p>

<p class="definition">Definition at line <a class="el" href="image__reader_8cxx_source.html#l00140">140</a> of file <a class="el" href="image__reader_8cxx_source.html">image_reader.cxx</a>.</p>

<p class="reference">References <a class="el" href="image__reader_8h_source.html#l00067">file_format_ptr</a>, <a class="el" href="base_8h_source.html#l00128">cgv::base::base::get_interface()</a>, <a class="el" href="image__reader_8cxx_source.html#l00084">get_supported_extensions()</a>, <a class="el" href="scan_8cxx_source.html#l00288">cgv::utils::is_element()</a>, <a class="el" href="image__reader_8h_source.html#l00073">last_error</a>, <a class="el" href="classcgv_1_1media_1_1image_1_1abst__image__reader.html#a21741f88130baa3224809472f69df8b5">cgv::media::image::abst_image_reader::open()</a>, <a class="el" href="image__reader_8h_source.html#l00069">palette_formats</a>, and <a class="el" href="image__reader_8h_source.html#l00071">rd</a>.</p>

<p class="reference">Referenced by <a class="el" href="gltf__support_8cxx_source.html#l00134">cgv::render::build_render_info()</a>, <a class="el" href="image__drawable_8cxx_source.html#l00113">cgv::render::gl::image_drawable::read_image()</a>, <a class="el" href="image__reader_8cxx_source.html#l00120">read_image()</a>, <a class="el" href="gl__tools_8cxx_source.html#l00049">cgv::render::gl::read_image_to_textures()</a>, <a class="el" href="image__drawable_8cxx_source.html#l00133">cgv::render::gl::image_drawable::read_images()</a>, and <a class="el" href="image__drawable_8cxx_source.html#l00162">cgv::render::gl::image_drawable::save_images()</a>.</p>

</div>
</div>
<a id="a2c76b7a71ad26a1f621ad209d980fc57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c76b7a71ad26a1f621ad209d980fc57">&#9670;&nbsp;</a></span>read_image() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::media::image::image_reader::read_image </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1data_1_1data__view.html">data_view</a> &amp;&#160;</td>
          <td class="paramname"><em>dv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcgv_1_1data_1_1data__view.html">data_view</a> &gt; *&#160;</td>
          <td class="paramname"><em>palettes</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read image to a data_view with the correct format and an allocated pointer </p>
<p>read the whole image into the given data pointer, set data format if not yet specified and allocate the data ptr if not yet done. If image file has not been opened yet, open it and close it after reading </p>

<p class="definition">Definition at line <a class="el" href="image__reader_8cxx_source.html#l00276">276</a> of file <a class="el" href="image__reader_8cxx_source.html">image_reader.cxx</a>.</p>

<p class="reference">References <a class="el" href="data__view_8cxx_source.html#l00113">cgv::data::data_view_impl&lt; D, P &gt;::empty()</a>, <a class="el" href="image__reader_8h_source.html#l00067">file_format_ptr</a>, <a class="el" href="image__reader_8h_source.html#l00069">palette_formats</a>, <a class="el" href="image__reader_8h_source.html#l00071">rd</a>, <a class="el" href="classcgv_1_1media_1_1image_1_1abst__image__reader.html#af3811feeb4f9c0c1b50e6985764af9bf">cgv::media::image::abst_image_reader::read_image()</a>, and <a class="el" href="image__reader_8cxx_source.html#l00211">read_palette()</a>.</p>

</div>
</div>
<a id="a46a96f9ca692b4ce82e776aabdce3351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a96f9ca692b4ce82e776aabdce3351">&#9670;&nbsp;</a></span>read_image() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::media::image::image_reader::read_image </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1data_1_1data__view.html">data_view</a> &amp;&#160;</td>
          <td class="paramname"><em>dv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcgv_1_1data_1_1data__view.html">data_view</a> &gt; *&#160;</td>
          <td class="paramname"><em>palettes</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read the image into the given data view that must have the correct format and an allocated data pointer. </p>
<p>read the whole image into the given data pointer, set data format if not yet specified and allocate the data ptr if not yet done. If image file has not been opened yet, open it and close it after reading </p>

<p class="definition">Definition at line <a class="el" href="image__reader_8cxx_source.html#l00130">130</a> of file <a class="el" href="image__reader_8cxx_source.html">image_reader.cxx</a>.</p>

<p class="reference">References <a class="el" href="image__reader_8cxx_source.html#l00295">close()</a>, <a class="el" href="component__format_8cxx_source.html#l00318">cgv::data::component_format::empty()</a>, <a class="el" href="data__view_8cxx_source.html#l00113">cgv::data::data_view_impl&lt; D, P &gt;::empty()</a>, <a class="el" href="image__reader_8h_source.html#l00067">file_format_ptr</a>, <a class="el" href="image__reader_8cxx_source.html#l00140">open()</a>, and <a class="el" href="image__reader_8cxx_source.html#l00120">read_image()</a>.</p>

</div>
</div>
<a id="ac871d242183818bcacb62613a6907611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac871d242183818bcacb62613a6907611">&#9670;&nbsp;</a></span>read_image() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::media::image::image_reader::read_image </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcgv_1_1data_1_1data__view.html">data_view</a> &amp;&#160;</td>
          <td class="paramname"><em>dv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcgv_1_1data_1_1data__view.html">data_view</a> &gt; *&#160;</td>
          <td class="paramname"><em>palettes</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read the whole image into the given data view. </p>
<p>read the whole image into the given data pointer, set data format if not yet specified and allocate the data ptr if not yet done. If image file has not been opened yet, open it and close it after reading</p>
<p>If the data view is empty, set the format and allocate memory to hold the image data. The newly allocate data pointer will belong to the data view afterwards. If the data pointer of the data view is already allocated, use this in the same way as the alternate version of read_image with the const data_view argument does. </p>

<p class="definition">Definition at line <a class="el" href="image__reader_8cxx_source.html#l00120">120</a> of file <a class="el" href="image__reader_8cxx_source.html">image_reader.cxx</a>.</p>

<p class="reference">References <a class="el" href="image__reader_8cxx_source.html#l00295">close()</a>, <a class="el" href="component__format_8cxx_source.html#l00318">cgv::data::component_format::empty()</a>, <a class="el" href="image__reader_8h_source.html#l00067">file_format_ptr</a>, and <a class="el" href="image__reader_8cxx_source.html#l00140">open()</a>.</p>

<p class="reference">Referenced by <a class="el" href="gltf__support_8cxx_source.html#l00134">cgv::render::build_render_info()</a>, <a class="el" href="texture_8cxx_source.html#l00259">cgv::render::texture::create_from_image()</a>, <a class="el" href="image__reader_8cxx_source.html#l00130">read_image()</a>, <a class="el" href="gl__tools_8cxx_source.html#l00027">cgv::render::gl::read_image_to_texture()</a>, <a class="el" href="gl__tools_8cxx_source.html#l00049">cgv::render::gl::read_image_to_textures()</a>, <a class="el" href="texture_8cxx_source.html#l00708">cgv::render::texture::replace_from_image()</a>, and <a class="el" href="image__drawable_8cxx_source.html#l00162">cgv::render::gl::image_drawable::save_images()</a>.</p>

</div>
</div>
<a id="abadd93d051939e353e40d674718ebf1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abadd93d051939e353e40d674718ebf1b">&#9670;&nbsp;</a></span>read_image() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::media::image::image_reader::read_image </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcgv_1_1data_1_1data__view.html">data_view</a> &amp;&#160;</td>
          <td class="paramname"><em>dv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcgv_1_1data_1_1data__view.html">data_view</a> &gt; *&#160;</td>
          <td class="paramname"><em>palettes</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read an opened image data and palettes into a data views that are optionally allocated. </p>
<p>read the whole image into the given data pointer, set data format if not yet specified and allocate the data ptr if not yet done. If image file has not been opened yet, open it and close it after reading</p>
<p>read an image from an opened image file into the given data view. If the data format of the view has not been specified, set it to the data format of the file. If the data pointer is empty, allocate enough memory to hold the image. The pointer is then owned by the view. </p>

<p class="definition">Definition at line <a class="el" href="image__reader_8cxx_source.html#l00258">258</a> of file <a class="el" href="image__reader_8cxx_source.html">image_reader.cxx</a>.</p>

<p class="reference">References <a class="el" href="data__view_8cxx_source.html#l00113">cgv::data::data_view_impl&lt; D, P &gt;::empty()</a>, <a class="el" href="image__reader_8h_source.html#l00067">file_format_ptr</a>, <a class="el" href="image__reader_8h_source.html#l00069">palette_formats</a>, <a class="el" href="image__reader_8h_source.html#l00071">rd</a>, <a class="el" href="classcgv_1_1media_1_1image_1_1abst__image__reader.html#af3811feeb4f9c0c1b50e6985764af9bf">cgv::media::image::abst_image_reader::read_image()</a>, and <a class="el" href="image__reader_8cxx_source.html#l00211">read_palette()</a>.</p>

</div>
</div>
<a id="a265b84b8171b89cba0747f99e9e50058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a265b84b8171b89cba0747f99e9e50058">&#9670;&nbsp;</a></span>read_line() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::media::image::image_reader::read_line </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1data_1_1data__view.html">data_view</a> &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read line into a preallocated data view of the correct format </p>
<p>read the next line into the given data pointer, set data format if not yet specified and allocate the data ptr if not yet done </p>

<p class="definition">Definition at line <a class="el" href="image__reader_8cxx_source.html#l00250">250</a> of file <a class="el" href="image__reader_8cxx_source.html">image_reader.cxx</a>.</p>

<p class="reference">References <a class="el" href="data__view_8cxx_source.html#l00113">cgv::data::data_view_impl&lt; D, P &gt;::empty()</a>, <a class="el" href="image__reader_8h_source.html#l00067">file_format_ptr</a>, <a class="el" href="image__reader_8h_source.html#l00071">rd</a>, and <a class="el" href="classcgv_1_1media_1_1image_1_1abst__image__reader.html#afd444e1f0903a178c082d69fa8145099">cgv::media::image::abst_image_reader::read_line()</a>.</p>

</div>
</div>
<a id="af4ba97597b2df4857888b006b695ea92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ba97597b2df4857888b006b695ea92">&#9670;&nbsp;</a></span>read_line() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::media::image::image_reader::read_line </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcgv_1_1data_1_1data__view.html">data_view</a> &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read the next line into the given data view. </p>
<p>read the next line into the given data pointer, set data format if not yet specified and allocate the data ptr if not yet done</p>
<p>If the data format of the view has not been specified, set it to the data format of the file, construct a 1d subview and allocate memory for a line only. The data pointer is then owned by the view. </p>

<p class="definition">Definition at line <a class="el" href="image__reader_8cxx_source.html#l00237">237</a> of file <a class="el" href="image__reader_8cxx_source.html">image_reader.cxx</a>.</p>

<p class="reference">References <a class="el" href="data__view_8cxx_source.html#l00113">cgv::data::data_view_impl&lt; D, P &gt;::empty()</a>, <a class="el" href="image__reader_8h_source.html#l00067">file_format_ptr</a>, <a class="el" href="component__format_8cxx_source.html#l00396">cgv::data::component_format::get_entry_size()</a>, <a class="el" href="data__format_8cxx_source.html#l00262">cgv::data::data_format::get_width()</a>, <a class="el" href="image__reader_8h_source.html#l00071">rd</a>, <a class="el" href="classcgv_1_1media_1_1image_1_1abst__image__reader.html#afd444e1f0903a178c082d69fa8145099">cgv::media::image::abst_image_reader::read_line()</a>, and <a class="el" href="data__view_8cxx_source.html#l00285">cgv::data::data_view::set_ptr()</a>.</p>

</div>
</div>
<a id="a601be4379303d149dc43d3c382e92dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601be4379303d149dc43d3c382e92dcf">&#9670;&nbsp;</a></span>read_palette() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::media::image::image_reader::read_palette </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1data_1_1data__view.html">data_view</a> &amp;&#160;</td>
          <td class="paramname"><em>dv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read the i-th palette in case of a paletted file format, and handle the data view as in the read_image method the standard implementation returns false </p>
<p>read the i-th palette in case of a paletted file format, the standard implementation returns false</p>
<p>In case of files with animated images, the palette can change for each image. Therefore call this method before each call to <code><a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#ac871d242183818bcacb62613a6907611" title="read the whole image into the given data view.">read_image()</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="image__reader_8cxx_source.html#l00221">221</a> of file <a class="el" href="image__reader_8cxx_source.html">image_reader.cxx</a>.</p>

<p class="reference">References <a class="el" href="data__view_8cxx_source.html#l00113">cgv::data::data_view_impl&lt; D, P &gt;::empty()</a>, <a class="el" href="image__reader_8h_source.html#l00069">palette_formats</a>, <a class="el" href="image__reader_8h_source.html#l00071">rd</a>, and <a class="el" href="image__reader_8cxx_source.html#l00046">cgv::media::image::abst_image_reader::read_palette()</a>.</p>

</div>
</div>
<a id="a5f47f588ac70c2c9f7fb733d6bd9cff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f47f588ac70c2c9f7fb733d6bd9cff0">&#9670;&nbsp;</a></span>read_palette() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::media::image::image_reader::read_palette </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcgv_1_1data_1_1data__view.html">data_view</a> &amp;&#160;</td>
          <td class="paramname"><em>dv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read the i-th palette in case of a paletted file format, and handle the data view as in the read_image method the standard implementation returns false </p>
<p>read the i-th palette in case of a paletted file format, the standard implementation returns false</p>
<p>In case of files with animated images, the palette can change for each image. Therefore call this method before each call to <code><a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#ac871d242183818bcacb62613a6907611" title="read the whole image into the given data view.">read_image()</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="image__reader_8cxx_source.html#l00211">211</a> of file <a class="el" href="image__reader_8cxx_source.html">image_reader.cxx</a>.</p>

<p class="reference">References <a class="el" href="data__view_8cxx_source.html#l00113">cgv::data::data_view_impl&lt; D, P &gt;::empty()</a>, <a class="el" href="image__reader_8h_source.html#l00069">palette_formats</a>, <a class="el" href="image__reader_8h_source.html#l00071">rd</a>, and <a class="el" href="image__reader_8cxx_source.html#l00046">cgv::media::image::abst_image_reader::read_palette()</a>.</p>

<p class="reference">Referenced by <a class="el" href="texture_8cxx_source.html#l00259">cgv::render::texture::create_from_image()</a>, <a class="el" href="image__reader_8cxx_source.html#l00258">read_image()</a>, <a class="el" href="gl__tools_8cxx_source.html#l00049">cgv::render::gl::read_image_to_textures()</a>, <a class="el" href="texture_8cxx_source.html#l00708">cgv::render::texture::replace_from_image()</a>, and <a class="el" href="image__drawable_8cxx_source.html#l00162">cgv::render::gl::image_drawable::save_images()</a>.</p>

</div>
</div>
<a id="aa0fe4266b74ebe49de68faaab3ca7a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0fe4266b74ebe49de68faaab3ca7a7a">&#9670;&nbsp;</a></span>self_reflect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::base::base::self_reflect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcgv_1_1reflect_1_1reflection__handler.html">cgv::reflect::reflection_handler</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>used for simple self reflection </p>
<p>is used by default implementation of set_void, get_void and get_property_declarations</p>
<p>The overloaded implementation is used by the default implementations of set_void, get_void and get_property_declarations with corresponding reflection handlers. The default implementation of self_reflect is empty. </p>

<p>Reimplemented in <a class="el" href="structcgv_1_1render_1_1shader__config.html#aab0aef9de8e9f9820e151f0aae8b0031">cgv::render::shader_config</a>, and <a class="el" href="structcgv_1_1render_1_1render__config.html#a91eabc5d1bee4696cce6de5ad05dfbe8">cgv::render::render_config</a>.</p>

<p class="definition">Definition at line <a class="el" href="base_8cxx_source.html#l00161">161</a> of file <a class="el" href="base_8cxx_source.html">base.cxx</a>.</p>

</div>
</div>
<a id="abd1b6b56455165d769b580d4006eba17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd1b6b56455165d769b580d4006eba17">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cgv::base::base::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set a property of the element to the given value and perform standard conversions if necessary. </p>
<p>This templated version simply extracts the type of the value from the reference and calls the <a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#aa31653a404d2100655e91db9c00cfda1" title="abstract interface for the setter, by default it simply returns false">set_void()</a> method. Note that this only works if the template cgv::type::info::type_name&lt;T&gt; is overloaded for the value type. </p>

<p class="definition">Definition at line <a class="el" href="base_8h_source.html#l00186">186</a> of file <a class="el" href="base_8h_source.html">base.h</a>.</p>

</div>
</div>
<a id="af29e189b8a2da2409e9b9ba119108f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af29e189b8a2da2409e9b9ba119108f7b">&#9670;&nbsp;</a></span>supports_per_line_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::media::image::image_reader::supports_per_line_read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return whether the reader supports per line reading (only valid after successfully opening an image file) </p>
<p>whether the <a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html" title="the image reader chooses a specific reader automatically based on the extension of the given file nam...">image_reader</a> supports per line reading (only valid after successful opening an image file </p>

<p class="definition">Definition at line <a class="el" href="image__reader_8cxx_source.html#l00229">229</a> of file <a class="el" href="image__reader_8cxx_source.html">image_reader.cxx</a>.</p>

<p class="reference">References <a class="el" href="image__reader_8h_source.html#l00071">rd</a>, and <a class="el" href="classcgv_1_1media_1_1image_1_1abst__image__reader.html#a5ada7393c90cdec16d2ca107872eb7aa">cgv::media::image::abst_image_reader::supports_per_line_read()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>cgv/media/image/<a class="el" href="image__reader_8h_source.html">image_reader.h</a></li>
<li>cgv/media/image/<a class="el" href="image__reader_8cxx_source.html">image_reader.cxx</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecgv.html">cgv</a></li><li class="navelem"><b>media</b></li><li class="navelem"><a class="el" href="namespacecgv_1_1media_1_1image.html">image</a></li><li class="navelem"><a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html">image_reader</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
