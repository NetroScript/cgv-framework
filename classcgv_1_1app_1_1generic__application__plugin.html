<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cgv: cgv::app::generic_application_plugin&lt; base_drawable &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cgv
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classcgv_1_1app_1_1generic__application__plugin.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classcgv_1_1app_1_1generic__application__plugin-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cgv::app::generic_application_plugin&lt; base_drawable &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Extension of <a class="el" href="classcgv_1_1app_1_1application__plugin__base.html" title="Abstract base class for application plugins that provides capability to handle overlays,...">application_plugin_base</a> that allows to define a used drawable base class.  
 <a href="classcgv_1_1app_1_1generic__application__plugin.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="application__plugin_8h_source.html">application_plugin.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cgv::app::generic_application_plugin&lt; base_drawable &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcgv_1_1app_1_1generic__application__plugin.png" usemap="#cgv::app::generic_5Fapplication_5Fplugin_3C_20base_5Fdrawable_20_3E_map" alt=""/>
  <map id="cgv::app::generic_5Fapplication_5Fplugin_3C_20base_5Fdrawable_20_3E_map" name="cgv::app::generic_5Fapplication_5Fplugin_3C_20base_5Fdrawable_20_3E_map">
<area href="classcgv_1_1app_1_1application__plugin__base.html" title="Abstract base class for application plugins that provides capability to handle overlays,..." alt="cgv::app::application_plugin_base" shape="rect" coords="507,280,835,304"/>
<area href="classcgv_1_1base_1_1group.html" title="The group class is a node with children." alt="cgv::base::group" shape="rect" coords="169,224,497,248"/>
<area href="classcgv_1_1gui_1_1provider.html" title="derive from this class to provide a gui to the current viewer" alt="cgv::gui::provider" shape="rect" coords="507,224,835,248"/>
<area href="classcgv_1_1gui_1_1event__handler.html" title="interface for all classes that want to receive events" alt="cgv::gui::event_handler" shape="rect" coords="845,224,1173,248"/>
<area href="classcgv_1_1base_1_1node.html" title="The node class keeps a pointer to its parent." alt="cgv::base::node" shape="rect" coords="169,168,497,192"/>
<area href="classcgv_1_1base_1_1traverse__policy.html" title="nodes should inherit from this policy class to allow selective tree traversals" alt="cgv::base::traverse_policy" shape="rect" coords="845,168,1173,192"/>
<area href="classcgv_1_1base_1_1named.html" title="base class for all gui types" alt="cgv::base::named" shape="rect" coords="169,112,497,136"/>
<area href="classcgv_1_1base_1_1base.html" title="base class for all classes that can be registered with support for dynamic properties (see also secti..." alt="cgv::base::base" shape="rect" coords="169,56,497,80"/>
<area href="classcgv_1_1data_1_1ref__counted.html" title="if you derive your class from this class, a ref_ptr will do reference counting in the inhereted ref_c..." alt="cgv::data::ref_counted" shape="rect" coords="0,0,328,24"/>
<area href="structcgv_1_1reflect_1_1self__reflection__tag.html" title="Derive from this class to announce implementation of the method self_reflect." alt="cgv::reflect::self_reflection_tag" shape="rect" coords="338,0,666,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad852de85129a7c6590fb879948b84c85"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1app_1_1generic__application__plugin.html#ad852de85129a7c6590fb879948b84c85">generic_application_plugin</a> (const std::string &amp;<a class="el" href="classcgv_1_1base_1_1named.html#aeacb85dab71b803971f8611644898371">name</a>)</td></tr>
<tr class="memdesc:ad852de85129a7c6590fb879948b84c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an instance of the class as a group node with the given name.  <a href="classcgv_1_1app_1_1generic__application__plugin.html#ad852de85129a7c6590fb879948b84c85">More...</a><br /></td></tr>
<tr class="separator:ad852de85129a7c6590fb879948b84c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2dfb029b1958a382351907810c398e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1app_1_1generic__application__plugin.html#a6a2dfb029b1958a382351907810c398e">on_set</a> (void *member_ptr)</td></tr>
<tr class="memdesc:a6a2dfb029b1958a382351907810c398e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the pure virtual base class method that delegates the member change evaluation to handle_member_change and performs the default actions of updating all member GUI views and requesting a redraw.  <a href="classcgv_1_1app_1_1generic__application__plugin.html#a6a2dfb029b1958a382351907810c398e">More...</a><br /></td></tr>
<tr class="separator:a6a2dfb029b1958a382351907810c398e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f711351433d2c4e1bf974e5d342f1f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1app_1_1generic__application__plugin.html#a72f711351433d2c4e1bf974e5d342f1f">handle_member_change</a> (const cgv::utils::pointer_test &amp;m)</td></tr>
<tr class="memdesc:a72f711351433d2c4e1bf974e5d342f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty default implementation to handle member changes from GUI interactions or manual calls to <a class="el" href="classcgv_1_1app_1_1generic__application__plugin.html#a6a2dfb029b1958a382351907810c398e" title="Default implementation of the pure virtual base class method that delegates the member change evaluat...">on_set()</a> provided through a convenient evaluation interface.  <a href="classcgv_1_1app_1_1generic__application__plugin.html#a72f711351433d2c4e1bf974e5d342f1f">More...</a><br /></td></tr>
<tr class="separator:a72f711351433d2c4e1bf974e5d342f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c5ab68b0ff784056a4b014982ad43a2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1app_1_1generic__application__plugin.html#a8c5ab68b0ff784056a4b014982ad43a2">initialize_view_ptr</a> () final</td></tr>
<tr class="memdesc:a8c5ab68b0ff784056a4b014982ad43a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the view pointer using drawable::find_view_as_node().  <a href="classcgv_1_1app_1_1generic__application__plugin.html#a8c5ab68b0ff784056a4b014982ad43a2">More...</a><br /></td></tr>
<tr class="separator:a8c5ab68b0ff784056a4b014982ad43a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f8cfc69b09d2d9106d6ae82658d62b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af1f8cfc69b09d2d9106d6ae82658d62b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1data_1_1ref__ptr.html">cgv::data::ref_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1app_1_1application__plugin__base.html#af1f8cfc69b09d2d9106d6ae82658d62b">register_overlay</a> (const std::string &amp;<a class="el" href="classcgv_1_1base_1_1named.html#aeacb85dab71b803971f8611644898371">name</a>)</td></tr>
<tr class="memdesc:af1f8cfc69b09d2d9106d6ae82658d62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers an overlay instance as a child of this group.  <a href="classcgv_1_1app_1_1application__plugin__base.html#af1f8cfc69b09d2d9106d6ae82658d62b">More...</a><br /></td></tr>
<tr class="separator:af1f8cfc69b09d2d9106d6ae82658d62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af235f0a26a1d9dd7aac02e4cb0009dc4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1app_1_1application__plugin__base.html#af235f0a26a1d9dd7aac02e4cb0009dc4">handle</a> (<a class="el" href="classcgv_1_1gui_1_1event.html">cgv::gui::event</a> &amp;e) final</td></tr>
<tr class="memdesc:af235f0a26a1d9dd7aac02e4cb0009dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Final implementation of event_handler::handle() to support event handling of registered overlays.  <a href="classcgv_1_1app_1_1application__plugin__base.html#af235f0a26a1d9dd7aac02e4cb0009dc4">More...</a><br /></td></tr>
<tr class="separator:af235f0a26a1d9dd7aac02e4cb0009dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288d3d89d13f1133cd254c184c107c05"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1app_1_1application__plugin__base.html#a288d3d89d13f1133cd254c184c107c05">handle_event</a> (<a class="el" href="classcgv_1_1gui_1_1event.html">cgv::gui::event</a> &amp;e)=0</td></tr>
<tr class="memdesc:a288d3d89d13f1133cd254c184c107c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement this method to handle any events not blocked by an registered overlay.  <a href="classcgv_1_1app_1_1application__plugin__base.html#a288d3d89d13f1133cd254c184c107c05">More...</a><br /></td></tr>
<tr class="separator:a288d3d89d13f1133cd254c184c107c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a92d1c5e922f1b93d7ced5406ad3ed"><td class="memItemLeft" align="right" valign="top"><a id="ab2a92d1c5e922f1b93d7ced5406ad3ed"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1group.html#ab2a92d1c5e922f1b93d7ced5406ad3ed">get_nr_children</a> () const</td></tr>
<tr class="memdesc:ab2a92d1c5e922f1b93d7ced5406ad3ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the number of children <br /></td></tr>
<tr class="separator:ab2a92d1c5e922f1b93d7ced5406ad3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16a6b052779cddc52fcf90a8e211690"><td class="memItemLeft" align="right" valign="top"><a id="ad16a6b052779cddc52fcf90a8e211690"></a>
base_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1group.html#ad16a6b052779cddc52fcf90a8e211690">get_child</a> (unsigned int i) const</td></tr>
<tr class="memdesc:ad16a6b052779cddc52fcf90a8e211690"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the i-th child <br /></td></tr>
<tr class="separator:ad16a6b052779cddc52fcf90a8e211690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd58f5c3d894ec711d531ff32143ff98"><td class="memItemLeft" align="right" valign="top"><a id="afd58f5c3d894ec711d531ff32143ff98"></a>
virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1group.html#afd58f5c3d894ec711d531ff32143ff98">append_child</a> (base_ptr child)</td></tr>
<tr class="memdesc:afd58f5c3d894ec711d531ff32143ff98"><td class="mdescLeft">&#160;</td><td class="mdescRight">append child and return index of appended child <br /></td></tr>
<tr class="separator:afd58f5c3d894ec711d531ff32143ff98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c6ebb77df081306208d33383c32ec3"><td class="memItemLeft" align="right" valign="top"><a id="ae7c6ebb77df081306208d33383c32ec3"></a>
virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1group.html#ae7c6ebb77df081306208d33383c32ec3">remove_child</a> (base_ptr child)</td></tr>
<tr class="memdesc:ae7c6ebb77df081306208d33383c32ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove all elements of the vector that point to child, return the number of removed children <br /></td></tr>
<tr class="separator:ae7c6ebb77df081306208d33383c32ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0deb75eca28f6e4b58222208562cc4e"><td class="memItemLeft" align="right" valign="top"><a id="ab0deb75eca28f6e4b58222208562cc4e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1group.html#ab0deb75eca28f6e4b58222208562cc4e">remove_all_children</a> ()</td></tr>
<tr class="memdesc:ab0deb75eca28f6e4b58222208562cc4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove all children <br /></td></tr>
<tr class="separator:ab0deb75eca28f6e4b58222208562cc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786fa7b5056dfc6c092bbecf5713dd4e"><td class="memItemLeft" align="right" valign="top"><a id="a786fa7b5056dfc6c092bbecf5713dd4e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1group.html#a786fa7b5056dfc6c092bbecf5713dd4e">insert_child</a> (unsigned int i, base_ptr child)</td></tr>
<tr class="memdesc:a786fa7b5056dfc6c092bbecf5713dd4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert a child at the given position <br /></td></tr>
<tr class="separator:a786fa7b5056dfc6c092bbecf5713dd4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec823eac02e6e54794cdcc94e328b56"><td class="memItemLeft" align="right" valign="top"><a id="aaec823eac02e6e54794cdcc94e328b56"></a>
group_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1group.html#aaec823eac02e6e54794cdcc94e328b56">get_group</a> ()</td></tr>
<tr class="memdesc:aaec823eac02e6e54794cdcc94e328b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">cast upward to group <br /></td></tr>
<tr class="separator:aaec823eac02e6e54794cdcc94e328b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae340ce8bfe07e8967e3852fc53c49f80"><td class="memItemLeft" align="right" valign="top"><a id="ae340ce8bfe07e8967e3852fc53c49f80"></a>
const_group_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1group.html#ae340ce8bfe07e8967e3852fc53c49f80">get_group_const</a> ()</td></tr>
<tr class="memdesc:ae340ce8bfe07e8967e3852fc53c49f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">cast upward to const group <br /></td></tr>
<tr class="separator:ae340ce8bfe07e8967e3852fc53c49f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8229995c361dc313cecd1ca42ded82ae"><td class="memItemLeft" align="right" valign="top"><a id="a8229995c361dc313cecd1ca42ded82ae"></a>
virtual <a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; const <a class="el" href="classcgv_1_1base_1_1group.html#a03ff3b7324183b4ecf260f834d618d27">group</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a8229995c361dc313cecd1ca42ded82ae">get_group_const</a> () const</td></tr>
<tr class="memdesc:a8229995c361dc313cecd1ca42ded82ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">const cast upward to group <br /></td></tr>
<tr class="separator:a8229995c361dc313cecd1ca42ded82ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc7567d9b3cc7fe66d5d8ef01a2a773"><td class="memItemLeft" align="right" valign="top"><a id="abbc7567d9b3cc7fe66d5d8ef01a2a773"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1group.html#abbc7567d9b3cc7fe66d5d8ef01a2a773">get_type_name</a> () const</td></tr>
<tr class="memdesc:abbc7567d9b3cc7fe66d5d8ef01a2a773"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload to return the type name of this object <br /></td></tr>
<tr class="separator:abbc7567d9b3cc7fe66d5d8ef01a2a773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3053a69b9fefa20cc4c2b851d88bbaf6"><td class="memItemLeft" align="right" valign="top"><a id="a3053a69b9fefa20cc4c2b851d88bbaf6"></a>
node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1node.html#a3053a69b9fefa20cc4c2b851d88bbaf6">get_parent</a> () const</td></tr>
<tr class="memdesc:a3053a69b9fefa20cc4c2b851d88bbaf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the parent node <br /></td></tr>
<tr class="separator:a3053a69b9fefa20cc4c2b851d88bbaf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14d6331e7487f989f0fa0f8af5c5a85"><td class="memItemLeft" align="right" valign="top"><a id="ad14d6331e7487f989f0fa0f8af5c5a85"></a>
base_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1node.html#ad14d6331e7487f989f0fa0f8af5c5a85">get_root</a> () const</td></tr>
<tr class="memdesc:ad14d6331e7487f989f0fa0f8af5c5a85"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the root node by traversing parents until no more parent is available <br /></td></tr>
<tr class="separator:ad14d6331e7487f989f0fa0f8af5c5a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf1d20e3f26347e54c40d31c67d930f"><td class="memItemLeft" align="right" valign="top"><a id="aaaf1d20e3f26347e54c40d31c67d930f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1node.html#aaaf1d20e3f26347e54c40d31c67d930f">set_parent</a> (node_ptr _parent)</td></tr>
<tr class="memdesc:aaaf1d20e3f26347e54c40d31c67d930f"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a new parent node <br /></td></tr>
<tr class="separator:aaaf1d20e3f26347e54c40d31c67d930f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746bbe7e49b1fae8253a8b06ce9ad4c3"><td class="memItemLeft" align="right" valign="top"><a id="a746bbe7e49b1fae8253a8b06ce9ad4c3"></a>
node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1node.html#a746bbe7e49b1fae8253a8b06ce9ad4c3">get_node</a> ()</td></tr>
<tr class="memdesc:a746bbe7e49b1fae8253a8b06ce9ad4c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">cast upward to node <br /></td></tr>
<tr class="separator:a746bbe7e49b1fae8253a8b06ce9ad4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0651595bba92daa2271a015a408867"><td class="memItemLeft" align="right" valign="top"><a id="a8d0651595bba92daa2271a015a408867"></a>
const_node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1node.html#a8d0651595bba92daa2271a015a408867">get_node_const</a> ()</td></tr>
<tr class="memdesc:a8d0651595bba92daa2271a015a408867"><td class="mdescLeft">&#160;</td><td class="mdescRight">cast upward to const node <br /></td></tr>
<tr class="separator:a8d0651595bba92daa2271a015a408867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0c21c14a4322c3edcce6018ab1c608"><td class="memItemLeft" align="right" valign="top"><a id="a5c0c21c14a4322c3edcce6018ab1c608"></a>
virtual <a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; const <a class="el" href="classcgv_1_1base_1_1node.html#a62615bb328f6c0b6f8ff4a9730349fba">node</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a5c0c21c14a4322c3edcce6018ab1c608">get_node_const</a> () const</td></tr>
<tr class="memdesc:a5c0c21c14a4322c3edcce6018ab1c608"><td class="mdescLeft">&#160;</td><td class="mdescRight">const cast upward to node <br /></td></tr>
<tr class="separator:a5c0c21c14a4322c3edcce6018ab1c608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad647d5c457d7a25ad907b062fd9ca36a"><td class="memItemLeft" align="right" valign="top"><a id="ad647d5c457d7a25ad907b062fd9ca36a"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1named.html#ad647d5c457d7a25ad907b062fd9ca36a">get_name</a> () const</td></tr>
<tr class="memdesc:ad647d5c457d7a25ad907b062fd9ca36a"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the parent node <br /></td></tr>
<tr class="separator:ad647d5c457d7a25ad907b062fd9ca36a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32925eca40ca8deecd7b46fb129160cb"><td class="memItemLeft" align="right" valign="top"><a id="a32925eca40ca8deecd7b46fb129160cb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1named.html#a32925eca40ca8deecd7b46fb129160cb">set_name</a> (const std::string &amp;_name)</td></tr>
<tr class="memdesc:a32925eca40ca8deecd7b46fb129160cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a new parent node <br /></td></tr>
<tr class="separator:a32925eca40ca8deecd7b46fb129160cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917ac90c92381c683a18f10e2ea0a52e"><td class="memItemLeft" align="right" valign="top"><a id="a917ac90c92381c683a18f10e2ea0a52e"></a>
named_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1named.html#a917ac90c92381c683a18f10e2ea0a52e">get_named</a> ()</td></tr>
<tr class="memdesc:a917ac90c92381c683a18f10e2ea0a52e"><td class="mdescLeft">&#160;</td><td class="mdescRight">cast upward to named <br /></td></tr>
<tr class="separator:a917ac90c92381c683a18f10e2ea0a52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af186b91996e3428848e80e4f4e0d62cb"><td class="memItemLeft" align="right" valign="top"><a id="af186b91996e3428848e80e4f4e0d62cb"></a>
const_named_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1named.html#af186b91996e3428848e80e4f4e0d62cb">get_named_const</a> ()</td></tr>
<tr class="memdesc:af186b91996e3428848e80e4f4e0d62cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">cast upward to const named <br /></td></tr>
<tr class="separator:af186b91996e3428848e80e4f4e0d62cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0c5b45da256e0696602feaf69a5cf3"><td class="memItemLeft" align="right" valign="top"><a id="acb0c5b45da256e0696602feaf69a5cf3"></a>
virtual <a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; const <a class="el" href="classcgv_1_1base_1_1named.html#ac9100e358ab0bfaaa451bd1d34b8804f">named</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#acb0c5b45da256e0696602feaf69a5cf3">get_named_const</a> () const</td></tr>
<tr class="memdesc:acb0c5b45da256e0696602feaf69a5cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">const cast upward to named <br /></td></tr>
<tr class="separator:acb0c5b45da256e0696602feaf69a5cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a9ca57ee7e6364153cda52223b8501"><td class="memItemLeft" align="right" valign="top"><a id="a79a9ca57ee7e6364153cda52223b8501"></a>
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a79a9ca57ee7e6364153cda52223b8501">get_default_options</a> () const</td></tr>
<tr class="memdesc:a79a9ca57ee7e6364153cda52223b8501"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload to provide default options for registration <br /></td></tr>
<tr class="separator:a79a9ca57ee7e6364153cda52223b8501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec86a78e596c9c4fb203fcad98fb6afd"><td class="memItemLeft" align="right" valign="top"><a id="aec86a78e596c9c4fb203fcad98fb6afd"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#aec86a78e596c9c4fb203fcad98fb6afd">get_name_or_type_name</a> () const</td></tr>
<tr class="memdesc:aec86a78e596c9c4fb203fcad98fb6afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">determine name of instance by checking <a class="el" href="classcgv_1_1base_1_1named.html" title="base class for all gui types">cgv::base::named</a> interface and in failure fallback to <a class="el" href="classcgv_1_1base_1_1base.html#a6e64a898476591f7246e522652abfa4c" title="overload to return the type name of this object. By default the type interface is queried over get_ty...">get_type_name()</a> <br /></td></tr>
<tr class="separator:aec86a78e596c9c4fb203fcad98fb6afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f074aea5bf4b0bfeb00845750d27623"><td class="memItemLeft" align="right" valign="top"><a id="a2f074aea5bf4b0bfeb00845750d27623"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a2f074aea5bf4b0bfeb00845750d27623">on_register</a> ()</td></tr>
<tr class="memdesc:a2f074aea5bf4b0bfeb00845750d27623"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload to handle register events that is sent after the instance has been registered <br /></td></tr>
<tr class="separator:a2f074aea5bf4b0bfeb00845750d27623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3db0f57373229e66422eeeb6750ebc"><td class="memItemLeft" align="right" valign="top"><a id="a0b3db0f57373229e66422eeeb6750ebc"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a0b3db0f57373229e66422eeeb6750ebc">unregister</a> ()</td></tr>
<tr class="memdesc:a0b3db0f57373229e66422eeeb6750ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload to handle unregistration of instances <br /></td></tr>
<tr class="separator:a0b3db0f57373229e66422eeeb6750ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313232084b52192201cecaf4ae257ee8"><td class="memItemLeft" align="right" valign="top"><a id="a313232084b52192201cecaf4ae257ee8"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a313232084b52192201cecaf4ae257ee8">on_exit_request</a> ()</td></tr>
<tr class="memdesc:a313232084b52192201cecaf4ae257ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload to handle the appication exit request, return true if exiting is allowed and false otherwise <br /></td></tr>
<tr class="separator:a313232084b52192201cecaf4ae257ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95bafefa81ebfa3206014eb198e49459"><td class="memItemLeft" align="right" valign="top"><a id="a95bafefa81ebfa3206014eb198e49459"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a95bafefa81ebfa3206014eb198e49459">stream_stats</a> (std::ostream &amp;)</td></tr>
<tr class="memdesc:a95bafefa81ebfa3206014eb198e49459"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload to show the content of this object <br /></td></tr>
<tr class="separator:a95bafefa81ebfa3206014eb198e49459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6401d6fb8aa227bd28cacc7e42b39e2b"><td class="memTemplParams" colspan="2"><a id="a6401d6fb8aa227bd28cacc7e42b39e2b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6401d6fb8aa227bd28cacc7e42b39e2b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; T, true &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a6401d6fb8aa227bd28cacc7e42b39e2b">cast</a> ()</td></tr>
<tr class="memdesc:a6401d6fb8aa227bd28cacc7e42b39e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">cast to arbitrary class, but use the casts to named, node and group from the interface <br /></td></tr>
<tr class="separator:a6401d6fb8aa227bd28cacc7e42b39e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4ce80d45ccfdc5100f7ddd2f33b64d"><td class="memTemplParams" colspan="2"><a id="a5e4ce80d45ccfdc5100f7ddd2f33b64d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a5e4ce80d45ccfdc5100f7ddd2f33b64d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; const T, true &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a5e4ce80d45ccfdc5100f7ddd2f33b64d">cast_const</a> ()</td></tr>
<tr class="memdesc:a5e4ce80d45ccfdc5100f7ddd2f33b64d"><td class="mdescLeft">&#160;</td><td class="mdescRight">const cast to arbitrary class, but use the casts to named, node and group from the interface <br /></td></tr>
<tr class="separator:a5e4ce80d45ccfdc5100f7ddd2f33b64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b866151a23c63b3e8029849e71a796"><td class="memTemplParams" colspan="2"><a id="aa2b866151a23c63b3e8029849e71a796"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa2b866151a23c63b3e8029849e71a796"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#aa2b866151a23c63b3e8029849e71a796">get_interface</a> ()</td></tr>
<tr class="memdesc:aa2b866151a23c63b3e8029849e71a796"><td class="mdescLeft">&#160;</td><td class="mdescRight">use dynamic type cast to check for the given interface <br /></td></tr>
<tr class="separator:aa2b866151a23c63b3e8029849e71a796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322bdd4891db870dafaba22e40d99bff"><td class="memTemplParams" colspan="2"><a id="a322bdd4891db870dafaba22e40d99bff"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a322bdd4891db870dafaba22e40d99bff"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a322bdd4891db870dafaba22e40d99bff">get_const_interface</a> () const</td></tr>
<tr class="memdesc:a322bdd4891db870dafaba22e40d99bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">use dynamic type cast to check for the given interface <br /></td></tr>
<tr class="separator:a322bdd4891db870dafaba22e40d99bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1dd0ff6fa2baf3dc2149d3acfecd45"><td class="memItemLeft" align="right" valign="top"><a id="a3e1dd0ff6fa2baf3dc2149d3acfecd45"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a3e1dd0ff6fa2baf3dc2149d3acfecd45">update</a> ()</td></tr>
<tr class="memdesc:a3e1dd0ff6fa2baf3dc2149d3acfecd45"><td class="mdescLeft">&#160;</td><td class="mdescRight">this virtual update allows for example to ask a view to update the viewed value. The default implementation is empty. <br /></td></tr>
<tr class="separator:a3e1dd0ff6fa2baf3dc2149d3acfecd45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed62898813a55528e2b4c2c9e57cdf15"><td class="memItemLeft" align="right" valign="top"><a id="aed62898813a55528e2b4c2c9e57cdf15"></a>
virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#aed62898813a55528e2b4c2c9e57cdf15">get_user_data</a> () const</td></tr>
<tr class="memdesc:aed62898813a55528e2b4c2c9e57cdf15"><td class="mdescLeft">&#160;</td><td class="mdescRight">this virtual method allows to pass application specific data for internal purposes <br /></td></tr>
<tr class="separator:aed62898813a55528e2b4c2c9e57cdf15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b5dba890a068acef62d9c026c05320"><td class="memItemLeft" align="right" valign="top"><a id="a67b5dba890a068acef62d9c026c05320"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1data_1_1ref__counted.html#a67b5dba890a068acef62d9c026c05320">get_ref_count</a> () const</td></tr>
<tr class="memdesc:a67b5dba890a068acef62d9c026c05320"><td class="mdescLeft">&#160;</td><td class="mdescRight">read access to current count <br /></td></tr>
<tr class="separator:a67b5dba890a068acef62d9c026c05320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98ba277948d39c0e8870018e2f466ae"><td class="memItemLeft" align="right" valign="top"><a id="af98ba277948d39c0e8870018e2f466ae"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1event__handler.html#af98ba277948d39c0e8870018e2f466ae">grab_focus</a> ()</td></tr>
<tr class="memdesc:af98ba277948d39c0e8870018e2f466ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">grab the focus in all parent nodes <br /></td></tr>
<tr class="separator:af98ba277948d39c0e8870018e2f466ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247d57486e7c06516b2b028262b6dc35"><td class="memItemLeft" align="right" valign="top"><a id="a247d57486e7c06516b2b028262b6dc35"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1event__handler.html#a247d57486e7c06516b2b028262b6dc35">stream_help</a> (std::ostream &amp;os)=0</td></tr>
<tr class="memdesc:a247d57486e7c06516b2b028262b6dc35"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload to stream help information to the given output stream <br /></td></tr>
<tr class="separator:a247d57486e7c06516b2b028262b6dc35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dcd44ab999b271df3c9b6e1da9c21c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1event__handler.html#a3dcd44ab999b271df3c9b6e1da9c21c4">add_key_control</a> (const std::string &amp;property, const std::string &amp;options, <a class="el" href="namespacecgv_1_1base.html#ac2501796ba207ee4454afee3d0ad7921">cgv::base::group_ptr</a> <a class="el" href="classcgv_1_1base_1_1group.html#a03ff3b7324183b4ecf260f834d618d27">group</a>=<a class="el" href="namespacecgv_1_1base.html#ac2501796ba207ee4454afee3d0ad7921">cgv::base::group_ptr</a>())</td></tr>
<tr class="memdesc:a3dcd44ab999b271df3c9b6e1da9c21c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a key control for the given property with the given options.  <a href="classcgv_1_1gui_1_1event__handler.html#a3dcd44ab999b271df3c9b6e1da9c21c4">More...</a><br /></td></tr>
<tr class="separator:a3dcd44ab999b271df3c9b6e1da9c21c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a276706d356dd32a65dde6062b0250937"><td class="memItemLeft" align="right" valign="top"><a id="a276706d356dd32a65dde6062b0250937"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1traverse__policy.html#a276706d356dd32a65dde6062b0250937">get_policy</a> () const</td></tr>
<tr class="memdesc:a276706d356dd32a65dde6062b0250937"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the policy without the stop on success flag <br /></td></tr>
<tr class="separator:a276706d356dd32a65dde6062b0250937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac985e72d3583fa5eb114d991ab294cce"><td class="memItemLeft" align="right" valign="top"><a id="ac985e72d3583fa5eb114d991ab294cce"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1traverse__policy.html#ac985e72d3583fa5eb114d991ab294cce">stop_on_success</a> () const</td></tr>
<tr class="memdesc:ac985e72d3583fa5eb114d991ab294cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether to stop on success <br /></td></tr>
<tr class="separator:ac985e72d3583fa5eb114d991ab294cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4936bff3707dba734680c37e1822a1a8"><td class="memItemLeft" align="right" valign="top"><a id="a4936bff3707dba734680c37e1822a1a8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1traverse__policy.html#a4936bff3707dba734680c37e1822a1a8">stop_on_failure</a> () const</td></tr>
<tr class="memdesc:a4936bff3707dba734680c37e1822a1a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether to stop on failure <br /></td></tr>
<tr class="separator:a4936bff3707dba734680c37e1822a1a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d54d9fc7e025a09a6f9e7f8c30a69a"><td class="memItemLeft" align="right" valign="top"><a id="a28d54d9fc7e025a09a6f9e7f8c30a69a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1traverse__policy.html#a28d54d9fc7e025a09a6f9e7f8c30a69a">set_policy</a> (int _policy)</td></tr>
<tr class="memdesc:a28d54d9fc7e025a09a6f9e7f8c30a69a"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a new policy, always add stop on success flag if needed <br /></td></tr>
<tr class="separator:a28d54d9fc7e025a09a6f9e7f8c30a69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae075e6b19833e43e3d0908c8a1cfc69f"><td class="memItemLeft" align="right" valign="top"><a id="ae075e6b19833e43e3d0908c8a1cfc69f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1traverse__policy.html#ae075e6b19833e43e3d0908c8a1cfc69f">get_focused_child</a> () const</td></tr>
<tr class="memdesc:ae075e6b19833e43e3d0908c8a1cfc69f"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the focused child or -1 if none is focused <br /></td></tr>
<tr class="separator:ae075e6b19833e43e3d0908c8a1cfc69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a822bf58021ff2a41a6cad1411b3e9e"><td class="memItemLeft" align="right" valign="top"><a id="a4a822bf58021ff2a41a6cad1411b3e9e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1traverse__policy.html#a4a822bf58021ff2a41a6cad1411b3e9e">set_focused_child</a> (int _focused_child)</td></tr>
<tr class="memdesc:a4a822bf58021ff2a41a6cad1411b3e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the focused child <br /></td></tr>
<tr class="separator:a4a822bf58021ff2a41a6cad1411b3e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ebecf480e5437aa2891dee243aac0a7"><td class="memItemLeft" align="right" valign="top"><a id="a0ebecf480e5437aa2891dee243aac0a7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1traverse__policy.html#a0ebecf480e5437aa2891dee243aac0a7">get_active</a> () const</td></tr>
<tr class="memdesc:a0ebecf480e5437aa2891dee243aac0a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether the current node is active <br /></td></tr>
<tr class="separator:a0ebecf480e5437aa2891dee243aac0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ed08d30e2ca24ce81a565fa431bdac"><td class="memItemLeft" align="right" valign="top"><a id="a81ed08d30e2ca24ce81a565fa431bdac"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1traverse__policy.html#a81ed08d30e2ca24ce81a565fa431bdac">set_active</a> (bool _active)</td></tr>
<tr class="memdesc:a81ed08d30e2ca24ce81a565fa431bdac"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the active flag of the current node <br /></td></tr>
<tr class="separator:a81ed08d30e2ca24ce81a565fa431bdac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">property interface</div></td></tr>
<tr class="memitem:aa0fe4266b74ebe49de68faaab3ca7a7a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#aa0fe4266b74ebe49de68faaab3ca7a7a">self_reflect</a> (<a class="el" href="classcgv_1_1reflect_1_1reflection__handler.html">cgv::reflect::reflection_handler</a> &amp;)</td></tr>
<tr class="memdesc:aa0fe4266b74ebe49de68faaab3ca7a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">used for simple self reflection  <a href="classcgv_1_1base_1_1base.html#aa0fe4266b74ebe49de68faaab3ca7a7a">More...</a><br /></td></tr>
<tr class="separator:aa0fe4266b74ebe49de68faaab3ca7a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d67c8d339fe06f17396aaa8625292f8"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a4d67c8d339fe06f17396aaa8625292f8">get_property_declarations</a> ()</td></tr>
<tr class="memdesc:a4d67c8d339fe06f17396aaa8625292f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a semicolon separated list of property declarations  <a href="classcgv_1_1base_1_1base.html#a4d67c8d339fe06f17396aaa8625292f8">More...</a><br /></td></tr>
<tr class="separator:a4d67c8d339fe06f17396aaa8625292f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d3cd5ae49c3e261f5c0e52bc59bd4f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a62d3cd5ae49c3e261f5c0e52bc59bd4f">set_void</a> (const std::string &amp;property, const std::string &amp;value_type, const void *value_ptr)</td></tr>
<tr class="memdesc:a62d3cd5ae49c3e261f5c0e52bc59bd4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract interface for the setter of a dynamic property.  <a href="classcgv_1_1base_1_1base.html#a62d3cd5ae49c3e261f5c0e52bc59bd4f">More...</a><br /></td></tr>
<tr class="separator:a62d3cd5ae49c3e261f5c0e52bc59bd4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0cf2e6e9275472854996435e25fe17"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#aec0cf2e6e9275472854996435e25fe17">get_void</a> (const std::string &amp;property, const std::string &amp;value_type, void *value_ptr)</td></tr>
<tr class="memdesc:aec0cf2e6e9275472854996435e25fe17"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract interface for the getter of a dynamic property.  <a href="classcgv_1_1base_1_1base.html#aec0cf2e6e9275472854996435e25fe17">More...</a><br /></td></tr>
<tr class="separator:aec0cf2e6e9275472854996435e25fe17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6746cd9f70fefe5a4f2b72534869fcc3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a6746cd9f70fefe5a4f2b72534869fcc3">call_void</a> (const std::string &amp;method, const std::vector&lt; std::string &gt; &amp;param_value_types, const std::vector&lt; const void * &gt; &amp;param_value_ptrs, const std::string &amp;result_type=&quot;&quot;, void *result_value_ptr=0)</td></tr>
<tr class="memdesc:a6746cd9f70fefe5a4f2b72534869fcc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract interface to call an action  <a href="classcgv_1_1base_1_1base.html#a6746cd9f70fefe5a4f2b72534869fcc3">More...</a><br /></td></tr>
<tr class="separator:a6746cd9f70fefe5a4f2b72534869fcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff38549b7f5c57918898543e78a416d"><td class="memItemLeft" align="right" valign="top"><a id="a1ff38549b7f5c57918898543e78a416d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a1ff38549b7f5c57918898543e78a416d">set</a> (const std::string &amp;property, const char *value)</td></tr>
<tr class="memdesc:a1ff38549b7f5c57918898543e78a416d"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialization of set method to support const char* as strings <br /></td></tr>
<tr class="separator:a1ff38549b7f5c57918898543e78a416d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1b6b56455165d769b580d4006eba17"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abd1b6b56455165d769b580d4006eba17"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#abd1b6b56455165d769b580d4006eba17">set</a> (const std::string &amp;property, const T &amp;value)</td></tr>
<tr class="memdesc:abd1b6b56455165d769b580d4006eba17"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a property of the element to the given value and perform standard conversions if necessary.  <a href="classcgv_1_1base_1_1base.html#abd1b6b56455165d769b580d4006eba17">More...</a><br /></td></tr>
<tr class="separator:abd1b6b56455165d769b580d4006eba17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5978e45464c3fdd3083426c4b21ed28a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5978e45464c3fdd3083426c4b21ed28a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a5978e45464c3fdd3083426c4b21ed28a">get</a> (const std::string &amp;property)</td></tr>
<tr class="memdesc:a5978e45464c3fdd3083426c4b21ed28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">query a property of the element and perform standard conversions if necessary.  <a href="classcgv_1_1base_1_1base.html#a5978e45464c3fdd3083426c4b21ed28a">More...</a><br /></td></tr>
<tr class="separator:a5978e45464c3fdd3083426c4b21ed28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfaded48bb322a4b77350ca73c9e1a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#afbfaded48bb322a4b77350ca73c9e1a2">multi_set</a> (const std::string &amp;property_assignments, bool report_error=true)</td></tr>
<tr class="memdesc:afbfaded48bb322a4b77350ca73c9e1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">set several properties  <a href="classcgv_1_1base_1_1base.html#afbfaded48bb322a4b77350ca73c9e1a2">More...</a><br /></td></tr>
<tr class="separator:afbfaded48bb322a4b77350ca73c9e1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad796aa58a0b7d9c52d724a99366f58ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#ad796aa58a0b7d9c52d724a99366f58ae">is_property</a> (const std::string &amp;property_name, std::string *<a class="el" href="structcgv_1_1type_1_1info_1_1type__name.html">type_name</a>=0)</td></tr>
<tr class="memdesc:ad796aa58a0b7d9c52d724a99366f58ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if the given name specifies a property.  <a href="classcgv_1_1base_1_1base.html#ad796aa58a0b7d9c52d724a99366f58ae">More...</a><br /></td></tr>
<tr class="separator:ad796aa58a0b7d9c52d724a99366f58ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad121ecb072de62a4ab4a180bc9d183bb"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#ad121ecb072de62a4ab4a180bc9d183bb">find_member_ptr</a> (const std::string &amp;property_name, std::string *<a class="el" href="structcgv_1_1type_1_1info_1_1type__name.html">type_name</a>=0)</td></tr>
<tr class="memdesc:ad121ecb072de62a4ab4a180bc9d183bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">find a member pointer by name.  <a href="classcgv_1_1base_1_1base.html#ad121ecb072de62a4ab4a180bc9d183bb">More...</a><br /></td></tr>
<tr class="separator:ad121ecb072de62a4ab4a180bc9d183bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">update of gui</div></td></tr>
<tr class="memitem:aeebc6429f63628979eaf49422f43af28"><td class="memItemLeft" align="right" valign="top"><a id="aeebc6429f63628979eaf49422f43af28"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#aeebc6429f63628979eaf49422f43af28">remove_element</a> (base_ptr)</td></tr>
<tr class="memdesc:aeebc6429f63628979eaf49422f43af28"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove a single element from the gui <br /></td></tr>
<tr class="separator:aeebc6429f63628979eaf49422f43af28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e328fb6f5cf42f38194d0be355f4db1"><td class="memItemLeft" align="right" valign="top"><a id="a0e328fb6f5cf42f38194d0be355f4db1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a0e328fb6f5cf42f38194d0be355f4db1">remove_all_elements</a> ()</td></tr>
<tr class="memdesc:a0e328fb6f5cf42f38194d0be355f4db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">this method removes all elements from the gui and can be used in a method that rebuilds the complete gui <br /></td></tr>
<tr class="separator:a0e328fb6f5cf42f38194d0be355f4db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17089a0c7f9fa7f69088eef86fa7e15"><td class="memItemLeft" align="right" valign="top"><a id="ae17089a0c7f9fa7f69088eef86fa7e15"></a>
base_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#ae17089a0c7f9fa7f69088eef86fa7e15">find_element</a> (const std::string &amp;<a class="el" href="classcgv_1_1base_1_1named.html#aeacb85dab71b803971f8611644898371">name</a>)</td></tr>
<tr class="memdesc:ae17089a0c7f9fa7f69088eef86fa7e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">find a gui element by name in the current group, return empty pointer if not found <br /></td></tr>
<tr class="separator:ae17089a0c7f9fa7f69088eef86fa7e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4350ea3d268a289aff9a9b792d8eb7f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af4350ea3d268a289aff9a9b792d8eb7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; view&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#af4350ea3d268a289aff9a9b792d8eb7f">find_view</a> (const T &amp;value, int *idx_ptr=0)</td></tr>
<tr class="memdesc:af4350ea3d268a289aff9a9b792d8eb7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">find a view of a given class member  <a href="classcgv_1_1gui_1_1provider.html#af4350ea3d268a289aff9a9b792d8eb7f">More...</a><br /></td></tr>
<tr class="separator:af4350ea3d268a289aff9a9b792d8eb7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e752ce7a60f2e4e978a54125fa036e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac9e752ce7a60f2e4e978a54125fa036e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; control&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#ac9e752ce7a60f2e4e978a54125fa036e">find_control</a> (T &amp;value, int *idx_ptr=0)</td></tr>
<tr class="memdesc:ac9e752ce7a60f2e4e978a54125fa036e"><td class="mdescLeft">&#160;</td><td class="mdescRight">find a control of a given class member  <a href="classcgv_1_1gui_1_1provider.html#ac9e752ce7a60f2e4e978a54125fa036e">More...</a><br /></td></tr>
<tr class="separator:ac9e752ce7a60f2e4e978a54125fa036e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdacc36103adb320449d81fe939feabb"><td class="memItemLeft" align="right" valign="top"><a id="afdacc36103adb320449d81fe939feabb"></a>
control_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#afdacc36103adb320449d81fe939feabb">find_control_void</a> (void *value_ptr, int *idx_ptr)</td></tr>
<tr class="memdesc:afdacc36103adb320449d81fe939feabb"><td class="mdescLeft">&#160;</td><td class="mdescRight">access to control of untyped member pointer <br /></td></tr>
<tr class="separator:afdacc36103adb320449d81fe939feabb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a0e7b3023b00762456b7b8c5480328"><td class="memItemLeft" align="right" valign="top"><a id="a37a0e7b3023b00762456b7b8c5480328"></a>
<a class="el" href="classcgv_1_1app_1_1application__plugin__base.html#a8335fb38baab1499d22bede7d582a4ed">view_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a37a0e7b3023b00762456b7b8c5480328">find_view_void</a> (void *value_ptr, int *idx_ptr)</td></tr>
<tr class="memdesc:a37a0e7b3023b00762456b7b8c5480328"><td class="mdescLeft">&#160;</td><td class="mdescRight">access to view of untyped member pointer <br /></td></tr>
<tr class="separator:a37a0e7b3023b00762456b7b8c5480328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfa89eb56c3302073b170ff24325773"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9bfa89eb56c3302073b170ff24325773"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a9bfa89eb56c3302073b170ff24325773">set_control_property</a> (T &amp;value, const std::string &amp;property_name, const std::string &amp;property_value)</td></tr>
<tr class="memdesc:a9bfa89eb56c3302073b170ff24325773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the property value of all controls of a given class member.  <a href="classcgv_1_1gui_1_1provider.html#a9bfa89eb56c3302073b170ff24325773">More...</a><br /></td></tr>
<tr class="separator:a9bfa89eb56c3302073b170ff24325773"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae39d55bc26d5afbbe71f12dd89cc4b92"><td class="memItemLeft" align="right" valign="top"><a id="ae39d55bc26d5afbbe71f12dd89cc4b92"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1group.html#ae39d55bc26d5afbbe71f12dd89cc4b92">link</a> (base_ptr b)</td></tr>
<tr class="memdesc:ae39d55bc26d5afbbe71f12dd89cc4b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if the base class is a node and set the parent of the node <br /></td></tr>
<tr class="separator:ae39d55bc26d5afbbe71f12dd89cc4b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1fb4949807f1c86f816c31b2efb7ca2"><td class="memItemLeft" align="right" valign="top"><a id="ab1fb4949807f1c86f816c31b2efb7ca2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1group.html#ab1fb4949807f1c86f816c31b2efb7ca2">unlink</a> (base_ptr b)</td></tr>
<tr class="memdesc:ab1fb4949807f1c86f816c31b2efb7ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if the base class is a node and clear the parent of the node <br /></td></tr>
<tr class="separator:ab1fb4949807f1c86f816c31b2efb7ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abceffe95f08d3fc13cf9286cf360e705"><td class="memItemLeft" align="right" valign="top"><a id="abceffe95f08d3fc13cf9286cf360e705"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1data_1_1ref__counted.html#abceffe95f08d3fc13cf9286cf360e705">set_ref_count</a> (int c) const</td></tr>
<tr class="memdesc:abceffe95f08d3fc13cf9286cf360e705"><td class="mdescLeft">&#160;</td><td class="mdescRight">write access is also const to allow ref counted pointers to const instances <br /></td></tr>
<tr class="separator:abceffe95f08d3fc13cf9286cf360e705"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:ad8d0e6ffe70e6d8adc43876dfca2e84a"><td class="memTemplParams" colspan="2"><a id="ad8d0e6ffe70e6d8adc43876dfca2e84a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad8d0e6ffe70e6d8adc43876dfca2e84a"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; T, true &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#ad8d0e6ffe70e6d8adc43876dfca2e84a">cast_dynamic</a> (base *b)</td></tr>
<tr class="memdesc:ad8d0e6ffe70e6d8adc43876dfca2e84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">use dynamic cast for upcast to given class <br /></td></tr>
<tr class="separator:ad8d0e6ffe70e6d8adc43876dfca2e84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a8335fb38baab1499d22bede7d582a4ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1render_1_1view.html">cgv::render::view</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1app_1_1application__plugin__base.html#a8335fb38baab1499d22bede7d582a4ed">view_ptr</a></td></tr>
<tr class="memdesc:a8335fb38baab1499d22bede7d582a4ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a pointer to the base view.  <a href="classcgv_1_1app_1_1application__plugin__base.html#a8335fb38baab1499d22bede7d582a4ed">More...</a><br /></td></tr>
<tr class="separator:a8335fb38baab1499d22bede7d582a4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d94e00268c0abac8f96e94cfda30e4"><td class="memItemLeft" align="right" valign="top"><a id="a87d94e00268c0abac8f96e94cfda30e4"></a>
std::vector&lt; <a class="el" href="classcgv_1_1data_1_1ref__ptr.html">overlay_ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1app_1_1application__plugin__base.html#a87d94e00268c0abac8f96e94cfda30e4">overlays</a></td></tr>
<tr class="memdesc:a87d94e00268c0abac8f96e94cfda30e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a list of all overlays registered as children of this application plugin. <br /></td></tr>
<tr class="separator:a87d94e00268c0abac8f96e94cfda30e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c75cea2a1b35d2e540aea31bb7ba7b8"><td class="memItemLeft" align="right" valign="top"><a id="a5c75cea2a1b35d2e540aea31bb7ba7b8"></a>
<a class="el" href="classcgv_1_1data_1_1ref__ptr.html">overlay_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1app_1_1application__plugin__base.html#a5c75cea2a1b35d2e540aea31bb7ba7b8">last_blocking_overlay_ptr</a></td></tr>
<tr class="memdesc:a5c75cea2a1b35d2e540aea31bb7ba7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a pointer to the overlay that handled the previous event. <br /></td></tr>
<tr class="separator:a5c75cea2a1b35d2e540aea31bb7ba7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb98362e9f3561ddb3b8d72d26bc153a"><td class="memItemLeft" align="right" valign="top"><a id="abb98362e9f3561ddb3b8d72d26bc153a"></a>
<a class="el" href="classcgv_1_1data_1_1ref__ptr.html">overlay_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1app_1_1application__plugin__base.html#abb98362e9f3561ddb3b8d72d26bc153a">blocking_overlay_ptr</a></td></tr>
<tr class="memdesc:abb98362e9f3561ddb3b8d72d26bc153a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a pointer to the overlay that handles the current event. <br /></td></tr>
<tr class="separator:abb98362e9f3561ddb3b8d72d26bc153a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541b1eae8145dd8a173e99b16722f975"><td class="memItemLeft" align="right" valign="top"><a id="a541b1eae8145dd8a173e99b16722f975"></a>
std::vector&lt; base_ptr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1group.html#a541b1eae8145dd8a173e99b16722f975">children</a></td></tr>
<tr class="memdesc:a541b1eae8145dd8a173e99b16722f975"><td class="mdescLeft">&#160;</td><td class="mdescRight">store a list of children <br /></td></tr>
<tr class="separator:a541b1eae8145dd8a173e99b16722f975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28286049d6db60c75aedf4c6358dfc12"><td class="memItemLeft" align="right" valign="top"><a id="a28286049d6db60c75aedf4c6358dfc12"></a>
node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1node.html#a28286049d6db60c75aedf4c6358dfc12">parent</a></td></tr>
<tr class="memdesc:a28286049d6db60c75aedf4c6358dfc12"><td class="mdescLeft">&#160;</td><td class="mdescRight">store a pointer to the parent node <br /></td></tr>
<tr class="separator:a28286049d6db60c75aedf4c6358dfc12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeacb85dab71b803971f8611644898371"><td class="memItemLeft" align="right" valign="top"><a id="aeacb85dab71b803971f8611644898371"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1named.html#aeacb85dab71b803971f8611644898371">name</a></td></tr>
<tr class="memdesc:aeacb85dab71b803971f8611644898371"><td class="mdescLeft">&#160;</td><td class="mdescRight">store the name as a string <br /></td></tr>
<tr class="separator:aeacb85dab71b803971f8611644898371"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">interface used by the parent gui</h2></td></tr>
<tr class="memitem:a056110300cb3a821afbc5ae5f934a557"><td class="memItemLeft" align="right" valign="top"><a id="a056110300cb3a821afbc5ae5f934a557"></a>
gui_group_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a056110300cb3a821afbc5ae5f934a557">get_parent_group</a> () const</td></tr>
<tr class="memdesc:a056110300cb3a821afbc5ae5f934a557"><td class="mdescLeft">&#160;</td><td class="mdescRight">use the parent group to append to be managed elements that should be destroyed in a post_recreate_gui event <br /></td></tr>
<tr class="separator:a056110300cb3a821afbc5ae5f934a557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e631f03ab8c729b5a97ef9effc0df4"><td class="memItemLeft" align="right" valign="top"><a id="a56e631f03ab8c729b5a97ef9effc0df4"></a>
<a class="el" href="classcgv_1_1app_1_1application__plugin__base.html#a8335fb38baab1499d22bede7d582a4ed">view_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a56e631f03ab8c729b5a97ef9effc0df4">add_view_void</a> (const std::string &amp;label, const void *value_ptr, const std::string &amp;value_type, const std::string &amp;gui_type, const std::string &amp;options, const std::string &amp;<a class="el" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>)</td></tr>
<tr class="memdesc:a56e631f03ab8c729b5a97ef9effc0df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a newly created view to the group <br /></td></tr>
<tr class="separator:a56e631f03ab8c729b5a97ef9effc0df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaee067e53371e254a7e8a2ae6e0dd72"><td class="memItemLeft" align="right" valign="top"><a id="abaee067e53371e254a7e8a2ae6e0dd72"></a>
control_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#abaee067e53371e254a7e8a2ae6e0dd72">add_control_void</a> (const std::string &amp;label, void *value_ptr, abst_control_provider *acp, const std::string &amp;value_type, const std::string &amp;gui_type, const std::string &amp;options, const std::string &amp;<a class="el" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>, void *user_data)</td></tr>
<tr class="memdesc:abaee067e53371e254a7e8a2ae6e0dd72"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a newly created control to the group <br /></td></tr>
<tr class="separator:abaee067e53371e254a7e8a2ae6e0dd72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afffb2e23a58a488448a175e6275c9e7b"><td class="memItemLeft" align="right" valign="top"><a id="afffb2e23a58a488448a175e6275c9e7b"></a>
gui_group_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#afffb2e23a58a488448a175e6275c9e7b">parent_group</a></td></tr>
<tr class="memdesc:afffb2e23a58a488448a175e6275c9e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">driver specific handle for the group gui element managing the gui built in the provider <br /></td></tr>
<tr class="separator:afffb2e23a58a488448a175e6275c9e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab51c3efb4addaae6f9ab79e6f5d2f641"><td class="memItemLeft" align="right" valign="top"><a id="ab51c3efb4addaae6f9ab79e6f5d2f641"></a>
<a class="el" href="classcgv_1_1gui_1_1provider.html#a6807d6d7fff24fd1d895cf67fd3e1331">provider</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>parent_provider</b></td></tr>
<tr class="separator:ab51c3efb4addaae6f9ab79e6f5d2f641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f6cb9fa8994a14fdb5bf70cba90093"><td class="memItemLeft" align="right" valign="top"><a id="aa6f6cb9fa8994a14fdb5bf70cba90093"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#aa6f6cb9fa8994a14fdb5bf70cba90093">set_parent</a> (gui_group_ptr)</td></tr>
<tr class="memdesc:aa6f6cb9fa8994a14fdb5bf70cba90093"><td class="mdescLeft">&#160;</td><td class="mdescRight">the gui window sets the parent group through this method <br /></td></tr>
<tr class="separator:aa6f6cb9fa8994a14fdb5bf70cba90093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845b81cb3d12858b7b70a2b00105c72f"><td class="memItemLeft" align="right" valign="top"><a id="a845b81cb3d12858b7b70a2b00105c72f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a845b81cb3d12858b7b70a2b00105c72f">update_parent</a> ()</td></tr>
<tr class="memdesc:a845b81cb3d12858b7b70a2b00105c72f"><td class="mdescLeft">&#160;</td><td class="mdescRight">update the parent group <br /></td></tr>
<tr class="separator:a845b81cb3d12858b7b70a2b00105c72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">creation of gui</h2></td></tr>
<tr class="memitem:a28af4e659bdd1825f3829263e15ce5ae"><td class="memItemLeft" align="right" valign="top"><a id="a28af4e659bdd1825f3829263e15ce5ae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a> (const std::string &amp;_align)</td></tr>
<tr class="memdesc:a28af4e659bdd1825f3829263e15ce5ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">send pure alignment information <br /></td></tr>
<tr class="separator:a28af4e659bdd1825f3829263e15ce5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90fe8e7ea3ff452a8148cc779111512a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a90fe8e7ea3ff452a8148cc779111512a">concat_enum_def</a> (const std::vector&lt; std::string &gt; &amp;names, const std::string &amp;additional_first_name=&quot;&quot;, const std::string &amp;additional_last_name=&quot;&quot;)</td></tr>
<tr class="memdesc:a90fe8e7ea3ff452a8148cc779111512a"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a new group to the given parent group, not supported yet  <a href="classcgv_1_1gui_1_1provider.html#a90fe8e7ea3ff452a8148cc779111512a">More...</a><br /></td></tr>
<tr class="separator:a90fe8e7ea3ff452a8148cc779111512a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f82aa4b9a568ca39bff1c1fa2fc637a"><td class="memItemLeft" align="right" valign="top"><a id="a4f82aa4b9a568ca39bff1c1fa2fc637a"></a>
gui_group_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>add_object_gui</b> (base_ptr object, const std::string &amp;label, const std::string &amp;group_type, const std::string &amp;options, const std::string &amp;<a class="el" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>)</td></tr>
<tr class="separator:a4f82aa4b9a568ca39bff1c1fa2fc637a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3302fad2cb441f3c26c2979c2c064b51"><td class="memItemLeft" align="right" valign="top"><a id="a3302fad2cb441f3c26c2979c2c064b51"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a3302fad2cb441f3c26c2979c2c064b51">integrate_object_gui</a> (base_ptr object)</td></tr>
<tr class="memdesc:a3302fad2cb441f3c26c2979c2c064b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">call this in <a class="el" href="classcgv_1_1gui_1_1provider.html#a1d2f0b6c734c04d3c90a1c51ffbc0de9" title="you must overload this for gui creation">create_gui()</a> function to integrate gui of another provider object by setting the parent group and parent provider of the other object <br /></td></tr>
<tr class="separator:a3302fad2cb441f3c26c2979c2c064b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d293603edad6ffd9a84303f67d6060a"><td class="memItemLeft" align="right" valign="top"><a id="a6d293603edad6ffd9a84303f67d6060a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a6d293603edad6ffd9a84303f67d6060a">inline_object_gui</a> (base_ptr object)</td></tr>
<tr class="memdesc:a6d293603edad6ffd9a84303f67d6060a"><td class="mdescLeft">&#160;</td><td class="mdescRight">integrate (if not explicitly done before) and inline the gui of another object that must be derived from provider <br /></td></tr>
<tr class="separator:a6d293603edad6ffd9a84303f67d6060a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79595103df6c363aba76db5ce49312ce"><td class="memItemLeft" align="right" valign="top"><a id="a79595103df6c363aba76db5ce49312ce"></a>
gui_group_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a79595103df6c363aba76db5ce49312ce">add_group</a> (const std::string &amp;label, const std::string &amp;group_type, const std::string &amp;options=&quot;&quot;, const std::string &amp;<a class="el" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>=&quot;\n&quot;)</td></tr>
<tr class="memdesc:a79595103df6c363aba76db5ce49312ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a newly created subgroup to the group <br /></td></tr>
<tr class="separator:a79595103df6c363aba76db5ce49312ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f624e9a95eb0b58dff0ac2a10fb6ed9"><td class="memItemLeft" align="right" valign="top"><a id="a5f624e9a95eb0b58dff0ac2a10fb6ed9"></a>
base_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a5f624e9a95eb0b58dff0ac2a10fb6ed9">add_decorator</a> (const std::string &amp;label, const std::string &amp;decorator_type, const std::string &amp;options=&quot;&quot;, const std::string &amp;<a class="el" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>=&quot;\n&quot;)</td></tr>
<tr class="memdesc:a5f624e9a95eb0b58dff0ac2a10fb6ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a newly created decorator to the group <br /></td></tr>
<tr class="separator:a5f624e9a95eb0b58dff0ac2a10fb6ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4c2c18d5da07d5dadfececde56e48e"><td class="memItemLeft" align="right" valign="top"><a id="aec4c2c18d5da07d5dadfececde56e48e"></a>
button_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#aec4c2c18d5da07d5dadfececde56e48e">add_button</a> (const std::string &amp;label, const std::string &amp;options=&quot;&quot;, const std::string &amp;<a class="el" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>=&quot;\n&quot;)</td></tr>
<tr class="memdesc:aec4c2c18d5da07d5dadfececde56e48e"><td class="mdescLeft">&#160;</td><td class="mdescRight">use the current gui driver to append a new button with the given label <br /></td></tr>
<tr class="separator:aec4c2c18d5da07d5dadfececde56e48e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131206860106d3d07078508006151b7e"><td class="memTemplParams" colspan="2"><a id="a131206860106d3d07078508006151b7e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a131206860106d3d07078508006151b7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; view&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a131206860106d3d07078508006151b7e">add_view</a> (const std::string &amp;label, const T &amp;value, const std::string &amp;gui_type=&quot;&quot;, const std::string &amp;options=&quot;&quot;, const std::string &amp;<a class="el" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>=&quot;\n&quot;)</td></tr>
<tr class="memdesc:a131206860106d3d07078508006151b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">use this to add a new view to the gui with a given value type, gui type and init options <br /></td></tr>
<tr class="separator:a131206860106d3d07078508006151b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5d812a9dc6b4132b67d0077cc6e22f"><td class="memTemplParams" colspan="2"><a id="ace5d812a9dc6b4132b67d0077cc6e22f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ace5d812a9dc6b4132b67d0077cc6e22f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; control&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#ace5d812a9dc6b4132b67d0077cc6e22f">add_control</a> (const std::string &amp;label, T &amp;value, const std::string &amp;gui_type=&quot;&quot;, const std::string &amp;options=&quot;&quot;, const std::string &amp;<a class="el" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>=&quot;\n&quot;)</td></tr>
<tr class="memdesc:ace5d812a9dc6b4132b67d0077cc6e22f"><td class="mdescLeft">&#160;</td><td class="mdescRight">use this to add a new control to the gui with a given value type, gui type and init options <br /></td></tr>
<tr class="separator:ace5d812a9dc6b4132b67d0077cc6e22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accde83e8bacb794c0c912334c5a743e4"><td class="memTemplParams" colspan="2"><a id="accde83e8bacb794c0c912334c5a743e4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:accde83e8bacb794c0c912334c5a743e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; control&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#accde83e8bacb794c0c912334c5a743e4">add_control</a> (const std::string &amp;label, control_provider&lt; T &gt; *<a class="el" href="classcgv_1_1gui_1_1provider.html#a6807d6d7fff24fd1d895cf67fd3e1331">provider</a>, const std::string &amp;gui_type=&quot;&quot;, const std::string &amp;options=&quot;&quot;, const std::string &amp;<a class="el" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>=&quot;\n&quot;, void *user_data=0)</td></tr>
<tr class="memdesc:accde83e8bacb794c0c912334c5a743e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">use this to add a new control to the gui, where the control is implemented with a control provider class <br /></td></tr>
<tr class="separator:accde83e8bacb794c0c912334c5a743e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b62a00070bd3dcdb8962da4f1921b0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af1b62a00070bd3dcdb8962da4f1921b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; control&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#af1b62a00070bd3dcdb8962da4f1921b0">add_member_control</a> (<a class="el" href="classcgv_1_1base_1_1base.html">cgv::base::base</a> *base_ptr, const std::string &amp;label, T &amp;value, const std::string &amp;gui_type=&quot;&quot;, const std::string &amp;options=&quot;&quot;, const std::string &amp;<a class="el" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>=&quot;\n&quot;)</td></tr>
<tr class="memdesc:af1b62a00070bd3dcdb8962da4f1921b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">add control with callback to cgv::base::on_set method on <a class="el" href="classcgv_1_1gui_1_1control.html#a49af8e128fc1e8443b95adbddfed009a" title="this signal is sent after the user triggered a change of value and the check_value succeeded.">cgv::gui::control::value_change</a>  <a href="classcgv_1_1gui_1_1provider.html#af1b62a00070bd3dcdb8962da4f1921b0">More...</a><br /></td></tr>
<tr class="separator:af1b62a00070bd3dcdb8962da4f1921b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d52460406852908aeaceb573cbd00e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a71d52460406852908aeaceb573cbd00e">add_tree_node</a> (const std::string &amp;label, bool &amp;toggle, int level, const std::string &amp;a=&quot;\n&quot;, gui_group_ptr ggp=gui_group_ptr())</td></tr>
<tr class="memdesc:a71d52460406852908aeaceb573cbd00e"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a collapsable node to the gui (deprecated)  <a href="classcgv_1_1gui_1_1provider.html#a71d52460406852908aeaceb573cbd00e">More...</a><br /></td></tr>
<tr class="separator:a71d52460406852908aeaceb573cbd00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ba041ea08c3e6e3a93e76995f706aa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a62ba041ea08c3e6e3a93e76995f706aa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a62ba041ea08c3e6e3a93e76995f706aa">begin_tree_node</a> (const std::string &amp;label, const T &amp;value, bool initial_visibility=false, const std::string &amp;options=&quot;&quot;, gui_group_ptr ggp=gui_group_ptr())</td></tr>
<tr class="memdesc:a62ba041ea08c3e6e3a93e76995f706aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin a sub tree of a tree structured gui.  <a href="classcgv_1_1gui_1_1provider.html#a62ba041ea08c3e6e3a93e76995f706aa">More...</a><br /></td></tr>
<tr class="separator:a62ba041ea08c3e6e3a93e76995f706aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bac0aa7c0467b606a3cbe9311f3d17c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9bac0aa7c0467b606a3cbe9311f3d17c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a9bac0aa7c0467b606a3cbe9311f3d17c">end_tree_node</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a9bac0aa7c0467b606a3cbe9311f3d17c"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialization that allows to specify value reference plus node_instance by using the result of the function with_instance(value,idx) for the value argument finish a sub tree begun with begin_tree_node <br  />
  <a href="classcgv_1_1gui_1_1provider.html#a9bac0aa7c0467b606a3cbe9311f3d17c">More...</a><br /></td></tr>
<tr class="separator:a9bac0aa7c0467b606a3cbe9311f3d17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb085cf7522a281e61dd30041654c8c"><td class="memTemplParams" colspan="2"><a id="aadb085cf7522a281e61dd30041654c8c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aadb085cf7522a281e61dd30041654c8c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#aadb085cf7522a281e61dd30041654c8c">is_tree_node_visible</a> (const T &amp;value) const</td></tr>
<tr class="memdesc:aadb085cf7522a281e61dd30041654c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether the sub tree attached to a value is visible <br /></td></tr>
<tr class="separator:aadb085cf7522a281e61dd30041654c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb70e048faeac605a62847f681c201b"><td class="memTemplParams" colspan="2"><a id="a3bb70e048faeac605a62847f681c201b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3bb70e048faeac605a62847f681c201b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a3bb70e048faeac605a62847f681c201b">set_tree_node_visibility</a> (const T &amp;value, bool is_visible)</td></tr>
<tr class="memdesc:a3bb70e048faeac605a62847f681c201b"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the visibility status of sub tree attached to a value. This calls the post_recreate method if needed. <br /></td></tr>
<tr class="separator:a3bb70e048faeac605a62847f681c201b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a782d2dc8ba7aab891b7139bc8f5be"><td class="memItemLeft" align="right" valign="top"><a id="a21a782d2dc8ba7aab891b7139bc8f5be"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a21a782d2dc8ba7aab891b7139bc8f5be">begin_tree_node_void</a> (const std::string &amp;label, const void *value_ptr, int index=-1, bool initial_visibility=false, const std::string &amp;options=&quot;&quot;, gui_group_ptr ggp=gui_group_ptr())</td></tr>
<tr class="memdesc:a21a782d2dc8ba7aab891b7139bc8f5be"><td class="mdescLeft">&#160;</td><td class="mdescRight">void version of the templated functions <br /></td></tr>
<tr class="separator:a21a782d2dc8ba7aab891b7139bc8f5be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b8490e597634729bb37cb370483de7d"><td class="memItemLeft" align="right" valign="top"><a id="a7b8490e597634729bb37cb370483de7d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>end_tree_node_void</b> (const void *value_ptr, int index=-1)</td></tr>
<tr class="separator:a7b8490e597634729bb37cb370483de7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4ae3f1f4b0582371447cceb86d286e"><td class="memItemLeft" align="right" valign="top"><a id="a6c4ae3f1f4b0582371447cceb86d286e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_tree_node_visible_void</b> (const void *value_ptr, int index) const</td></tr>
<tr class="separator:a6c4ae3f1f4b0582371447cceb86d286e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f634cc86cdcb2a65aa1921bd461a1fe"><td class="memItemLeft" align="right" valign="top"><a id="a8f634cc86cdcb2a65aa1921bd461a1fe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_tree_node_visibility_void</b> (const void *value_ptr, int index, bool is_visible)</td></tr>
<tr class="separator:a8f634cc86cdcb2a65aa1921bd461a1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05025e09df1d16f40678661b83c79bc8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a05025e09df1d16f40678661b83c79bc8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a05025e09df1d16f40678661b83c79bc8">add_gui</a> (const std::string &amp;label, T &amp;value, const std::string &amp;gui_type=&quot;&quot;, const std::string &amp;options=&quot;&quot;)</td></tr>
<tr class="memdesc:a05025e09df1d16f40678661b83c79bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a composed gui of the given gui_type for the given value.  <a href="classcgv_1_1gui_1_1provider.html#a05025e09df1d16f40678661b83c79bc8">More...</a><br /></td></tr>
<tr class="separator:a05025e09df1d16f40678661b83c79bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e722ce8fd3bd48387d8ee5761498189"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9e722ce8fd3bd48387d8ee5761498189"><td class="memTemplItemLeft" align="right" valign="top">static bool &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a9e722ce8fd3bd48387d8ee5761498189">ref_tree_node_visible_flag</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a9e722ce8fd3bd48387d8ee5761498189"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a reference to the boolean flag, that tells whether the tree node for the passed value is visible  <a href="classcgv_1_1gui_1_1provider.html#a9e722ce8fd3bd48387d8ee5761498189">More...</a><br /></td></tr>
<tr class="separator:a9e722ce8fd3bd48387d8ee5761498189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001e91968dadb3c01162f00bfb101edc"><td class="memItemLeft" align="right" valign="top"><a id="a001e91968dadb3c01162f00bfb101edc"></a>
static bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>ref_tree_node_visible_flag_void</b> (const void *value_ptr, int index=-1)</td></tr>
<tr class="separator:a001e91968dadb3c01162f00bfb101edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">callbacks</h2></td></tr>
<tr class="memitem:abd40cd68e7f4339a603af99ebbf40108"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#abd40cd68e7f4339a603af99ebbf40108">get_gui_name</a> () const</td></tr>
<tr class="memdesc:abd40cd68e7f4339a603af99ebbf40108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derive a name for this instance that can be used in the gui as heading.  <a href="classcgv_1_1gui_1_1provider.html#abd40cd68e7f4339a603af99ebbf40108">More...</a><br /></td></tr>
<tr class="separator:abd40cd68e7f4339a603af99ebbf40108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f68d3402bf77c9705f1fd010a4f6390"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a9f68d3402bf77c9705f1fd010a4f6390">get_parent_type</a> () const</td></tr>
<tr class="memdesc:a9f68d3402bf77c9705f1fd010a4f6390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the group type that should be used by the class embedding the gui of the provider.  <a href="classcgv_1_1gui_1_1provider.html#a9f68d3402bf77c9705f1fd010a4f6390">More...</a><br /></td></tr>
<tr class="separator:a9f68d3402bf77c9705f1fd010a4f6390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6abf8d523c9ac4d79b54ceba5edd3727"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a6abf8d523c9ac4d79b54ceba5edd3727">ensure_selected_in_tab_group_parent</a> ()</td></tr>
<tr class="memdesc:a6abf8d523c9ac4d79b54ceba5edd3727"><td class="mdescLeft">&#160;</td><td class="mdescRight">ensure that my UI is selected in the parent group in case this is a tab group, otherwise return false  <a href="classcgv_1_1gui_1_1provider.html#a6abf8d523c9ac4d79b54ceba5edd3727">More...</a><br /></td></tr>
<tr class="separator:a6abf8d523c9ac4d79b54ceba5edd3727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841e8ef471bf376be1c3fa97179cd218"><td class="memItemLeft" align="right" valign="top"><a id="a841e8ef471bf376be1c3fa97179cd218"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a841e8ef471bf376be1c3fa97179cd218">update_member</a> (void *member_ptr)</td></tr>
<tr class="memdesc:a841e8ef471bf376be1c3fa97179cd218"><td class="mdescLeft">&#160;</td><td class="mdescRight">call this to update all views and controls of a member <br /></td></tr>
<tr class="separator:a841e8ef471bf376be1c3fa97179cd218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f205b0f9fb19663ded86d329a88678"><td class="memItemLeft" align="right" valign="top"><a id="a54f205b0f9fb19663ded86d329a88678"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a54f205b0f9fb19663ded86d329a88678">update_all_members</a> ()</td></tr>
<tr class="memdesc:a54f205b0f9fb19663ded86d329a88678"><td class="mdescLeft">&#160;</td><td class="mdescRight">call this to update all views and controls of all member <br /></td></tr>
<tr class="separator:a54f205b0f9fb19663ded86d329a88678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f386dcbc43a7409fd2f3f655c938e5d"><td class="memItemLeft" align="right" valign="top"><a id="a1f386dcbc43a7409fd2f3f655c938e5d"></a>
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a1f386dcbc43a7409fd2f3f655c938e5d">get_menu_path</a> () const</td></tr>
<tr class="memdesc:a1f386dcbc43a7409fd2f3f655c938e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a path in the main menu to select the gui <br /></td></tr>
<tr class="separator:a1f386dcbc43a7409fd2f3f655c938e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad662c36ff5c1e73c79a938c4adbab952"><td class="memItemLeft" align="right" valign="top"><a id="ad662c36ff5c1e73c79a938c4adbab952"></a>
virtual shortcut&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#ad662c36ff5c1e73c79a938c4adbab952">get_shortcut</a> () const</td></tr>
<tr class="memdesc:ad662c36ff5c1e73c79a938c4adbab952"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a shortcut to activate the gui without menu navigation <br /></td></tr>
<tr class="separator:ad662c36ff5c1e73c79a938c4adbab952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2f0b6c734c04d3c90a1c51ffbc0de9"><td class="memItemLeft" align="right" valign="top"><a id="a1d2f0b6c734c04d3c90a1c51ffbc0de9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#a1d2f0b6c734c04d3c90a1c51ffbc0de9">create_gui</a> ()=0</td></tr>
<tr class="memdesc:a1d2f0b6c734c04d3c90a1c51ffbc0de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">you must overload this for gui creation <br /></td></tr>
<tr class="separator:a1d2f0b6c734c04d3c90a1c51ffbc0de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71df33b57067886a8c264ed9eb672f5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#ab71df33b57067886a8c264ed9eb672f5">recreate_gui</a> ()</td></tr>
<tr class="memdesc:ab71df33b57067886a8c264ed9eb672f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recreate the gui of this instance right now.  <a href="classcgv_1_1gui_1_1provider.html#ab71df33b57067886a8c264ed9eb672f5">More...</a><br /></td></tr>
<tr class="separator:ab71df33b57067886a8c264ed9eb672f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91a5b7508ca2f8a995a7101a80cab76"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#aa91a5b7508ca2f8a995a7101a80cab76">post_recreate_gui</a> ()</td></tr>
<tr class="memdesc:aa91a5b7508ca2f8a995a7101a80cab76"><td class="mdescLeft">&#160;</td><td class="mdescRight">delayed recreation of gui  <a href="classcgv_1_1gui_1_1provider.html#aa91a5b7508ca2f8a995a7101a80cab76">More...</a><br /></td></tr>
<tr class="separator:aa91a5b7508ca2f8a995a7101a80cab76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21e975a89b32dcbbe9bdb39b4f452ca"><td class="memItemLeft" align="right" valign="top"><a id="ac21e975a89b32dcbbe9bdb39b4f452ca"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#ac21e975a89b32dcbbe9bdb39b4f452ca">on_select</a> ()</td></tr>
<tr class="memdesc:ac21e975a89b32dcbbe9bdb39b4f452ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">called by selection_change_cb whenever the gui of this provider is selected <br /></td></tr>
<tr class="separator:ac21e975a89b32dcbbe9bdb39b4f452ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d49da0a9a5f434b920c33d42139621"><td class="memItemLeft" align="right" valign="top"><a id="ac6d49da0a9a5f434b920c33d42139621"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#ac6d49da0a9a5f434b920c33d42139621">on_deselect</a> ()</td></tr>
<tr class="memdesc:ac6d49da0a9a5f434b920c33d42139621"><td class="mdescLeft">&#160;</td><td class="mdescRight">called by selection_change_cb whenever the gui of this provider is deselected <br /></td></tr>
<tr class="separator:ac6d49da0a9a5f434b920c33d42139621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30ecc2b9412b158cbe774babaacd402"><td class="memItemLeft" align="right" valign="top"><a id="af30ecc2b9412b158cbe774babaacd402"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1gui_1_1provider.html#af30ecc2b9412b158cbe774babaacd402">selection_change_cb</a> (<a class="el" href="namespacecgv_1_1base.html#a580333ed27888f5e8c61452a44545f51">cgv::base::base_ptr</a> new_child, bool selected)</td></tr>
<tr class="memdesc:af30ecc2b9412b158cbe774babaacd402"><td class="mdescLeft">&#160;</td><td class="mdescRight">this is called by the gui group when the selection changes <br /></td></tr>
<tr class="separator:af30ecc2b9412b158cbe774babaacd402"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class base_drawable&gt;<br />
class cgv::app::generic_application_plugin&lt; base_drawable &gt;</h3>

<p>Extension of <a class="el" href="classcgv_1_1app_1_1application__plugin__base.html" title="Abstract base class for application plugins that provides capability to handle overlays,...">application_plugin_base</a> that allows to define a used drawable base class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">base_drawable</td><td>the used drawable type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="application__plugin_8h_source.html#l00097">97</a> of file <a class="el" href="application__plugin_8h_source.html">application_plugin.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad852de85129a7c6590fb879948b84c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad852de85129a7c6590fb879948b84c85">&#9670;&nbsp;</a></span>generic_application_plugin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class base_drawable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcgv_1_1app_1_1generic__application__plugin.html">cgv::app::generic_application_plugin</a>&lt; base_drawable &gt;::<a class="el" href="classcgv_1_1app_1_1generic__application__plugin.html">generic_application_plugin</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an instance of the class as a group node with the given name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of this node. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="application__plugin_8h_source.html#l00102">102</a> of file <a class="el" href="application__plugin_8h_source.html">application_plugin.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a05025e09df1d16f40678661b83c79bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05025e09df1d16f40678661b83c79bc8">&#9670;&nbsp;</a></span>add_gui()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::gui::provider::add_gui </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>gui_type</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a composed gui of the given gui_type for the given value. </p>
<p>This function returns false if no cgv::base::gui_creator has been registered for the given gui_type. The plugin cg_ext contains registers gui_creators for the most important types of the framework. The supported values for the options parameter are specific for the gui_type. Currently these are not documented and can only be found in the source code of the cg_ext plugin. </p>

<p class="definition">Definition at line <a class="el" href="provider_8h_source.html#l00247">247</a> of file <a class="el" href="provider_8h_source.html">provider.h</a>.</p>

<p class="reference">References <a class="el" href="gui__creator_8cxx_source.html#l00021">cgv::gui::create_gui()</a>.</p>

<p class="reference">Referenced by <a class="el" href="plot__base_8cxx_source.html#l01453">cgv::plot::plot_base::create_base_config_gui()</a>, <a class="el" href="plot3d_8cxx_source.html#l00582">cgv::plot::plot3d::create_gui()</a>, and <a class="el" href="plot__base_8cxx_source.html#l01254">cgv::plot::plot_base::create_plot_gui()</a>.</p>

</div>
</div>
<a id="a3dcd44ab999b271df3c9b6e1da9c21c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dcd44ab999b271df3c9b6e1da9c21c4">&#9670;&nbsp;</a></span>add_key_control()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::gui::event_handler::add_key_control </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecgv_1_1base.html#ac2501796ba207ee4454afee3d0ad7921">cgv::base::group_ptr</a>&#160;</td>
          <td class="paramname"><em>group</em> = <code><a class="el" href="namespacecgv_1_1base.html#ac2501796ba207ee4454afee3d0ad7921">cgv::base::group_ptr</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add a key control for the given property with the given options. </p>
<p>grab the focus in all parent nodes</p>
<p>This should be called in classes derived from <a class="el" href="classcgv_1_1base_1_1group.html" title="The group class is a node with children.">cgv::base::group</a> and event_handler. The group argument should be the this pointer cast to cgv::base_group. If group is not given, a dynamic_cast is performed on the this pointer. </p>

<p class="definition">Definition at line <a class="el" href="event__handler_8cxx_source.html#l00022">22</a> of file <a class="el" href="event__handler_8cxx_source.html">event_handler.cxx</a>.</p>

<p class="reference">References <a class="el" href="group_8cxx_source.html#l00036">cgv::base::group::append_child()</a>, <a class="el" href="ref__ptr_8h_source.html#l00230">cgv::data::ref_ptr&lt; T, is_ref_counted &gt;::empty()</a>, <a class="el" href="base_8cxx_source.html#l00360">cgv::base::base::find_member_ptr()</a>, and <a class="el" href="base_8cxx_source.html#l00210">cgv::base::base::on_set()</a>.</p>

</div>
</div>
<a id="af1b62a00070bd3dcdb8962da4f1921b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b62a00070bd3dcdb8962da4f1921b0">&#9670;&nbsp;</a></span>add_member_control()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt;control&lt;T&gt; &gt; cgv::gui::provider::add_member_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcgv_1_1base_1_1base.html">cgv::base::base</a> *&#160;</td>
          <td class="paramname"><em>base_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>gui_type</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>align</em> = <code>&quot;\n&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add control with callback to cgv::base::on_set method on <a class="el" href="classcgv_1_1gui_1_1control.html#a49af8e128fc1e8443b95adbddfed009a" title="this signal is sent after the user triggered a change of value and the check_value succeeded.">cgv::gui::control::value_change</a> </p>
<p>use this method to add a control of a member and a callback to the on_set method of the <a class="el" href="classcgv_1_1base_1_1base.html" title="base class for all classes that can be registered with support for dynamic properties (see also secti...">cgv::base::base</a> class. </p>

<p class="definition">Definition at line <a class="el" href="provider_8h_source.html#l00137">137</a> of file <a class="el" href="provider_8h_source.html">provider.h</a>.</p>

<p class="reference">References <a class="el" href="base_8cxx_source.html#l00210">cgv::base::base::on_set()</a>.</p>

<p class="reference">Referenced by <a class="el" href="plot__base_8cxx_source.html#l01525">cgv::plot::plot_base::create_bar_config_gui()</a>, <a class="el" href="plot__base_8cxx_source.html#l01453">cgv::plot::plot_base::create_base_config_gui()</a>, <a class="el" href="plot3d_8cxx_source.html#l00565">cgv::plot::plot3d::create_config_gui()</a>, <a class="el" href="plot__base_8cxx_source.html#l01535">cgv::plot::plot_base::create_config_gui()</a>, <a class="el" href="axis__config_8cxx_source.html#l00208">cgv::plot::axis_config::create_gui()</a>, <a class="el" href="plot2d_8cxx_source.html#l00671">cgv::plot::plot2d::create_gui()</a>, <a class="el" href="plot__base_8cxx_source.html#l01578">cgv::plot::plot_base::create_gui()</a>, <a class="el" href="plot3d_8cxx_source.html#l00552">cgv::plot::plot3d::create_line_config_gui()</a>, <a class="el" href="plot__base_8cxx_source.html#l01254">cgv::plot::plot_base::create_plot_gui()</a>, and <a class="el" href="plot__base_8cxx_source.html#l01517">cgv::plot::plot_base::create_stick_config_gui()</a>.</p>

</div>
</div>
<a id="a71d52460406852908aeaceb573cbd00e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71d52460406852908aeaceb573cbd00e">&#9670;&nbsp;</a></span>add_tree_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::gui::provider::add_tree_node </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>toggle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a</em> = <code>&quot;\n&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecgv_1_1gui.html#a24b531058de9d4333ab8541c302587d7">gui_group_ptr</a>&#160;</td>
          <td class="paramname"><em>ggp</em> = <code><a class="el" href="namespacecgv_1_1gui.html#a24b531058de9d4333ab8541c302587d7">gui_group_ptr</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add a collapsable node to the gui (deprecated) </p>
<p>This method is one possibility to support tree like guis with nodes that can be opened or closed. The other prefarable possibitly builds on the functions <a class="el" href="classcgv_1_1gui_1_1provider.html#a62ba041ea08c3e6e3a93e76995f706aa" title="Begin a sub tree of a tree structured gui.">begin_tree_node()</a> and <a class="el" href="classcgv_1_1gui_1_1provider.html#a9bac0aa7c0467b606a3cbe9311f3d17c" title="template specialization that allows to specify value reference plus node_instance by using the result...">end_tree_node()</a>.</p>
<p>Each node is represented by a heading with the text provided in the first parameter and of heading level specified in the first parameter. The state of the node is stored in a boolean variable "toggle" that must be supplied by the implementation of the provider. The toggle needs to be initialized in the constructor and is used in the create_gui method to only provide the gui of the subtree if toggle is true. Every time the status of the node is changed, the whole gui is rebuild with the post_recreate_gui method. The value of the toggle is also the return parameter of add_tree_node such the typical code inside the create_gui method looks like </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="classcgv_1_1gui_1_1provider.html#a71d52460406852908aeaceb573cbd00e">add_tree_node</a>(<span class="stringliteral">&quot;Node&quot;</span>, toggle, 2)) {</div>
<div class="line">   <a class="code" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>(<span class="stringliteral">&quot;\a&quot;</span>); <span class="comment">// indent gui elements of tree node</span></div>
<div class="line">   <span class="comment">// create gui of subtree</span></div>
<div class="line">   </div>
<div class="line">   <a class="code" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>(<span class="stringliteral">&quot;\b&quot;</span>); <span class="comment">// undo indentation</span></div>
<div class="line">}</div>
<div class="ttc" id="aclasscgv_1_1gui_1_1provider_html_a28af4e659bdd1825f3829263e15ce5ae"><div class="ttname"><a href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">cgv::gui::provider::align</a></div><div class="ttdeci">void align(const std::string &amp;_align)</div><div class="ttdoc">send pure alignment information</div><div class="ttdef"><b>Definition:</b> <a href="provider_8cxx_source.html#l00036">provider.cxx:36</a></div></div>
<div class="ttc" id="aclasscgv_1_1gui_1_1provider_html_a71d52460406852908aeaceb573cbd00e"><div class="ttname"><a href="classcgv_1_1gui_1_1provider.html#a71d52460406852908aeaceb573cbd00e">cgv::gui::provider::add_tree_node</a></div><div class="ttdeci">bool add_tree_node(const std::string &amp;label, bool &amp;toggle, int level, const std::string &amp;a=&quot;\n&quot;, gui_group_ptr ggp=gui_group_ptr())</div><div class="ttdoc">add a collapsable node to the gui (deprecated)</div><div class="ttdef"><b>Definition:</b> <a href="provider_8cxx_source.html#l00183">provider.cxx:183</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="provider_8cxx_source.html#l00183">183</a> of file <a class="el" href="provider_8cxx_source.html">provider.cxx</a>.</p>

<p class="reference">References <a class="el" href="provider_8h_source.html#l00069">cgv::gui::provider::parent_group</a>, <a class="el" href="provider_8cxx_source.html#l00509">cgv::gui::provider::post_recreate_gui()</a>, and <a class="el" href="convert__string_8cxx_source.html#l00007">cgv::utils::to_string()</a>.</p>

</div>
</div>
<a id="a62ba041ea08c3e6e3a93e76995f706aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ba041ea08c3e6e3a93e76995f706aa">&#9670;&nbsp;</a></span>begin_tree_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::gui::provider::begin_tree_node </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>initial_visibility</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecgv_1_1gui.html#a24b531058de9d4333ab8541c302587d7">gui_group_ptr</a>&#160;</td>
          <td class="paramname"><em>ggp</em> = <code><a class="el" href="namespacecgv_1_1gui.html#a24b531058de9d4333ab8541c302587d7">gui_group_ptr</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begin a sub tree of a tree structured gui. </p>
<p>This function addes a toggle button and a heading for the tree node. The toggle button can be used to show or hide the subtree below the tree node. The heading shows simply the label parameter. The function returns the visibility state of the subtree below the tree node. Therefore its contents should only be specified if the function returns true. In that case one needs to terminate the gui elements added for the tree node with the end_tree_node function. A typical example would be </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="classcgv_1_1gui_1_1provider.html#a62ba041ea08c3e6e3a93e76995f706aa">begin_tree_node</a>(<span class="stringliteral">&quot;Node&quot;</span>, composed_value)) {</div>
<div class="line">   <a class="code" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>(<span class="stringliteral">&quot;\a&quot;</span>); <span class="comment">// indent gui elements of tree node</span></div>
<div class="line">   <span class="comment">// create gui of composed_value</span></div>
<div class="line">   </div>
<div class="line">   <a class="code" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>(<span class="stringliteral">&quot;\b&quot;</span>); <span class="comment">// undo indentation</span></div>
<div class="line">   <a class="code" href="classcgv_1_1gui_1_1provider.html#a9bac0aa7c0467b606a3cbe9311f3d17c">end_tree_node</a>(composed_value);</div>
<div class="line">}</div>
<div class="ttc" id="aclasscgv_1_1gui_1_1provider_html_a62ba041ea08c3e6e3a93e76995f706aa"><div class="ttname"><a href="classcgv_1_1gui_1_1provider.html#a62ba041ea08c3e6e3a93e76995f706aa">cgv::gui::provider::begin_tree_node</a></div><div class="ttdeci">bool begin_tree_node(const std::string &amp;label, const T &amp;value, bool initial_visibility=false, const std::string &amp;options=&quot;&quot;, gui_group_ptr ggp=gui_group_ptr())</div><div class="ttdoc">Begin a sub tree of a tree structured gui.</div><div class="ttdef"><b>Definition:</b> <a href="provider_8h_source.html#l00212">provider.h:212</a></div></div>
<div class="ttc" id="aclasscgv_1_1gui_1_1provider_html_a9bac0aa7c0467b606a3cbe9311f3d17c"><div class="ttname"><a href="classcgv_1_1gui_1_1provider.html#a9bac0aa7c0467b606a3cbe9311f3d17c">cgv::gui::provider::end_tree_node</a></div><div class="ttdeci">void end_tree_node(const T &amp;value)</div><div class="ttdoc">template specialization that allows to specify value reference plus node_instance by using the result...</div><div class="ttdef"><b>Definition:</b> <a href="provider_8h_source.html#l00222">provider.h:222</a></div></div>
</div><!-- fragment --><p> The state of the toggle button is attached to a boolean flag that is globally managed by the provider. If your this pointer can be converted to <a class="el" href="classcgv_1_1base_1_1base.html" title="base class for all classes that can be registered with support for dynamic properties (see also secti...">cgv::base::base</a>, the on_set callback with a pointer to the flag is called when the user toggles the tree node. To check in the on_set callback for the tree node toggle one can get a reference to the boolean flag with the ref_tree_node_visible_flag method.</p>
<p>To allocate the boolean flag the reference to a value controlled by the tree node is specified. The pointer to the controlled value is used as key for a map that manages the toggle states of all tree node buttons. If there is no superior structure whose value is controlled by the tree node, one can specify any of the values controled by the tree node. It is just important that no two tree nodes use the same value and that the pointer to the value cannot change. The latter is for example the case, when one uses an entry in a std::vector that can change size and reallocate its values. Then one should use the std::vector itself as value. In order to be able to distinguish the different elements of a vector one can extend the key from a value reference to a pair of a value reference plus an index. The index is then the index of the vector element. This is done by specifying with_index(value, idx) in the value argument. An example could look as follows: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="classcgv_1_1gui_1_1provider.html#a62ba041ea08c3e6e3a93e76995f706aa">begin_tree_node</a>(<span class="stringliteral">&quot;Node&quot;</span>, vec)) {</div>
<div class="line">   <a class="code" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>(<span class="stringliteral">&quot;\a&quot;</span>); <span class="comment">// indent gui elements of tree node</span></div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;vec.size; ++i) {</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="classcgv_1_1gui_1_1provider.html#a62ba041ea08c3e6e3a93e76995f706aa">begin_tree_node</a>(std::string(<span class="stringliteral">&quot;element &quot;</span>)+<a class="code" href="namespacecgv_1_1utils.html#a9584ae56050ff7dd2b881c2b60efd55b">cgv::utils::to_string</a>(i), <a class="code" href="namespacecgv_1_1gui.html#aa887b469731f8956d0eaefd8801fc4a3">with_index</a>(vec,i))) {</div>
<div class="line">           <a class="code" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>(<span class="stringliteral">&quot;\a&quot;</span>); <span class="comment">// indent gui elements of tree node for vector element</span></div>
<div class="line">           <span class="comment">// create gui of vector element</span></div>
<div class="line">   </div>
<div class="line">           <a class="code" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>(<span class="stringliteral">&quot;\b&quot;</span>); <span class="comment">// undo indentation</span></div>
<div class="line">           <a class="code" href="classcgv_1_1gui_1_1provider.html#a9bac0aa7c0467b606a3cbe9311f3d17c">end_tree_node</a>(<a class="code" href="namespacecgv_1_1gui.html#aa887b469731f8956d0eaefd8801fc4a3">with_index</a>(vec,i));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <a class="code" href="classcgv_1_1gui_1_1provider.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>(<span class="stringliteral">&quot;\b&quot;</span>); <span class="comment">// undo indentation</span></div>
<div class="line">    <a class="code" href="classcgv_1_1gui_1_1provider.html#a9bac0aa7c0467b606a3cbe9311f3d17c">end_tree_node</a>(vec);</div>
<div class="line">}</div>
<div class="ttc" id="anamespacecgv_1_1gui_html_aa887b469731f8956d0eaefd8801fc4a3"><div class="ttname"><a href="namespacecgv_1_1gui.html#aa887b469731f8956d0eaefd8801fc4a3">cgv::gui::with_index</a></div><div class="ttdeci">with_index_struct&lt; T &gt; with_index(const T &amp;_value, int _index)</div><div class="ttdoc">helper function to support value references as well as value references with index for the tree_node ...</div><div class="ttdef"><b>Definition:</b> <a href="provider_8h_source.html#l00028">provider.h:28</a></div></div>
<div class="ttc" id="anamespacecgv_1_1utils_html_a9584ae56050ff7dd2b881c2b60efd55b"><div class="ttname"><a href="namespacecgv_1_1utils.html#a9584ae56050ff7dd2b881c2b60efd55b">cgv::utils::to_string</a></div><div class="ttdeci">std::string to_string(const std::string &amp;v, unsigned int w, unsigned int p)</div><div class="ttdoc">specialization of conversion from string to strings</div><div class="ttdef"><b>Definition:</b> <a href="convert__string_8cxx_source.html#l00007">convert_string.cxx:7</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="provider_8h_source.html#l00212">212</a> of file <a class="el" href="provider_8h_source.html">provider.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="plot3d_8cxx_source.html#l00565">cgv::plot::plot3d::create_config_gui()</a>, <a class="el" href="plot__base_8cxx_source.html#l01535">cgv::plot::plot_base::create_config_gui()</a>, <a class="el" href="axis__config_8cxx_source.html#l00208">cgv::plot::axis_config::create_gui()</a>, <a class="el" href="plot2d_8cxx_source.html#l00671">cgv::plot::plot2d::create_gui()</a>, <a class="el" href="plot3d_8cxx_source.html#l00582">cgv::plot::plot3d::create_gui()</a>, <a class="el" href="plot__base_8cxx_source.html#l01578">cgv::plot::plot_base::create_gui()</a>, and <a class="el" href="plot__base_8cxx_source.html#l01254">cgv::plot::plot_base::create_plot_gui()</a>.</p>

</div>
</div>
<a id="a6746cd9f70fefe5a4f2b72534869fcc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6746cd9f70fefe5a4f2b72534869fcc3">&#9670;&nbsp;</a></span>call_void()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::base::base::call_void </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>param_value_types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>param_value_ptrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>result_type</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>result_value_ptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>abstract interface to call an action </p>
<p>overload to implement the execution of a method based on the method name and the given parameters</p>
<p>, i.e. a class method based on the action name and the given parameters. The default implementation uses the <a class="el" href="classcgv_1_1base_1_1base.html#aa0fe4266b74ebe49de68faaab3ca7a7a" title="used for simple self reflection">self_reflect()</a> method to dispatch this call. If not found, the get_void method returns false. </p>

<p class="definition">Definition at line <a class="el" href="base_8cxx_source.html#l00168">168</a> of file <a class="el" href="base_8cxx_source.html">base.cxx</a>.</p>

</div>
</div>
<a id="a90fe8e7ea3ff452a8148cc779111512a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90fe8e7ea3ff452a8148cc779111512a">&#9670;&nbsp;</a></span>concat_enum_def()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string cgv::gui::provider::concat_enum_def </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>additional_first_name</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>additional_last_name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add a new group to the given parent group, not supported yet </p>
<p>concatenate names in string to enum declaration and optionally prepend or append given additional names</p>
<p>Add group with the gui of another object inside.</p>
<p>Add a new group, where the group elements are defined by another object that must be derived from provider. You can use the same group types as in the add_group method. concatenate names in string to enum declaration and optionally prepend or append given additional names </p>

<p class="definition">Definition at line <a class="el" href="provider_8cxx_source.html#l00043">43</a> of file <a class="el" href="provider_8cxx_source.html">provider.cxx</a>.</p>

</div>
</div>
<a id="a9bac0aa7c0467b606a3cbe9311f3d17c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bac0aa7c0467b606a3cbe9311f3d17c">&#9670;&nbsp;</a></span>end_tree_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cgv::gui::provider::end_tree_node </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>template specialization that allows to specify value reference plus node_instance by using the result of the function with_instance(value,idx) for the value argument finish a sub tree begun with begin_tree_node <br  />
 </p>
<p>This functions should be called only if the corresponding call to begin_tree_node returned true. </p>

<p class="definition">Definition at line <a class="el" href="provider_8h_source.html#l00222">222</a> of file <a class="el" href="provider_8h_source.html">provider.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="plot3d_8cxx_source.html#l00565">cgv::plot::plot3d::create_config_gui()</a>, <a class="el" href="plot__base_8cxx_source.html#l01535">cgv::plot::plot_base::create_config_gui()</a>, <a class="el" href="axis__config_8cxx_source.html#l00208">cgv::plot::axis_config::create_gui()</a>, <a class="el" href="plot2d_8cxx_source.html#l00671">cgv::plot::plot2d::create_gui()</a>, <a class="el" href="plot3d_8cxx_source.html#l00582">cgv::plot::plot3d::create_gui()</a>, <a class="el" href="plot__base_8cxx_source.html#l01578">cgv::plot::plot_base::create_gui()</a>, and <a class="el" href="plot__base_8cxx_source.html#l01254">cgv::plot::plot_base::create_plot_gui()</a>.</p>

</div>
</div>
<a id="a6abf8d523c9ac4d79b54ceba5edd3727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6abf8d523c9ac4d79b54ceba5edd3727">&#9670;&nbsp;</a></span>ensure_selected_in_tab_group_parent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::gui::provider::ensure_selected_in_tab_group_parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ensure that my UI is selected in the parent group in case this is a tab group, otherwise return false </p>
<p>ensure that my UI is selected in the closest parent that is a tab group </p>

<p class="definition">Definition at line <a class="el" href="provider_8cxx_source.html#l00407">407</a> of file <a class="el" href="provider_8cxx_source.html">provider.cxx</a>.</p>

<p class="reference">References <a class="el" href="provider_8h_source.html#l00081">cgv::gui::provider::get_parent_group()</a>.</p>

</div>
</div>
<a id="ac9e752ce7a60f2e4e978a54125fa036e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e752ce7a60f2e4e978a54125fa036e">&#9670;&nbsp;</a></span>find_control()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt;control&lt;T&gt; &gt; cgv::gui::provider::find_control </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>idx_ptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find a control of a given class member </p>
<p>find the next control of the given value in the current group. If the index pointer is given, start at the index to which the pointer points and set this index to the index of the child index of the found control </p>

<p class="definition">Definition at line <a class="el" href="provider_8h_source.html#l00330">330</a> of file <a class="el" href="provider_8h_source.html">provider.h</a>.</p>

<p class="reference">References <a class="el" href="ref__ptr_8h_source.html#l00230">cgv::data::ref_ptr&lt; T, is_ref_counted &gt;::empty()</a>.</p>

<p class="reference">Referenced by <a class="el" href="plot__base_8cxx_source.html#l01254">cgv::plot::plot_base::create_plot_gui()</a>.</p>

</div>
</div>
<a id="ad121ecb072de62a4ab4a180bc9d183bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad121ecb072de62a4ab4a180bc9d183bb">&#9670;&nbsp;</a></span>find_member_ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * cgv::base::base::find_member_ptr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>property_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>type_name</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find a member pointer by name. </p>
<p>If not found the null pointer is returned. If the type name string pointer is provided, the type of the property is copied to the referenced string. </p>

<p class="definition">Definition at line <a class="el" href="base_8cxx_source.html#l00360">360</a> of file <a class="el" href="base_8cxx_source.html">base.cxx</a>.</p>

<p class="reference">References <a class="el" href="find__reflection__handler_8cxx_source.html#l00047">cgv::reflect::find_reflection_handler::found_target()</a>, <a class="el" href="find__reflection__handler_8cxx_source.html#l00059">cgv::reflect::find_reflection_handler::get_member_ptr()</a>, <a class="el" href="find__reflection__handler_8cxx_source.html#l00072">cgv::reflect::find_reflection_handler::get_reflection_traits()</a>, and <a class="el" href="structcgv_1_1reflect_1_1abst__reflection__traits.html#aa00b01c2252909e01eb154c6170df6d2">cgv::reflect::abst_reflection_traits::get_type_name()</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__handler_8cxx_source.html#l00022">cgv::gui::event_handler::add_key_control()</a>.</p>

</div>
</div>
<a id="af4350ea3d268a289aff9a9b792d8eb7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4350ea3d268a289aff9a9b792d8eb7f">&#9670;&nbsp;</a></span>find_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt;view&lt;T&gt; &gt; cgv::gui::provider::find_view </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>idx_ptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find a view of a given class member </p>
<p>find the next view of the given value in the current group. If the index pointer is given, start at the index to which the pointer points and set this index to the index of the child index of the found view </p>

<p class="definition">Definition at line <a class="el" href="provider_8h_source.html#l00320">320</a> of file <a class="el" href="provider_8h_source.html">provider.h</a>.</p>

<p class="reference">References <a class="el" href="ref__ptr_8h_source.html#l00230">cgv::data::ref_ptr&lt; T, is_ref_counted &gt;::empty()</a>.</p>

</div>
</div>
<a id="a5978e45464c3fdd3083426c4b21ed28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5978e45464c3fdd3083426c4b21ed28a">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T cgv::base::base::get </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>property</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>query a property of the element and perform standard conversions if necessary. </p>
<p>This templated version simply extracts the type of the value from the reference and calls the <a class="el" href="classcgv_1_1base_1_1base.html#a62d3cd5ae49c3e261f5c0e52bc59bd4f" title="abstract interface for the setter of a dynamic property.">set_void()</a> method. Note that this only works if the template cgv::type::info::type_name&lt;T&gt; is overloaded for the value type. </p>

<p class="definition">Definition at line <a class="el" href="base_8h_source.html#l00192">192</a> of file <a class="el" href="base_8h_source.html">base.h</a>.</p>

</div>
</div>
<a id="abd40cd68e7f4339a603af99ebbf40108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd40cd68e7f4339a603af99ebbf40108">&#9670;&nbsp;</a></span>get_gui_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string cgv::gui::provider::get_gui_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derive a name for this instance that can be used in the gui as heading. </p>
<p>this method uses the following strategy to automatically determine the name shown in guis for a provider instance:</p>
<p>This method uses the following strategy to automatically determine the name shown in guis for a provider instance:</p><ul>
<li>try to cast the object into <a class="el" href="classcgv_1_1base_1_1named.html" title="base class for all gui types">cgv::base::named</a>, if successful, use <a class="el" href="classcgv_1_1base_1_1named.html#ad647d5c457d7a25ad907b062fd9ca36a" title="return the parent node">get_name()</a> method</li>
<li>check whether <a class="el" href="classcgv_1_1gui_1_1provider.html#a1f386dcbc43a7409fd2f3f655c938e5d" title="return a path in the main menu to select the gui">get_menu_path()</a> results in a path or name. In case of a path, use the last entry of the path as name.</li>
<li>try to cast to <a class="el" href="classcgv_1_1base_1_1base.html" title="base class for all classes that can be registered with support for dynamic properties (see also secti...">cgv::base::base</a> and use <a class="el" href="classcgv_1_1base_1_1group.html#abbc7567d9b3cc7fe66d5d8ef01a2a773" title="overload to return the type name of this object">get_type_name()</a>.</li>
<li>return "unnamed" otherwise</li>
<li>try to cast the object into <a class="el" href="classcgv_1_1base_1_1named.html" title="base class for all gui types">cgv::base::named</a>, if successful, use <a class="el" href="classcgv_1_1base_1_1named.html#ad647d5c457d7a25ad907b062fd9ca36a" title="return the parent node">get_name()</a> method</li>
<li>check whether <a class="el" href="classcgv_1_1gui_1_1provider.html#a1f386dcbc43a7409fd2f3f655c938e5d" title="return a path in the main menu to select the gui">get_menu_path()</a> results in a path or name. In case of a path, use the last entry of the path as name.</li>
<li>try to cast to <a class="el" href="classcgv_1_1base_1_1base.html" title="base class for all classes that can be registered with support for dynamic properties (see also secti...">cgv::base::base</a> and use <a class="el" href="classcgv_1_1base_1_1group.html#abbc7567d9b3cc7fe66d5d8ef01a2a773" title="overload to return the type name of this object">get_type_name()</a>.</li>
<li>return "unnamed" otherwise </li>
</ul>

<p class="definition">Definition at line <a class="el" href="provider_8cxx_source.html#l00383">383</a> of file <a class="el" href="provider_8cxx_source.html">provider.cxx</a>.</p>

<p class="reference">References <a class="el" href="provider_8cxx_source.html#l00424">cgv::gui::provider::get_menu_path()</a>, <a class="el" href="base_8cxx_source.html#l00037">cgv::base::base::get_named()</a>, and <a class="el" href="base_8cxx_source.html#l00241">cgv::base::base::get_type_name()</a>.</p>

<p class="reference">Referenced by <a class="el" href="provider_8cxx_source.html#l00015">cgv::gui::provider::update_parent()</a>.</p>

</div>
</div>
<a id="a9f68d3402bf77c9705f1fd010a4f6390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f68d3402bf77c9705f1fd010a4f6390">&#9670;&nbsp;</a></span>get_parent_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string cgv::gui::provider::get_parent_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the group type that should be used by the class embedding the gui of the provider. </p>
<p>The default is to use a group of type "align_group". Overload this virtual method to use a different group type, such as layout group. </p>

<p class="definition">Definition at line <a class="el" href="provider_8cxx_source.html#l00402">402</a> of file <a class="el" href="provider_8cxx_source.html">provider.cxx</a>.</p>

</div>
</div>
<a id="a4d67c8d339fe06f17396aaa8625292f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d67c8d339fe06f17396aaa8625292f8">&#9670;&nbsp;</a></span>get_property_declarations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string cgv::base::base::get_property_declarations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a semicolon separated list of property declarations </p>
<p>return a semicolon separated list of property declarations of the form "name:type", by default an empty list is returned</p>
<p>of the form "name1:type1;name2:type2;...", by default an empty list is returned. The types should by consistent with the names returned by <a class="el" href="structcgv_1_1type_1_1info_1_1type__name.html#a7dcb7c43dbf01bd9276508eb7e2295aa" title="return special name for standard types or type name from RTTI cleaned from keywords for all other typ...">cgv::type::info::type_name::get_name</a>. The default implementation extracts names and types from the <a class="el" href="classcgv_1_1base_1_1base.html#aa0fe4266b74ebe49de68faaab3ca7a7a" title="used for simple self reflection">self_reflect()</a> method and the meta type information provided by the get_type() method. </p>

<p>Reimplemented in <a class="el" href="classcgv_1_1media_1_1video_1_1video__writer.html#a70c7d0a47fedc21d9da8ae58a8e582b2">cgv::media::video::video_writer</a>, <a class="el" href="classcgv_1_1media_1_1video_1_1video__reader.html#aa79161bb56539ef00192c01887e91026">cgv::media::video::video_reader</a>, <a class="el" href="classcgv_1_1media_1_1image_1_1image__writer.html#a477ec6f721fcae426557c6f6584cf134">cgv::media::image::image_writer</a>, <a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#ae6cd9178f2412fcc7e3068cf76cb1611">cgv::media::image::image_reader</a>, <a class="el" href="structcgv_1_1base_1_1factory.html#a614db734b9dab12958b6c0370addfb6f">cgv::base::factory</a>, <a class="el" href="classcgv_1_1base_1_1console.html#a662798821c197e8886aff79e8ffa3d40">cgv::base::console</a>, and <a class="el" href="classcgv_1_1base_1_1base__generator.html#a398375938ddac0a608e2fcaa96240623">cgv::base::base_generator</a>.</p>

<p class="definition">Definition at line <a class="el" href="base_8cxx_source.html#l00264">264</a> of file <a class="el" href="base_8cxx_source.html">base.cxx</a>.</p>

<p class="reference">Referenced by <a class="el" href="image__reader_8cxx_source.html#l00310">cgv::media::image::image_reader::get_property_declarations()</a>, <a class="el" href="image__writer_8cxx_source.html#l00161">cgv::media::image::image_writer::get_property_declarations()</a>, <a class="el" href="video__reader_8cxx_source.html#l00176">cgv::media::video::video_reader::get_property_declarations()</a>, and <a class="el" href="video__writer_8cxx_source.html#l00149">cgv::media::video::video_writer::get_property_declarations()</a>.</p>

</div>
</div>
<a id="aec0cf2e6e9275472854996435e25fe17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec0cf2e6e9275472854996435e25fe17">&#9670;&nbsp;</a></span>get_void()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::base::base::get_void </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>abstract interface for the getter of a dynamic property. </p>
<p>abstract interface for the getter, by default it simply returns false</p>
<p>The default implementation uses the <a class="el" href="classcgv_1_1base_1_1base.html#aa0fe4266b74ebe49de68faaab3ca7a7a" title="used for simple self reflection">self_reflect()</a> method to find a member with the given property as name. If not found, the get_void method returns false. </p>

<p>Reimplemented in <a class="el" href="structcgv_1_1base_1_1factory.html#aa4d907250a697d6c8368140133c9d719">cgv::base::factory</a>, <a class="el" href="classcgv_1_1base_1_1console.html#a122730d2bac682abd6213b355f7d95b5">cgv::base::console</a>, <a class="el" href="classcgv_1_1base_1_1base__generator.html#abfaaedd0749b1123dd7f320a13600027">cgv::base::base_generator</a>, <a class="el" href="classcgv_1_1media_1_1video_1_1video__writer.html#a90f05725f03c58306d1d3a35157517c4">cgv::media::video::video_writer</a>, <a class="el" href="classcgv_1_1media_1_1video_1_1video__reader.html#a0bd18953a4ce256e940177c643fca639">cgv::media::video::video_reader</a>, <a class="el" href="classcgv_1_1media_1_1image_1_1image__writer.html#aa6627b8b8595bbb75cb3e9f45839fa08">cgv::media::image::image_writer</a>, and <a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#aa96a1e4519bc87a517b5149ba27095e0">cgv::media::image::image_reader</a>.</p>

<p class="definition">Definition at line <a class="el" href="base_8cxx_source.html#l00215">215</a> of file <a class="el" href="base_8cxx_source.html">base.cxx</a>.</p>

<p class="reference">References <a class="el" href="find__reflection__handler_8cxx_source.html#l00053">cgv::reflect::find_reflection_handler::found_valid_target()</a>.</p>

<p class="reference">Referenced by <a class="el" href="image__reader_8cxx_source.html#l00325">cgv::media::image::image_reader::get_void()</a>, <a class="el" href="image__writer_8cxx_source.html#l00176">cgv::media::image::image_writer::get_void()</a>, <a class="el" href="video__reader_8cxx_source.html#l00191">cgv::media::video::video_reader::get_void()</a>, and <a class="el" href="video__writer_8cxx_source.html#l00164">cgv::media::video::video_writer::get_void()</a>.</p>

</div>
</div>
<a id="af235f0a26a1d9dd7aac02e4cb0009dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af235f0a26a1d9dd7aac02e4cb0009dc4">&#9670;&nbsp;</a></span>handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::app::application_plugin_base::handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcgv_1_1gui_1_1event.html">cgv::gui::event</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Final implementation of event_handler::handle() to support event handling of registered overlays. </p>
<p>Implement handle_event to handle any events that are passed to the instance of this class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the event to handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the event was handled and stopped here, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classcgv_1_1gui_1_1event__handler.html#aeef89567e820d30fc538b9be22083403">cgv::gui::event_handler</a>.</p>

<p class="definition">Definition at line <a class="el" href="application__plugin_8cxx_source.html#l00016">16</a> of file <a class="el" href="application__plugin_8cxx_source.html">application_plugin.cxx</a>.</p>

<p class="reference">References <a class="el" href="application__plugin_8h_source.html#l00042">cgv::app::application_plugin_base::blocking_overlay_ptr</a>, <a class="el" href="event_8h_source.html#l00033">cgv::gui::EF_DND</a>, <a class="el" href="event_8h_source.html#l00018">cgv::gui::EID_MOUSE</a>, <a class="el" href="mouse__event_8cxx_source.html#l00065">cgv::gui::mouse_event::get_action()</a>, <a class="el" href="event_8cxx_source.html#l00214">cgv::gui::event::get_flags()</a>, <a class="el" href="event_8cxx_source.html#l00202">cgv::gui::event::get_kind()</a>, <a class="el" href="mouse__event_8cxx_source.html#l00045">cgv::gui::mouse_event::get_x()</a>, <a class="el" href="mouse__event_8cxx_source.html#l00050">cgv::gui::mouse_event::get_y()</a>, <a class="el" href="classcgv_1_1app_1_1application__plugin__base.html#a288d3d89d13f1133cd254c184c107c05">cgv::app::application_plugin_base::handle_event()</a>, <a class="el" href="application__plugin_8h_source.html#l00039">cgv::app::application_plugin_base::last_blocking_overlay_ptr</a>, <a class="el" href="mouse__event_8h_source.html#l00018">cgv::gui::MA_ENTER</a>, <a class="el" href="mouse__event_8h_source.html#l00019">cgv::gui::MA_LEAVE</a>, <a class="el" href="mouse__event_8h_source.html#l00016">cgv::gui::MA_MOVE</a>, <a class="el" href="mouse__event_8h_source.html#l00013">cgv::gui::MA_PRESS</a>, <a class="el" href="mouse__event_8h_source.html#l00014">cgv::gui::MA_RELEASE</a>, <a class="el" href="mouse__event_8h_source.html#l00015">cgv::gui::MA_WHEEL</a>, <a class="el" href="application__plugin_8h_source.html#l00036">cgv::app::application_plugin_base::overlays</a>, and <a class="el" href="mouse__event_8cxx_source.html#l00111">cgv::gui::mouse_event::set_action()</a>.</p>

</div>
</div>
<a id="a288d3d89d13f1133cd254c184c107c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a288d3d89d13f1133cd254c184c107c05">&#9670;&nbsp;</a></span>handle_event()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cgv::app::application_plugin_base::handle_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcgv_1_1gui_1_1event.html">cgv::gui::event</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implement this method to handle any events not blocked by an registered overlay. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the event to handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the event was handled and stopped here, false otherwise. </dd></dl>

<p class="reference">Referenced by <a class="el" href="application__plugin_8cxx_source.html#l00016">cgv::app::application_plugin_base::handle()</a>.</p>

</div>
</div>
<a id="a72f711351433d2c4e1bf974e5d342f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72f711351433d2c4e1bf974e5d342f1f">&#9670;&nbsp;</a></span>handle_member_change()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class base_drawable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classcgv_1_1app_1_1generic__application__plugin.html">cgv::app::generic_application_plugin</a>&lt; base_drawable &gt;::handle_member_change </td>
          <td>(</td>
          <td class="paramtype">const cgv::utils::pointer_test &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty default implementation to handle member changes from GUI interactions or manual calls to <a class="el" href="classcgv_1_1app_1_1generic__application__plugin.html#a6a2dfb029b1958a382351907810c398e" title="Default implementation of the pure virtual base class method that delegates the member change evaluat...">on_set()</a> provided through a convenient evaluation interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the pointer_test interface used to conveniently evaluate the affected member. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classcgv_1_1app_1_1application__plugin__base.html#aad3c9ff929e4acfee4cb457b203483cf">cgv::app::application_plugin_base</a>.</p>

<p class="definition">Definition at line <a class="el" href="application__plugin_8h_source.html#l00118">118</a> of file <a class="el" href="application__plugin_8h_source.html">application_plugin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="application__plugin_8h_source.html#l00108">cgv::app::generic_application_plugin&lt; base_drawable &gt;::on_set()</a>.</p>

</div>
</div>
<a id="a8c5ab68b0ff784056a4b014982ad43a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c5ab68b0ff784056a4b014982ad43a2">&#9670;&nbsp;</a></span>initialize_view_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class base_drawable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classcgv_1_1app_1_1generic__application__plugin.html">cgv::app::generic_application_plugin</a>&lt; base_drawable &gt;::initialize_view_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the view pointer using drawable::find_view_as_node(). </p>
<p>Can be used to check when the view pointer is available and, e.g., perform one-time initializations of dependent members. Due to the non-guaranteed registration order of plugins it is advisable to call this method in drawable::init_frame.</p>
<dl class="section return"><dt>Returns</dt><dd>true when the view pointer is set initially (this will only fire once), false otherwise. </dd></dl>

<p>Implements <a class="el" href="classcgv_1_1app_1_1application__plugin__base.html#a278afbd16dd80b341b4d144d843e956f">cgv::app::application_plugin_base</a>.</p>

<p class="definition">Definition at line <a class="el" href="application__plugin_8h_source.html#l00127">127</a> of file <a class="el" href="application__plugin_8h_source.html">application_plugin.h</a>.</p>

<p class="reference">References <a class="el" href="application__plugin_8h_source.html#l00033">cgv::app::application_plugin_base::view_ptr</a>.</p>

</div>
</div>
<a id="ad796aa58a0b7d9c52d724a99366f58ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad796aa58a0b7d9c52d724a99366f58ae">&#9670;&nbsp;</a></span>is_property()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::base::base::is_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>property_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>type_name</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check if the given name specifies a property. </p>
<p>If the type name string pointer is provided, the type of the property is copied to the referenced string. </p>

<p class="definition">Definition at line <a class="el" href="base_8cxx_source.html#l00336">336</a> of file <a class="el" href="base_8cxx_source.html">base.cxx</a>.</p>

<p class="reference">References <a class="el" href="tokenizer_8h_source.html#l00121">cgv::utils::bite_all()</a>, and <a class="el" href="convert__string_8h_source.html#l00018">cgv::utils::to_string()</a>.</p>

</div>
</div>
<a id="afbfaded48bb322a4b77350ca73c9e1a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbfaded48bb322a4b77350ca73c9e1a2">&#9670;&nbsp;</a></span>multi_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cgv::base::base::multi_set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>property_assignments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>report_error</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set several properties </p>
<p>set several properties, which are defined as colon separated assignments, where the types are derived automatically</p>
<p>, which are defined as colon separated assignments, where the types are derived automatically to bool, int, double or std::string. </p>

<p class="definition">Definition at line <a class="el" href="base_8cxx_source.html#l00287">287</a> of file <a class="el" href="base_8cxx_source.html">base.cxx</a>.</p>

<p class="reference">References <a class="el" href="tokenizer_8h_source.html#l00121">cgv::utils::bite_all()</a>, <a class="el" href="scan_8cxx_source.html#l00017">cgv::utils::is_digit()</a>, <a class="el" href="scan_8cxx_source.html#l00353">cgv::utils::is_integer()</a>, and <a class="el" href="convert__string_8h_source.html#l00018">cgv::utils::to_string()</a>.</p>

<p class="reference">Referenced by <a class="el" href="base__generator_8h_source.html#l00132">cgv::base::has_property()</a>, and <a class="el" href="texture_8cxx_source.html#l00429">cgv::render::texture::write_to_file()</a>.</p>

</div>
</div>
<a id="a6a2dfb029b1958a382351907810c398e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a2dfb029b1958a382351907810c398e">&#9670;&nbsp;</a></span>on_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class base_drawable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classcgv_1_1app_1_1generic__application__plugin.html">cgv::app::generic_application_plugin</a>&lt; base_drawable &gt;::on_set </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>member_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the pure virtual base class method that delegates the member change evaluation to handle_member_change and performs the default actions of updating all member GUI views and requesting a redraw. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">member_ptr</td><td>the pointer to the affected member. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classcgv_1_1app_1_1application__plugin__base.html#aed86d82cc892937bf0357e67c983eb42">cgv::app::application_plugin_base</a>.</p>

<p class="definition">Definition at line <a class="el" href="application__plugin_8h_source.html#l00108">108</a> of file <a class="el" href="application__plugin_8h_source.html">application_plugin.h</a>.</p>

<p class="reference">References <a class="el" href="application__plugin_8h_source.html#l00118">cgv::app::generic_application_plugin&lt; base_drawable &gt;::handle_member_change()</a>, and <a class="el" href="provider_8cxx_source.html#l00072">cgv::gui::provider::update_member()</a>.</p>

</div>
</div>
<a id="aa91a5b7508ca2f8a995a7101a80cab76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa91a5b7508ca2f8a995a7101a80cab76">&#9670;&nbsp;</a></span>post_recreate_gui()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cgv::gui::provider::post_recreate_gui </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>delayed recreation of gui </p>
<p>schedule the recreation of the gui for the next time the program is idle. This mechanism is implemented in a thread save way. </p>

<p class="definition">Definition at line <a class="el" href="provider_8cxx_source.html#l00509">509</a> of file <a class="el" href="provider_8cxx_source.html">provider.cxx</a>.</p>

<p class="reference">References <a class="el" href="trigger_8cxx_source.html#l00100">cgv::gui::get_trigger_server()</a>, <a class="el" href="provider_8h_source.html#l00069">cgv::gui::provider::parent_group</a>, and <a class="el" href="provider_8cxx_source.html#l00509">cgv::gui::provider::post_recreate_gui()</a>.</p>

<p class="reference">Referenced by <a class="el" href="provider_8cxx_source.html#l00183">cgv::gui::provider::add_tree_node()</a>, <a class="el" href="provider_8cxx_source.html#l00207">cgv::gui::provider::begin_tree_node_void()</a>, and <a class="el" href="provider_8cxx_source.html#l00509">cgv::gui::provider::post_recreate_gui()</a>.</p>

</div>
</div>
<a id="ab71df33b57067886a8c264ed9eb672f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab71df33b57067886a8c264ed9eb672f5">&#9670;&nbsp;</a></span>recreate_gui()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cgv::gui::provider::recreate_gui </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recreate the gui of this instance right now. </p>
<p>Use this method to recreate the gui, dont call create gui directly. Be careful when calling the method from a functor that is attached to a gui element generated by this provider. This can cause the gui element to be destroyed before the callback triggering the recreate_gui method has been completely finished, what might make the program crash. Use the post_recreate_gui method instead. </p>

<p class="definition">Definition at line <a class="el" href="provider_8cxx_source.html#l00436">436</a> of file <a class="el" href="provider_8cxx_source.html">provider.cxx</a>.</p>

<p class="reference">References <a class="el" href="classcgv_1_1gui_1_1provider.html#a1d2f0b6c734c04d3c90a1c51ffbc0de9">cgv::gui::provider::create_gui()</a>, <a class="el" href="provider_8h_source.html#l00069">cgv::gui::provider::parent_group</a>, and <a class="el" href="provider_8cxx_source.html#l00297">cgv::gui::provider::remove_all_elements()</a>.</p>

</div>
</div>
<a id="a9e722ce8fd3bd48387d8ee5761498189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e722ce8fd3bd48387d8ee5761498189">&#9670;&nbsp;</a></span>ref_tree_node_visible_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool&amp; cgv::gui::provider::ref_tree_node_visible_flag </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a reference to the boolean flag, that tells whether the tree node for the passed value is visible </p>
<p>T can be with_index(v,i) as in the begin_tree_node function. You typically need this function in an on_set callback to check whether the user has toggled a tree node </p>

<p class="definition">Definition at line <a class="el" href="provider_8h_source.html#l00217">217</a> of file <a class="el" href="provider_8h_source.html">provider.h</a>.</p>

</div>
</div>
<a id="af1f8cfc69b09d2d9106d6ae82658d62b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1f8cfc69b09d2d9106d6ae82658d62b">&#9670;&nbsp;</a></span>register_overlay()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcgv_1_1data_1_1ref__ptr.html">cgv::data::ref_ptr</a>&lt;T&gt; cgv::app::application_plugin_base::register_overlay </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers an overlay instance as a child of this group. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the overlay class type; must inherit from overlay. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the overlay instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a ref_ptr to the registered overlay instance. </dd></dl>

<p class="definition">Definition at line <a class="el" href="application__plugin_8h_source.html#l00057">57</a> of file <a class="el" href="application__plugin_8h_source.html">application_plugin.h</a>.</p>

<p class="reference">References <a class="el" href="group_8cxx_source.html#l00036">cgv::base::group::append_child()</a>.</p>

</div>
</div>
<a id="aa0fe4266b74ebe49de68faaab3ca7a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0fe4266b74ebe49de68faaab3ca7a7a">&#9670;&nbsp;</a></span>self_reflect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::base::base::self_reflect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcgv_1_1reflect_1_1reflection__handler.html">cgv::reflect::reflection_handler</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>used for simple self reflection </p>
<p>is used by default implementation of set_void, get_void and get_property_declarations</p>
<p>The overloaded implementation is used by the default implementations of set_void, get_void and get_property_declarations with corresponding reflection handlers. The default implementation of self_reflect is empty. </p>

<p>Reimplemented in <a class="el" href="structcgv_1_1render_1_1render__config.html#a91eabc5d1bee4696cce6de5ad05dfbe8">cgv::render::render_config</a>.</p>

<p class="definition">Definition at line <a class="el" href="base_8cxx_source.html#l00161">161</a> of file <a class="el" href="base_8cxx_source.html">base.cxx</a>.</p>

</div>
</div>
<a id="abd1b6b56455165d769b580d4006eba17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd1b6b56455165d769b580d4006eba17">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cgv::base::base::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set a property of the element to the given value and perform standard conversions if necessary. </p>
<p>This templated version simply extracts the type of the value from the reference and calls the <a class="el" href="classcgv_1_1base_1_1base.html#a62d3cd5ae49c3e261f5c0e52bc59bd4f" title="abstract interface for the setter of a dynamic property.">set_void()</a> method. Note that this only works if the template cgv::type::info::type_name&lt;T&gt; is overloaded for the value type. </p>

<p class="definition">Definition at line <a class="el" href="base_8h_source.html#l00186">186</a> of file <a class="el" href="base_8h_source.html">base.h</a>.</p>

</div>
</div>
<a id="a9bfa89eb56c3302073b170ff24325773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bfa89eb56c3302073b170ff24325773">&#9670;&nbsp;</a></span>set_control_property()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cgv::gui::provider::set_control_property </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>property_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>property_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the property value of all controls of a given class member. </p>
<p>Use this method to loop over all controls of the given value and set their named property to the specified property value. </p>

<p class="definition">Definition at line <a class="el" href="provider_8h_source.html#l00343">343</a> of file <a class="el" href="provider_8h_source.html">provider.h</a>.</p>

</div>
</div>
<a id="a62d3cd5ae49c3e261f5c0e52bc59bd4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62d3cd5ae49c3e261f5c0e52bc59bd4f">&#9670;&nbsp;</a></span>set_void()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::base::base::set_void </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>value_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>abstract interface for the setter of a dynamic property. </p>
<p>abstract interface for the setter, by default it simply returns false</p>
<p>The default implementation uses the <a class="el" href="classcgv_1_1base_1_1base.html#aa0fe4266b74ebe49de68faaab3ca7a7a" title="used for simple self reflection">self_reflect()</a> method to find a member with the given property as name. If not found, the set_void method returns false. </p>

<p>Reimplemented in <a class="el" href="structcgv_1_1base_1_1factory.html#a03229b698d12d0da2cae1b769f0ee40e">cgv::base::factory</a>, <a class="el" href="classcgv_1_1base_1_1console.html#a99ea2f5fa87e80338b1f996de9dc6983">cgv::base::console</a>, <a class="el" href="classcgv_1_1base_1_1base__generator.html#aa69ce6781528ebf7f78412fd6c7bad5f">cgv::base::base_generator</a>, <a class="el" href="classcgv_1_1media_1_1video_1_1video__writer.html#afd0800ba2f918dc95b8a3ce2a26978ed">cgv::media::video::video_writer</a>, <a class="el" href="classcgv_1_1media_1_1video_1_1video__reader.html#a702b054c51a69f3d1b982a14c99282d6">cgv::media::video::video_reader</a>, <a class="el" href="classcgv_1_1media_1_1image_1_1image__writer.html#a2eeade9ca2755e97f55e1f162bf495b7">cgv::media::image::image_writer</a>, and <a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#aa31653a404d2100655e91db9c00cfda1">cgv::media::image::image_reader</a>.</p>

<p class="definition">Definition at line <a class="el" href="base_8cxx_source.html#l00181">181</a> of file <a class="el" href="base_8cxx_source.html">base.cxx</a>.</p>

<p class="reference">Referenced by <a class="el" href="image__reader_8cxx_source.html#l00318">cgv::media::image::image_reader::set_void()</a>, <a class="el" href="image__writer_8cxx_source.html#l00169">cgv::media::image::image_writer::set_void()</a>, <a class="el" href="video__reader_8cxx_source.html#l00184">cgv::media::video::video_reader::set_void()</a>, and <a class="el" href="video__writer_8cxx_source.html#l00157">cgv::media::video::video_writer::set_void()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a8335fb38baab1499d22bede7d582a4ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8335fb38baab1499d22bede7d582a4ed">&#9670;&nbsp;</a></span>view_ptr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcgv_1_1render_1_1view.html">cgv::render::view</a>* cgv::app::application_plugin_base::view_ptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a pointer to the base view. </p>
<p>If a specific view is required in an implementation, it is advised to declare a new member with the specific view name in the actual implementation of this class. </p>

<p class="definition">Definition at line <a class="el" href="application__plugin_8h_source.html#l00033">33</a> of file <a class="el" href="application__plugin_8h_source.html">application_plugin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="application__plugin_8cxx_source.html#l00009">cgv::app::application_plugin_base::application_plugin_base()</a>, and <a class="el" href="application__plugin_8h_source.html#l00127">cgv::app::generic_application_plugin&lt; base_drawable &gt;::initialize_view_ptr()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>libs/cgv_app/<a class="el" href="application__plugin_8h_source.html">application_plugin.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecgv.html">cgv</a></li><li class="navelem"><b>app</b></li><li class="navelem"><a class="el" href="classcgv_1_1app_1_1generic__application__plugin.html">generic_application_plugin</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
