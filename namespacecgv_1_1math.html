<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cgv: cgv::math Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cgv
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacecgv_1_1math.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">cgv::math Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>namespace with classes and algorithms for mathematics  
<a href="namespacecgv_1_1math.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1math_1_1adjacency__list.html">adjacency_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A graph represented in an adjacency list.  <a href="classcgv_1_1math_1_1adjacency__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1math_1_1pinhole.html">pinhole</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class to store and use a pinhole camera model without distortion but with support for skew and different focal lengths in x and y direction  <a href="classcgv_1_1math_1_1pinhole.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1math_1_1distorted__pinhole__types.html">distorted_pinhole_types</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">common type declarations used by <a class="el" href="classcgv_1_1math_1_1distorted__pinhole.html" title="pinhole camera including distortion according to Brown-Conrady model">distorted_pinhole</a> class that are independent of the template parameter  <a href="classcgv_1_1math_1_1distorted__pinhole__types.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1math_1_1distorted__pinhole.html">distorted_pinhole</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">pinhole camera including distortion according to Brown-Conrady model  <a href="classcgv_1_1math_1_1distorted__pinhole.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1math_1_1camera.html">camera</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">extend distorted pinhole with external calibration stored as a pose matrix  <a href="classcgv_1_1math_1_1camera.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1math_1_1diag__mat.html">diag_mat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A diagonal matrix type which internally stores the elements on the main diagonal in a vector.  <a href="structcgv_1_1math_1_1diag__mat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1math_1_1fibo__heap.html">fibo_heap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fibonacci heap.  <a href="classcgv_1_1math_1_1fibo__heap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">matrix of fixed size dimensions  <a href="classcgv_1_1math_1_1fmat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A column vector class.  <a href="classcgv_1_1math_1_1vec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector with zero based index.  <a href="classcgv_1_1math_1_1fvec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1math_1_1interval.html">interval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the interval template represents a close interval of two numbers, i.e.  <a href="classcgv_1_1math_1_1interval.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1math_1_1mat.html">mat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix type (full column major storage) The matrix can be loaded directly into OpenGL without need for transposing!  <a href="classcgv_1_1math_1_1mat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1math_1_1mfunc.html">mfunc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">interface class for multivariate function with two template arguments:  <a href="classcgv_1_1math_1_1mfunc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1math_1_1v2__func.html">v2_func</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialization of a multivariate function to two independent variables, which only reimplements the method get_nr_independent_variables.  <a href="classcgv_1_1math_1_1v2__func.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1math_1_1v3__func.html">v3_func</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialization of a multivariate function to three independent variables, which only reimplements the method get_nr_independent_variables.  <a href="classcgv_1_1math_1_1v3__func.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1math_1_1perm__mat.html">perm_mat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a permutation matrix type  <a href="structcgv_1_1math_1_1perm__mat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1math_1_1qem.html">qem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">dimension independent implementation of quadric error metrics  <a href="classcgv_1_1math_1_1qem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1math_1_1quaternion.html">quaternion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implements a quaternion.  <a href="classcgv_1_1math_1_1quaternion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1math_1_1random.html">random</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">High quality random number generator, which is a little bit slower than typical random number generators but with a period about 3.138 x 10^57.  <a href="structcgv_1_1math_1_1random.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1math_1_1ray.html">ray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class defines a template for n-dimensional rays with arbitrary data type defined by origin and direction.  <a href="classcgv_1_1math_1_1ray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1math_1_1ray_3_01T_00_013_01_4.html">ray&lt; T, 3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialization of ray class for 3 dimensions.  <a href="classcgv_1_1math_1_1ray_3_01T_00_013_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1math_1_1rigid__transform.html">rigid_transform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implementation of a rigid body transformation with a quaternion and a translation vector.  <a href="classcgv_1_1math_1_1rigid__transform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1math_1_1sparse__les__factory.html">sparse_les_factory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">factory class for sparse linear system solvers  <a href="classcgv_1_1math_1_1sparse__les__factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1math_1_1sparse__les.html">sparse_les</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">interface for implementations of solvers for sparse linear systems of the form A * x = b with a square matrix A.  <a href="classcgv_1_1math_1_1sparse__les.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1math_1_1sparse__les__factory__impl.html">sparse_les_factory_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implementation of factory class for sparse linear system solvers  <a href="classcgv_1_1math_1_1sparse__les__factory__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1math_1_1register__sparse__les__factory.html">register_sparse_les_factory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper template to register a sparse les solver  <a href="structcgv_1_1math_1_1register__sparse__les__factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1math_1_1thin__plate__spline.html">thin_plate_spline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A thin plate spline which represents 2d deformations See Fred L.  <a href="structcgv_1_1math_1_1thin__plate__spline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1math_1_1thin__hyper__plate__spline.html">thin_hyper_plate_spline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A thin hyperplate spline which represents 3d deformations 3d extension of the thin plate spline.  <a href="structcgv_1_1math_1_1thin__hyper__plate__spline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1math_1_1tri__diag__mat.html">tri_diag_mat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">tridiagonal matrix (square)  <a href="classcgv_1_1math_1_1tri__diag__mat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1math_1_1union__find.html">union_find</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A union find data structure.  <a href="structcgv_1_1math_1_1union__find.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1ee5ee26c821419a8c7c5efbf583d424"><td class="memItemLeft" align="right" valign="top"><a id="a1ee5ee26c821419a8c7c5efbf583d424"></a>
typedef <a class="el" href="classcgv_1_1data_1_1ref__ptr.html">cgv::data::ref_ptr</a>&lt; <a class="el" href="classcgv_1_1math_1_1sparse__les.html">sparse_les</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a1ee5ee26c821419a8c7c5efbf583d424">sparse_les_ptr</a></td></tr>
<tr class="memdesc:a1ee5ee26c821419a8c7c5efbf583d424"><td class="mdescLeft">&#160;</td><td class="mdescRight">reference counted pointer type for sparse les solver <br /></td></tr>
<tr class="separator:a1ee5ee26c821419a8c7c5efbf583d424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5cba5eba7be3c4228793a426cbb5944"><td class="memItemLeft" align="right" valign="top"><a id="ab5cba5eba7be3c4228793a426cbb5944"></a>
typedef <a class="el" href="classcgv_1_1data_1_1ref__ptr.html">cgv::data::ref_ptr</a>&lt; <a class="el" href="classcgv_1_1math_1_1sparse__les__factory.html">sparse_les_factory</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ab5cba5eba7be3c4228793a426cbb5944">sparse_les_factory_ptr</a></td></tr>
<tr class="memdesc:ab5cba5eba7be3c4228793a426cbb5944"><td class="mdescLeft">&#160;</td><td class="mdescRight">reference counted pointer type for sparse les solver factories <br /></td></tr>
<tr class="separator:ab5cba5eba7be3c4228793a426cbb5944"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a22446204b5909c06423af9ce96233507"><td class="memItemLeft" align="right" valign="top"><a id="a22446204b5909c06423af9ce96233507"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a22446204b5909c06423af9ce96233507">SparseLesCaps</a> </td></tr>
<tr class="memdesc:a22446204b5909c06423af9ce96233507"><td class="mdescLeft">&#160;</td><td class="mdescRight">capability options for a sparse linear solver <br /></td></tr>
<tr class="separator:a22446204b5909c06423af9ce96233507"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a329a46cc70edfd039f85153dc8aefc0e"><td class="memTemplParams" colspan="2"><a id="a329a46cc70edfd039f85153dc8aefc0e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a329a46cc70edfd039f85153dc8aefc0e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a329a46cc70edfd039f85153dc8aefc0e">mean</a> (const std::vector&lt; <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &gt; &amp;P, T inv_n=T(1)/P.size())</td></tr>
<tr class="memdesc:a329a46cc70edfd039f85153dc8aefc0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">mean of point set <br /></td></tr>
<tr class="separator:a329a46cc70edfd039f85153dc8aefc0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad955645264ca2260ee8621b44ae5f734"><td class="memTemplParams" colspan="2"><a id="ad955645264ca2260ee8621b44ae5f734"></a>
template&lt;typename T , cgv::type::uint32_type N, cgv::type::uint32_type M&gt; </td></tr>
<tr class="memitem:ad955645264ca2260ee8621b44ae5f734"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ad955645264ca2260ee8621b44ae5f734">svd</a> (const <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, N, M &gt; &amp;A, <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, N, N &gt; &amp;U, <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, M &gt; &amp;D, <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, M, M &gt; &amp;V_t, bool ordering=true, int maxiter=30)</td></tr>
<tr class="memdesc:ad955645264ca2260ee8621b44ae5f734"><td class="mdescLeft">&#160;</td><td class="mdescRight">svd wrapper <br /></td></tr>
<tr class="separator:ad955645264ca2260ee8621b44ae5f734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8527540ec203ab48b8d29c34602218f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T_SVD  = T&gt; </td></tr>
<tr class="memitem:aa8527540ec203ab48b8d29c34602218f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#aa8527540ec203ab48b8d29c34602218f">align</a> (const std::vector&lt; <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &gt; &amp;source_points, const std::vector&lt; <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &gt; &amp;target_points, <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 3 &gt; &amp;O, <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;t, T *scale_ptr=nullptr, bool allow_reflection=false)</td></tr>
<tr class="memdesc:aa8527540ec203ab48b8d29c34602218f"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute rigid body transformation and optionally uniform scaling to align source point set to target point set in least squares sense  <a href="namespacecgv_1_1math.html#aa8527540ec203ab48b8d29c34602218f">More...</a><br /></td></tr>
<tr class="separator:aa8527540ec203ab48b8d29c34602218f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334232cf858e03e53db9bbf416fc76e3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a334232cf858e03e53db9bbf416fc76e3"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a334232cf858e03e53db9bbf416fc76e3">bipoly_val</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;bp, const T &amp;x1, const T &amp;x2)</td></tr>
<tr class="memdesc:a334232cf858e03e53db9bbf416fc76e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">bivariate polynomials are stored in matrices in the following order: [a,b,c,d a*x1^3*x2^3 + b*x1^2*x2^3 + c*x1*x2^3 + d*x2^3 + e,f,g,h e*x1^3*x2^2 + f*x1^2*x2^2 + g*x1*x2^2 + h*x2^2 + i,j,k,l i*x1^3*x2 + j*x1^2*x2 + k*x1*x2 + l*x2 + m,n,o,p] m*x1^3 + n*x1^2 + o*x1 + p <br  />
  <a href="namespacecgv_1_1math.html#a334232cf858e03e53db9bbf416fc76e3">More...</a><br /></td></tr>
<tr class="separator:a334232cf858e03e53db9bbf416fc76e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c3df147faeb70898d5d8be36ee6989"><td class="memTemplParams" colspan="2"><a id="a71c3df147faeb70898d5d8be36ee6989"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a71c3df147faeb70898d5d8be36ee6989"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a71c3df147faeb70898d5d8be36ee6989">bipoly_val</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;bp, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a71c3df147faeb70898d5d8be36ee6989"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate a bivariate polynomial p at 2d position x p is the coefficients matrix of the bivariate polynomial evaluation is done by using the horner scheme <br /></td></tr>
<tr class="separator:a71c3df147faeb70898d5d8be36ee6989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd02962dd3e20c230b6920c4baa6b1cf"><td class="memTemplParams" colspan="2"><a id="abd02962dd3e20c230b6920c4baa6b1cf"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abd02962dd3e20c230b6920c4baa6b1cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#abd02962dd3e20c230b6920c4baa6b1cf">bipoly_int_x1</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;bp, const T &amp;k=0)</td></tr>
<tr class="memdesc:abd02962dd3e20c230b6920c4baa6b1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">analytic integration of bivariate polynomial int p(x1,x2) dx1 <br /></td></tr>
<tr class="separator:abd02962dd3e20c230b6920c4baa6b1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d44c29d8541df107111af2d9b2e179"><td class="memTemplParams" colspan="2"><a id="ae3d44c29d8541df107111af2d9b2e179"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae3d44c29d8541df107111af2d9b2e179"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ae3d44c29d8541df107111af2d9b2e179">bipoly_int_x2</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;bp, const T &amp;k=0)</td></tr>
<tr class="memdesc:ae3d44c29d8541df107111af2d9b2e179"><td class="mdescLeft">&#160;</td><td class="mdescRight">analytic integration of bivariate polynomial int p(x1,x2) dx2 <br /></td></tr>
<tr class="separator:ae3d44c29d8541df107111af2d9b2e179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c08fa6907f5b41a0f22362f9013f220"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; int, 2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a6c08fa6907f5b41a0f22362f9013f220">bresenham</a> (<a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; int, 2 &gt; origin, <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; int, 2 &gt; destination)</td></tr>
<tr class="memdesc:a6c08fa6907f5b41a0f22362f9013f220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a list of points along a rasterized line according to Bresenham's line drawing algorithm.  <a href="namespacecgv_1_1math.html#a6c08fa6907f5b41a0f22362f9013f220">More...</a><br /></td></tr>
<tr class="separator:a6c08fa6907f5b41a0f22362f9013f220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3d20eb47e56aebfa6f2208a351e668"><td class="memTemplParams" colspan="2"><a id="aeb3d20eb47e56aebfa6f2208a351e668"></a>
template&lt;typename key_type , typename idx_type &gt; </td></tr>
<tr class="memitem:aeb3d20eb47e56aebfa6f2208a351e668"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#aeb3d20eb47e56aebfa6f2208a351e668">bucket_sort</a> (const std::vector&lt; key_type &gt; &amp;keys, size_t nr_keys, std::vector&lt; idx_type &gt; &amp;perm, std::vector&lt; idx_type &gt; *perm_in_ptr=0)</td></tr>
<tr class="memdesc:aeb3d20eb47e56aebfa6f2208a351e668"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute a permutation perm with bucket_sort over index typed keys that a limited to nr_keys, optionally provide an initial permutation <br /></td></tr>
<tr class="separator:aeb3d20eb47e56aebfa6f2208a351e668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3e38779f899fbd4ec9b0c86b3aca3c"><td class="memTemplParams" colspan="2"><a id="abf3e38779f899fbd4ec9b0c86b3aca3c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abf3e38779f899fbd4ec9b0c86b3aca3c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#abf3e38779f899fbd4ec9b0c86b3aca3c">distortion_inversion_epsilon</a> ()</td></tr>
<tr class="memdesc:abf3e38779f899fbd4ec9b0c86b3aca3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">function to provide type specific epsilon for inversion of distortion model <br /></td></tr>
<tr class="separator:abf3e38779f899fbd4ec9b0c86b3aca3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c30190cfd6bcece90c27f4f3fb0f5b"><td class="memItemLeft" align="right" valign="top"><a id="a36c30190cfd6bcece90c27f4f3fb0f5b"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a36c30190cfd6bcece90c27f4f3fb0f5b"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a36c30190cfd6bcece90c27f4f3fb0f5b">distortion_inversion_epsilon</a> ()</td></tr>
<tr class="memdesc:a36c30190cfd6bcece90c27f4f3fb0f5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialization to float <br /></td></tr>
<tr class="separator:a36c30190cfd6bcece90c27f4f3fb0f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b594665950a0417ea397d6d419fe826"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2b594665950a0417ea397d6d419fe826"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a2b594665950a0417ea397d6d419fe826">create_color_map</a> (unsigned steps=256, std::string name=&quot;jet&quot;)</td></tr>
<tr class="memdesc:a2b594665950a0417ea397d6d419fe826"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates different type of color map matrices colors are stored as columns in the resulting matrix the number of columns is defined by the parameter steps colormaps can be chosen by name : possible colormaps are "gray" black .  <a href="namespacecgv_1_1math.html#a2b594665950a0417ea397d6d419fe826">More...</a><br /></td></tr>
<tr class="separator:a2b594665950a0417ea397d6d419fe826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3795d992bc753f74302f173f646c2cfe"><td class="memTemplParams" colspan="2"><a id="a3795d992bc753f74302f173f646c2cfe"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3795d992bc753f74302f173f646c2cfe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a3795d992bc753f74302f173f646c2cfe">rgb_2_xyz</a> (<a class="el" href="classcgv_1_1math_1_1mat.html">math::mat</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a3795d992bc753f74302f173f646c2cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert matrix columns from rgb to xyz <br /></td></tr>
<tr class="separator:a3795d992bc753f74302f173f646c2cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ebf9f24bcb148bc9e5afc87dac508e7"><td class="memTemplParams" colspan="2"><a id="a4ebf9f24bcb148bc9e5afc87dac508e7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4ebf9f24bcb148bc9e5afc87dac508e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1vec.html">math::vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a4ebf9f24bcb148bc9e5afc87dac508e7">xyz_2_rgb</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">math::vec</a>&lt; T &gt; &amp;xyz)</td></tr>
<tr class="memdesc:a4ebf9f24bcb148bc9e5afc87dac508e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert colo vector from xyz to rgb <br /></td></tr>
<tr class="separator:a4ebf9f24bcb148bc9e5afc87dac508e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298492e84c1a1e16cf57c3130a5e250e"><td class="memTemplParams" colspan="2"><a id="a298492e84c1a1e16cf57c3130a5e250e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a298492e84c1a1e16cf57c3130a5e250e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a298492e84c1a1e16cf57c3130a5e250e">xyz_2_rgb</a> (<a class="el" href="classcgv_1_1math_1_1mat.html">math::mat</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a298492e84c1a1e16cf57c3130a5e250e"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert matrix columns from xyz to rgb <br /></td></tr>
<tr class="separator:a298492e84c1a1e16cf57c3130a5e250e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4e6bd4309b6498f27ab4d9a6d9e8f8"><td class="memTemplParams" colspan="2"><a id="add4e6bd4309b6498f27ab4d9a6d9e8f8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:add4e6bd4309b6498f27ab4d9a6d9e8f8"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structcgv_1_1math_1_1diag__mat.html">diag_mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#add4e6bd4309b6498f27ab4d9a6d9e8f8">operator*</a> (const T &amp;s, const <a class="el" href="structcgv_1_1math_1_1diag__mat.html">diag_mat</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:add4e6bd4309b6498f27ab4d9a6d9e8f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplication of scalar s and diagonal matrix m <br /></td></tr>
<tr class="separator:add4e6bd4309b6498f27ab4d9a6d9e8f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73290cc8b3dc6aef55ceb9067d450db7"><td class="memTemplParams" colspan="2"><a id="a73290cc8b3dc6aef55ceb9067d450db7"></a>
template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:a73290cc8b3dc6aef55ceb9067d450db7"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structcgv_1_1math_1_1diag__mat.html">diag_mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a73290cc8b3dc6aef55ceb9067d450db7">operator*</a> (const <a class="el" href="structcgv_1_1math_1_1diag__mat.html">diag_mat</a>&lt; S &gt; &amp;s, const <a class="el" href="structcgv_1_1math_1_1diag__mat.html">diag_mat</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a73290cc8b3dc6aef55ceb9067d450db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">matrix multiplication of diagonal matrix s and m <br /></td></tr>
<tr class="separator:a73290cc8b3dc6aef55ceb9067d450db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c3be3cf3933d0707bbce702589b296"><td class="memTemplParams" colspan="2"><a id="a65c3be3cf3933d0707bbce702589b296"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a65c3be3cf3933d0707bbce702589b296"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a65c3be3cf3933d0707bbce702589b296">operator*</a> (const <a class="el" href="structcgv_1_1math_1_1perm__mat.html">perm_mat</a> &amp;p, const <a class="el" href="structcgv_1_1math_1_1diag__mat.html">diag_mat</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a65c3be3cf3933d0707bbce702589b296"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplies a permutation matrix from left to apply a rows permutation <br /></td></tr>
<tr class="separator:a65c3be3cf3933d0707bbce702589b296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b33039575323f0ab6d45f75525895ad"><td class="memTemplParams" colspan="2"><a id="a3b33039575323f0ab6d45f75525895ad"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3b33039575323f0ab6d45f75525895ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a3b33039575323f0ab6d45f75525895ad">operator*</a> (const <a class="el" href="structcgv_1_1math_1_1diag__mat.html">diag_mat</a>&lt; T &gt; &amp;m, const <a class="el" href="structcgv_1_1math_1_1perm__mat.html">perm_mat</a> &amp;p)</td></tr>
<tr class="memdesc:a3b33039575323f0ab6d45f75525895ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplies a permutation matrix from right to apply a rows permutation <br /></td></tr>
<tr class="separator:a3b33039575323f0ab6d45f75525895ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1ac596b696fed9bf9de9f94da38aac"><td class="memTemplParams" colspan="2"><a id="a3c1ac596b696fed9bf9de9f94da38aac"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3c1ac596b696fed9bf9de9f94da38aac"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a3c1ac596b696fed9bf9de9f94da38aac">operator*</a> (const <a class="el" href="structcgv_1_1math_1_1diag__mat.html">diag_mat</a>&lt; T &gt; &amp;s, const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a3c1ac596b696fed9bf9de9f94da38aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">matrix multiplication of matrix m by a diagonal matrix s <br /></td></tr>
<tr class="separator:a3c1ac596b696fed9bf9de9f94da38aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3184ae8911e141826cfb582cffe2fc98"><td class="memTemplParams" colspan="2"><a id="a3184ae8911e141826cfb582cffe2fc98"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3184ae8911e141826cfb582cffe2fc98"><td class="memTemplItemLeft" align="right" valign="top">const up_tri_mat&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a3184ae8911e141826cfb582cffe2fc98">operator*</a> (const up_tri_mat&lt; T &gt; &amp;m, const <a class="el" href="structcgv_1_1math_1_1diag__mat.html">diag_mat</a>&lt; T &gt; &amp;s)</td></tr>
<tr class="memdesc:a3184ae8911e141826cfb582cffe2fc98"><td class="mdescLeft">&#160;</td><td class="mdescRight">matrix multiplication of upper triangular matrix m by a diagonal matrix s <br /></td></tr>
<tr class="separator:a3184ae8911e141826cfb582cffe2fc98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959d852b32d156d183107537cc965ca7"><td class="memTemplParams" colspan="2"><a id="a959d852b32d156d183107537cc965ca7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a959d852b32d156d183107537cc965ca7"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a959d852b32d156d183107537cc965ca7">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structcgv_1_1math_1_1diag__mat.html">diag_mat</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a959d852b32d156d183107537cc965ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">output of a diagonal matrix onto an ostream <br /></td></tr>
<tr class="separator:a959d852b32d156d183107537cc965ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bdff18efd6afb8e7d19406cb7664e51"><td class="memTemplParams" colspan="2"><a id="a4bdff18efd6afb8e7d19406cb7664e51"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4bdff18efd6afb8e7d19406cb7664e51"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a4bdff18efd6afb8e7d19406cb7664e51">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="structcgv_1_1math_1_1diag__mat.html">diag_mat</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a4bdff18efd6afb8e7d19406cb7664e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">input of a diagonal matrix from an istream <br /></td></tr>
<tr class="separator:a4bdff18efd6afb8e7d19406cb7664e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a12451076df1957fe4247589887704d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1a12451076df1957fe4247589887704d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a1a12451076df1957fe4247589887704d">sqrdist_transf_1d</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;f, <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;d)</td></tr>
<tr class="memdesc:a1a12451076df1957fe4247589887704d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of 1d and 2d linear time distance transformation see: "Distance Transforms of Sampled Functions Pedro F.  <a href="namespacecgv_1_1math.html#a1a12451076df1957fe4247589887704d">More...</a><br /></td></tr>
<tr class="separator:a1a12451076df1957fe4247589887704d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae111715a4f488edeb34ecbd1d790ece3"><td class="memTemplParams" colspan="2"><a id="ae111715a4f488edeb34ecbd1d790ece3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae111715a4f488edeb34ecbd1d790ece3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ae111715a4f488edeb34ecbd1d790ece3">sqrdist_transf_2d</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;input, <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;output, T on=1)</td></tr>
<tr class="memdesc:ae111715a4f488edeb34ecbd1d790ece3"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the squared distance transform of an input image <br /></td></tr>
<tr class="separator:ae111715a4f488edeb34ecbd1d790ece3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb7ef1ba387bc69a8ee0eedd008b140"><td class="memTemplParams" colspan="2"><a id="a6fb7ef1ba387bc69a8ee0eedd008b140"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6fb7ef1ba387bc69a8ee0eedd008b140"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a6fb7ef1ba387bc69a8ee0eedd008b140">dist_transf_2d</a> (<a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;input, <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;output, T on=1)</td></tr>
<tr class="memdesc:a6fb7ef1ba387bc69a8ee0eedd008b140"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the distance transform of an input image <br /></td></tr>
<tr class="separator:a6fb7ef1ba387bc69a8ee0eedd008b140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7edcbce1ad75f9e7f698dfe11e8f41f4"><td class="memTemplParams" colspan="2"><a id="a7edcbce1ad75f9e7f698dfe11e8f41f4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7edcbce1ad75f9e7f698dfe11e8f41f4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a7edcbce1ad75f9e7f698dfe11e8f41f4">eig_sym</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;a, <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;v, <a class="el" href="structcgv_1_1math_1_1diag__mat.html">diag_mat</a>&lt; T &gt; &amp;d, bool ordering=true, unsigned maxiter=50)</td></tr>
<tr class="memdesc:a7edcbce1ad75f9e7f698dfe11e8f41f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">eigen decomposition of a symmetric matrix using the jacobi method v contains the eigenvectors d contains the eigenvalues a=v*d*transpose(v) <br /></td></tr>
<tr class="separator:a7edcbce1ad75f9e7f698dfe11e8f41f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f639abf33334ad93ab52dbdaa19abf"><td class="memTemplParams" colspan="2"><a id="ae1f639abf33334ad93ab52dbdaa19abf"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:ae1f639abf33334ad93ab52dbdaa19abf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, N, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ae1f639abf33334ad93ab52dbdaa19abf">transpose</a> (const <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, N, N &gt; &amp;m)</td></tr>
<tr class="memdesc:ae1f639abf33334ad93ab52dbdaa19abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the transposed of a square matrix <br /></td></tr>
<tr class="separator:ae1f639abf33334ad93ab52dbdaa19abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e21658387fcb926d7d2107455b93e6"><td class="memTemplParams" colspan="2"><a id="a98e21658387fcb926d7d2107455b93e6"></a>
template&lt;typename T , cgv::type::uint32_type N, cgv::type::uint32_type M&gt; </td></tr>
<tr class="memitem:a98e21658387fcb926d7d2107455b93e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, N, M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a98e21658387fcb926d7d2107455b93e6">operator*</a> (const T &amp;s, const <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, N, M &gt; &amp;m)</td></tr>
<tr class="memdesc:a98e21658387fcb926d7d2107455b93e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the product of a scalar s and a matrix m <br /></td></tr>
<tr class="separator:a98e21658387fcb926d7d2107455b93e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6566df1a94d71d55d3335f25ab53153d"><td class="memTemplParams" colspan="2"><a id="a6566df1a94d71d55d3335f25ab53153d"></a>
template&lt;typename T , cgv::type::uint32_type N, cgv::type::uint32_type M&gt; </td></tr>
<tr class="memitem:a6566df1a94d71d55d3335f25ab53153d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a6566df1a94d71d55d3335f25ab53153d">operator*</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v_row, const <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, N, M &gt; &amp;m)</td></tr>
<tr class="memdesc:a6566df1a94d71d55d3335f25ab53153d"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiply a row vector from the left to matrix m and return a row vector <br /></td></tr>
<tr class="separator:a6566df1a94d71d55d3335f25ab53153d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5761c72337c6456a9e5830a88e845c"><td class="memTemplParams" colspan="2"><a id="a3e5761c72337c6456a9e5830a88e845c"></a>
template&lt;typename T , cgv::type::uint32_type N, cgv::type::uint32_type M&gt; </td></tr>
<tr class="memitem:a3e5761c72337c6456a9e5830a88e845c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a3e5761c72337c6456a9e5830a88e845c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, N, M &gt; &amp;m)</td></tr>
<tr class="memdesc:a3e5761c72337c6456a9e5830a88e845c"><td class="mdescLeft">&#160;</td><td class="mdescRight">output of a matrix onto an ostream <br /></td></tr>
<tr class="separator:a3e5761c72337c6456a9e5830a88e845c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42e4ccbb7f1f909ddebc4ca3a15d70a"><td class="memTemplParams" colspan="2"><a id="aa42e4ccbb7f1f909ddebc4ca3a15d70a"></a>
template&lt;typename T , cgv::type::uint32_type N, cgv::type::uint32_type M&gt; </td></tr>
<tr class="memitem:aa42e4ccbb7f1f909ddebc4ca3a15d70a"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#aa42e4ccbb7f1f909ddebc4ca3a15d70a">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, N, M &gt; &amp;m)</td></tr>
<tr class="memdesc:aa42e4ccbb7f1f909ddebc4ca3a15d70a"><td class="mdescLeft">&#160;</td><td class="mdescRight">input of a matrix onto an ostream <br /></td></tr>
<tr class="separator:aa42e4ccbb7f1f909ddebc4ca3a15d70a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6834066b8a9e1319b63e48423c67baa5"><td class="memTemplParams" colspan="2"><a id="a6834066b8a9e1319b63e48423c67baa5"></a>
template&lt;typename T , cgv::type::uint32_type N, typename S , cgv::type::uint32_type M&gt; </td></tr>
<tr class="memitem:a6834066b8a9e1319b63e48423c67baa5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, N, M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a6834066b8a9e1319b63e48423c67baa5">dyad</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; S, M &gt; &amp;w)</td></tr>
<tr class="memdesc:a6834066b8a9e1319b63e48423c67baa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the outer product of vector v and w <br /></td></tr>
<tr class="separator:a6834066b8a9e1319b63e48423c67baa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133d06634d2086b01c9b8ef341009331"><td class="memTemplParams" colspan="2"><a id="a133d06634d2086b01c9b8ef341009331"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a133d06634d2086b01c9b8ef341009331"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a133d06634d2086b01c9b8ef341009331">det</a> (const <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 2, 2 &gt; &amp;m)</td></tr>
<tr class="memdesc:a133d06634d2086b01c9b8ef341009331"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the determinant of a 2x2 matrix <br /></td></tr>
<tr class="separator:a133d06634d2086b01c9b8ef341009331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc3aa555d004997bafd25299a193891"><td class="memTemplParams" colspan="2"><a id="aecc3aa555d004997bafd25299a193891"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aecc3aa555d004997bafd25299a193891"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#aecc3aa555d004997bafd25299a193891">det</a> (const <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 3 &gt; &amp;m)</td></tr>
<tr class="memdesc:aecc3aa555d004997bafd25299a193891"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the determinant of a 3x3 matrix <br /></td></tr>
<tr class="separator:aecc3aa555d004997bafd25299a193891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72cf634eb03e767e64433f0e69d27442"><td class="memTemplParams" colspan="2"><a id="a72cf634eb03e767e64433f0e69d27442"></a>
template&lt;typename T , cgv::type::uint32_type N, cgv::type::uint32_type M&gt; </td></tr>
<tr class="memitem:a72cf634eb03e767e64433f0e69d27442"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, N, M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a72cf634eb03e767e64433f0e69d27442">lerp</a> (const <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, N, M &gt; &amp;m1, const <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, N, M &gt; &amp;m2, T t)</td></tr>
<tr class="memdesc:a72cf634eb03e767e64433f0e69d27442"><td class="mdescLeft">&#160;</td><td class="mdescRight">linear interpolation returns (1-t)*m1 + t*m2 <br /></td></tr>
<tr class="separator:a72cf634eb03e767e64433f0e69d27442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc94728b5da613144c5fe7baaa908761"><td class="memTemplParams" colspan="2"><a id="abc94728b5da613144c5fe7baaa908761"></a>
template&lt;typename T , cgv::type::uint32_type N, cgv::type::uint32_type M&gt; </td></tr>
<tr class="memitem:abc94728b5da613144c5fe7baaa908761"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, N, M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#abc94728b5da613144c5fe7baaa908761">lerp</a> (const <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, N, M &gt; &amp;m1, const <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, N, M &gt; &amp;m2, <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, N, M &gt; t)</td></tr>
<tr class="memdesc:abc94728b5da613144c5fe7baaa908761"><td class="mdescLeft">&#160;</td><td class="mdescRight">linear interpolation returns (1-t)*m1 + t*m2 <br /></td></tr>
<tr class="separator:abc94728b5da613144c5fe7baaa908761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c775fdb3417e4bab2f32bd5e76a9e2"><td class="memTemplParams" colspan="2"><a id="a94c775fdb3417e4bab2f32bd5e76a9e2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a94c775fdb3417e4bab2f32bd5e76a9e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 4, 4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a94c775fdb3417e4bab2f32bd5e76a9e2">zero4</a> ()</td></tr>
<tr class="memdesc:a94c775fdb3417e4bab2f32bd5e76a9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct 4x4 zero matrix <br /></td></tr>
<tr class="separator:a94c775fdb3417e4bab2f32bd5e76a9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b72ce41a65bef43ff53d97f7fd594c"><td class="memTemplParams" colspan="2"><a id="a09b72ce41a65bef43ff53d97f7fd594c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a09b72ce41a65bef43ff53d97f7fd594c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 2, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a09b72ce41a65bef43ff53d97f7fd594c">identity2</a> ()</td></tr>
<tr class="memdesc:a09b72ce41a65bef43ff53d97f7fd594c"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct 2x2 identity matrix <br /></td></tr>
<tr class="separator:a09b72ce41a65bef43ff53d97f7fd594c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b4de5b808b7aac948cc91a10881ffc"><td class="memTemplParams" colspan="2"><a id="a37b4de5b808b7aac948cc91a10881ffc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a37b4de5b808b7aac948cc91a10881ffc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a37b4de5b808b7aac948cc91a10881ffc">identity3</a> ()</td></tr>
<tr class="memdesc:a37b4de5b808b7aac948cc91a10881ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct 3x3 identity matrix <br /></td></tr>
<tr class="separator:a37b4de5b808b7aac948cc91a10881ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3e99019bd391ea3404126e830929ad"><td class="memTemplParams" colspan="2"><a id="a8a3e99019bd391ea3404126e830929ad"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8a3e99019bd391ea3404126e830929ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 4, 4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a8a3e99019bd391ea3404126e830929ad">identity4</a> ()</td></tr>
<tr class="memdesc:a8a3e99019bd391ea3404126e830929ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct 4x4 identity matrix <br /></td></tr>
<tr class="separator:a8a3e99019bd391ea3404126e830929ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40227876ac052547b447f0d57e0cd081"><td class="memTemplParams" colspan="2"><a id="a40227876ac052547b447f0d57e0cd081"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a40227876ac052547b447f0d57e0cd081"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a40227876ac052547b447f0d57e0cd081">translate2h</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 2 &gt; &amp;t)</td></tr>
<tr class="memdesc:a40227876ac052547b447f0d57e0cd081"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct homogeneous 2x2 translation matrix from vec2 <br /></td></tr>
<tr class="separator:a40227876ac052547b447f0d57e0cd081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e82282de2fef3b8ad12a8fcc66f84c"><td class="memTemplParams" colspan="2"><a id="a61e82282de2fef3b8ad12a8fcc66f84c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a61e82282de2fef3b8ad12a8fcc66f84c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a61e82282de2fef3b8ad12a8fcc66f84c">translate2h</a> (const T &amp;tx, const T &amp;ty)</td></tr>
<tr class="memdesc:a61e82282de2fef3b8ad12a8fcc66f84c"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct homogeneous 2x2 translation matrix from xy components <br /></td></tr>
<tr class="separator:a61e82282de2fef3b8ad12a8fcc66f84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d05b83aafda5042f9413b6e6c80199"><td class="memTemplParams" colspan="2"><a id="a68d05b83aafda5042f9413b6e6c80199"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a68d05b83aafda5042f9413b6e6c80199"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 4, 4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a68d05b83aafda5042f9413b6e6c80199">translate4</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;t)</td></tr>
<tr class="memdesc:a68d05b83aafda5042f9413b6e6c80199"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct 4x4 translation matrix from vec3 <br /></td></tr>
<tr class="separator:a68d05b83aafda5042f9413b6e6c80199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38819ba55007e7e00fdf2fbfb0cf8796"><td class="memTemplParams" colspan="2"><a id="a38819ba55007e7e00fdf2fbfb0cf8796"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a38819ba55007e7e00fdf2fbfb0cf8796"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 4, 4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a38819ba55007e7e00fdf2fbfb0cf8796">translate4</a> (const T &amp;tx, const T &amp;ty, const T &amp;tz)</td></tr>
<tr class="memdesc:a38819ba55007e7e00fdf2fbfb0cf8796"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct 4x4 translation matrix from xyz components <br /></td></tr>
<tr class="separator:a38819ba55007e7e00fdf2fbfb0cf8796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136599724e3fb02e07b8c2be0bb1eaa8"><td class="memTemplParams" colspan="2"><a id="a136599724e3fb02e07b8c2be0bb1eaa8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a136599724e3fb02e07b8c2be0bb1eaa8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a136599724e3fb02e07b8c2be0bb1eaa8">scale2h</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 2 &gt; &amp;s)</td></tr>
<tr class="memdesc:a136599724e3fb02e07b8c2be0bb1eaa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct homogeneous 2x2 scale matrix from vec2 <br /></td></tr>
<tr class="separator:a136599724e3fb02e07b8c2be0bb1eaa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa150c7fd8e574cd201dcf467074245b7"><td class="memTemplParams" colspan="2"><a id="aa150c7fd8e574cd201dcf467074245b7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa150c7fd8e574cd201dcf467074245b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#aa150c7fd8e574cd201dcf467074245b7">scale2h</a> (const T &amp;sx, const T &amp;sy)</td></tr>
<tr class="memdesc:aa150c7fd8e574cd201dcf467074245b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct homogeneous 2x2 scale matrix from xy components <br /></td></tr>
<tr class="separator:aa150c7fd8e574cd201dcf467074245b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe9fb18427a4b1ce7f0e5c78cc3cba6"><td class="memTemplParams" colspan="2"><a id="abbe9fb18427a4b1ce7f0e5c78cc3cba6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abbe9fb18427a4b1ce7f0e5c78cc3cba6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 2, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#abbe9fb18427a4b1ce7f0e5c78cc3cba6">scale2</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 2 &gt; &amp;s)</td></tr>
<tr class="memdesc:abbe9fb18427a4b1ce7f0e5c78cc3cba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct 2x2 scale matrix from xy scales <br /></td></tr>
<tr class="separator:abbe9fb18427a4b1ce7f0e5c78cc3cba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02471f3347c3e55f2fd1aa6ed811c172"><td class="memTemplParams" colspan="2"><a id="a02471f3347c3e55f2fd1aa6ed811c172"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a02471f3347c3e55f2fd1aa6ed811c172"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 2, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a02471f3347c3e55f2fd1aa6ed811c172">scale2</a> (const T &amp;sx, const T &amp;sy)</td></tr>
<tr class="memdesc:a02471f3347c3e55f2fd1aa6ed811c172"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct 2x2 scale matrix from xy scales <br /></td></tr>
<tr class="separator:a02471f3347c3e55f2fd1aa6ed811c172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533f02b2328b0937e19caaa3484c5a3f"><td class="memTemplParams" colspan="2"><a id="a533f02b2328b0937e19caaa3484c5a3f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a533f02b2328b0937e19caaa3484c5a3f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a533f02b2328b0937e19caaa3484c5a3f">scale3</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;s)</td></tr>
<tr class="memdesc:a533f02b2328b0937e19caaa3484c5a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct 3x3 scale matrix from xyz scales <br /></td></tr>
<tr class="separator:a533f02b2328b0937e19caaa3484c5a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c9b1ecbfcbac14a4005e04879e5f1b"><td class="memTemplParams" colspan="2"><a id="ad3c9b1ecbfcbac14a4005e04879e5f1b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad3c9b1ecbfcbac14a4005e04879e5f1b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ad3c9b1ecbfcbac14a4005e04879e5f1b">scale3</a> (const T &amp;sx, const T &amp;sy, const T &amp;sz)</td></tr>
<tr class="memdesc:ad3c9b1ecbfcbac14a4005e04879e5f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct 3x3 scale matrix from xyz scales <br /></td></tr>
<tr class="separator:ad3c9b1ecbfcbac14a4005e04879e5f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6d917ec383078fb72e44889b438c20"><td class="memTemplParams" colspan="2"><a id="a3f6d917ec383078fb72e44889b438c20"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3f6d917ec383078fb72e44889b438c20"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 4, 4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a3f6d917ec383078fb72e44889b438c20">scale4</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;s)</td></tr>
<tr class="memdesc:a3f6d917ec383078fb72e44889b438c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct 4x4 scale matrix from xyz scales <br /></td></tr>
<tr class="separator:a3f6d917ec383078fb72e44889b438c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc22f50716b36e15f4e1dd011dabdee"><td class="memTemplParams" colspan="2"><a id="adfc22f50716b36e15f4e1dd011dabdee"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:adfc22f50716b36e15f4e1dd011dabdee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 4, 4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#adfc22f50716b36e15f4e1dd011dabdee">scale4</a> (const T &amp;sx, const T &amp;sy, const T &amp;sz)</td></tr>
<tr class="memdesc:adfc22f50716b36e15f4e1dd011dabdee"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct 4x4 scale matrix from xyz scales <br /></td></tr>
<tr class="separator:adfc22f50716b36e15f4e1dd011dabdee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d11a062a233029cc2ec04af3deb727b"><td class="memTemplParams" colspan="2"><a id="a8d11a062a233029cc2ec04af3deb727b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8d11a062a233029cc2ec04af3deb727b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 4, 4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a8d11a062a233029cc2ec04af3deb727b">scale4</a> (const T &amp;s)</td></tr>
<tr class="memdesc:a8d11a062a233029cc2ec04af3deb727b"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct 4x4 uniform scale matrix <br /></td></tr>
<tr class="separator:a8d11a062a233029cc2ec04af3deb727b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1bc0dbc569b1644210dad24319c693"><td class="memTemplParams" colspan="2"><a id="ade1bc0dbc569b1644210dad24319c693"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ade1bc0dbc569b1644210dad24319c693"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 2, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ade1bc0dbc569b1644210dad24319c693">rotate2</a> (const T &amp;A)</td></tr>
<tr class="memdesc:ade1bc0dbc569b1644210dad24319c693"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct 2x2 rotation matrix from angle in degrees <br /></td></tr>
<tr class="separator:ade1bc0dbc569b1644210dad24319c693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114910f4a04bd24d7a04d43d4fe79fc8"><td class="memTemplParams" colspan="2"><a id="a114910f4a04bd24d7a04d43d4fe79fc8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a114910f4a04bd24d7a04d43d4fe79fc8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a114910f4a04bd24d7a04d43d4fe79fc8">rotate2h</a> (const T &amp;A)</td></tr>
<tr class="memdesc:a114910f4a04bd24d7a04d43d4fe79fc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct homogeneous 2x2 rotation matrix from angle in degrees <br /></td></tr>
<tr class="separator:a114910f4a04bd24d7a04d43d4fe79fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c02fb56bb0f27964498d29f7eaa679"><td class="memTemplParams" colspan="2"><a id="af6c02fb56bb0f27964498d29f7eaa679"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af6c02fb56bb0f27964498d29f7eaa679"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#af6c02fb56bb0f27964498d29f7eaa679">rotate3</a> (const T &amp;A, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;a)</td></tr>
<tr class="memdesc:af6c02fb56bb0f27964498d29f7eaa679"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct 3x3 rotation matrix from angle in degrees and axis <br /></td></tr>
<tr class="separator:af6c02fb56bb0f27964498d29f7eaa679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39594949e1518068bdab10f89da0d57d"><td class="memTemplParams" colspan="2"><a id="a39594949e1518068bdab10f89da0d57d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a39594949e1518068bdab10f89da0d57d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a39594949e1518068bdab10f89da0d57d">rotate3</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;A)</td></tr>
<tr class="memdesc:a39594949e1518068bdab10f89da0d57d"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct 3x3 rotation matrix from euler angles yaw, pitch and roll around axes y, x and z in degrees <br /></td></tr>
<tr class="separator:a39594949e1518068bdab10f89da0d57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b280a0167112c9fc71710b472909949"><td class="memTemplParams" colspan="2"><a id="a8b280a0167112c9fc71710b472909949"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8b280a0167112c9fc71710b472909949"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a8b280a0167112c9fc71710b472909949">rotate3s</a> (<a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; k)</td></tr>
<tr class="memdesc:a8b280a0167112c9fc71710b472909949"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct 3x3 rotation matrix from spin vector via Rodrigues formula <br /></td></tr>
<tr class="separator:a8b280a0167112c9fc71710b472909949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c98840cff4a0b25d6bbf25541347483"><td class="memTemplParams" colspan="2"><a id="a9c98840cff4a0b25d6bbf25541347483"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9c98840cff4a0b25d6bbf25541347483"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 4, 4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a9c98840cff4a0b25d6bbf25541347483">rotate4</a> (const T &amp;A, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;a)</td></tr>
<tr class="memdesc:a9c98840cff4a0b25d6bbf25541347483"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct 4x4 rotation matrix from angle in degrees and axis <br /></td></tr>
<tr class="separator:a9c98840cff4a0b25d6bbf25541347483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce5b05bfe2bf1938ee5079ce7a532ad"><td class="memTemplParams" colspan="2"><a id="a4ce5b05bfe2bf1938ee5079ce7a532ad"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4ce5b05bfe2bf1938ee5079ce7a532ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 4, 4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a4ce5b05bfe2bf1938ee5079ce7a532ad">rotate4</a> (const T &amp;A, const T &amp;ax, const T &amp;ay, const T &amp;az)</td></tr>
<tr class="memdesc:a4ce5b05bfe2bf1938ee5079ce7a532ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct 4x4 rotation matrix from angle in degrees and axis <br /></td></tr>
<tr class="separator:a4ce5b05bfe2bf1938ee5079ce7a532ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb84edef7e25cd2273deee10844a2e0"><td class="memTemplParams" colspan="2"><a id="aecb84edef7e25cd2273deee10844a2e0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aecb84edef7e25cd2273deee10844a2e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 4, 4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#aecb84edef7e25cd2273deee10844a2e0">rotate4</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;A)</td></tr>
<tr class="memdesc:aecb84edef7e25cd2273deee10844a2e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct 4x4 rotation matrix from euler angles yaw, pitch and roll around axes y, x and z in degrees <br /></td></tr>
<tr class="separator:aecb84edef7e25cd2273deee10844a2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa613a9a726db935c3940720d5c824a08"><td class="memTemplParams" colspan="2"><a id="aa613a9a726db935c3940720d5c824a08"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa613a9a726db935c3940720d5c824a08"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 4, 4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#aa613a9a726db935c3940720d5c824a08">pose4</a> (const <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 4 &gt; &amp;M)</td></tr>
<tr class="memdesc:aa613a9a726db935c3940720d5c824a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct 4x4 pose matrix from a 3x4 matrix <br /></td></tr>
<tr class="separator:aa613a9a726db935c3940720d5c824a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf91d34b3e25ccdbee6d746d4e259876"><td class="memTemplParams" colspan="2"><a id="aaf91d34b3e25ccdbee6d746d4e259876"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaf91d34b3e25ccdbee6d746d4e259876"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 4, 4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#aaf91d34b3e25ccdbee6d746d4e259876">pose4</a> (const <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 3 &gt; &amp;R, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;t)</td></tr>
<tr class="memdesc:aaf91d34b3e25ccdbee6d746d4e259876"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct 4x4 pose matrix from a 3x3 rotation matrix and translation vector <br /></td></tr>
<tr class="separator:aaf91d34b3e25ccdbee6d746d4e259876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2ec1cb511265bca9e8b89f75c10f1c"><td class="memTemplParams" colspan="2"><a id="a6a2ec1cb511265bca9e8b89f75c10f1c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6a2ec1cb511265bca9e8b89f75c10f1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 4, 4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a6a2ec1cb511265bca9e8b89f75c10f1c">pose4</a> (const <a class="el" href="classcgv_1_1math_1_1quaternion.html">quaternion</a>&lt; T &gt; &amp;q, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;t)</td></tr>
<tr class="memdesc:a6a2ec1cb511265bca9e8b89f75c10f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct 4x4 pose matrix from quaternion and translation vector <br /></td></tr>
<tr class="separator:a6a2ec1cb511265bca9e8b89f75c10f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b587a38ce71938fc4bfe60c29e78d1"><td class="memTemplParams" colspan="2"><a id="a38b587a38ce71938fc4bfe60c29e78d1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a38b587a38ce71938fc4bfe60c29e78d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 4, 4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a38b587a38ce71938fc4bfe60c29e78d1">look_at4</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;eye, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;focus, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;view_up_dir)</td></tr>
<tr class="memdesc:a38b587a38ce71938fc4bfe60c29e78d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">return rigid body transformation that performs look at transformation <br /></td></tr>
<tr class="separator:a38b587a38ce71938fc4bfe60c29e78d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2977addf3435b7a68d37a81f8dff5a"><td class="memTemplParams" colspan="2"><a id="a2f2977addf3435b7a68d37a81f8dff5a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2f2977addf3435b7a68d37a81f8dff5a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 4, 4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a2f2977addf3435b7a68d37a81f8dff5a">ortho4</a> (const T &amp;l, const T &amp;r, const T &amp;b, const T &amp;t, const T &amp;n, const T &amp;f)</td></tr>
<tr class="memdesc:a2f2977addf3435b7a68d37a81f8dff5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct 4x4 frustum matrix for orthographic projection <br /></td></tr>
<tr class="separator:a2f2977addf3435b7a68d37a81f8dff5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae381c13fbc0bb0c638536e792d866f09"><td class="memTemplParams" colspan="2"><a id="ae381c13fbc0bb0c638536e792d866f09"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae381c13fbc0bb0c638536e792d866f09"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 4, 4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ae381c13fbc0bb0c638536e792d866f09">frustum4</a> (const T &amp;l, const T &amp;r, const T &amp;b, const T &amp;t, const T &amp;n, const T &amp;f)</td></tr>
<tr class="memdesc:ae381c13fbc0bb0c638536e792d866f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct 4x4 frustum matrix for perspective projection <br /></td></tr>
<tr class="separator:ae381c13fbc0bb0c638536e792d866f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b8bc7f4b44b25688a7d5fdca877615"><td class="memTemplParams" colspan="2"><a id="aa4b8bc7f4b44b25688a7d5fdca877615"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa4b8bc7f4b44b25688a7d5fdca877615"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 4, 4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#aa4b8bc7f4b44b25688a7d5fdca877615">perspective4</a> (const T &amp;fovy, const T &amp;aspect, const T &amp;zNear, const T &amp;zFar)</td></tr>
<tr class="memdesc:aa4b8bc7f4b44b25688a7d5fdca877615"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct 4x4 perspective frustum matrix <br /></td></tr>
<tr class="separator:aa4b8bc7f4b44b25688a7d5fdca877615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c53909db56a33ab337098bb7ca0c2f"><td class="memTemplParams" colspan="2"><a id="ae0c53909db56a33ab337098bb7ca0c2f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae0c53909db56a33ab337098bb7ca0c2f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ae0c53909db56a33ab337098bb7ca0c2f">znear_from_proj4</a> (const <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 4, 4 &gt; &amp;proj)</td></tr>
<tr class="memdesc:ae0c53909db56a33ab337098bb7ca0c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract distance of near clipping plane from a 4x4 projection matrix (ortho or perspective) <br /></td></tr>
<tr class="separator:ae0c53909db56a33ab337098bb7ca0c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11e57e9b8a4102f0a42cc5e679af49a"><td class="memTemplParams" colspan="2"><a id="ac11e57e9b8a4102f0a42cc5e679af49a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac11e57e9b8a4102f0a42cc5e679af49a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ac11e57e9b8a4102f0a42cc5e679af49a">zfar_from_proj4</a> (const <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 4, 4 &gt; &amp;proj)</td></tr>
<tr class="memdesc:ac11e57e9b8a4102f0a42cc5e679af49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract distance of far clipping plane from a 4x4 projection matrix (ortho or perspective) <br /></td></tr>
<tr class="separator:ac11e57e9b8a4102f0a42cc5e679af49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabcaa20776a303341d70e278f831476a"><td class="memTemplParams" colspan="2"><a id="aabcaa20776a303341d70e278f831476a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aabcaa20776a303341d70e278f831476a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#aabcaa20776a303341d70e278f831476a">znear_from_invproj4</a> (const <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 4, 4 &gt; &amp;invproj)</td></tr>
<tr class="memdesc:aabcaa20776a303341d70e278f831476a"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract distance of near clipping plane from given inverse of a 4x4 projection matrix (ortho or perspective) <br /></td></tr>
<tr class="separator:aabcaa20776a303341d70e278f831476a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a276e2f77d1b78f20cf6de8a259c9ac39"><td class="memTemplParams" colspan="2"><a id="a276e2f77d1b78f20cf6de8a259c9ac39"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a276e2f77d1b78f20cf6de8a259c9ac39"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a276e2f77d1b78f20cf6de8a259c9ac39">zfar_from_invproj4</a> (const <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 4, 4 &gt; &amp;invproj)</td></tr>
<tr class="memdesc:a276e2f77d1b78f20cf6de8a259c9ac39"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract distance of far clipping plane from given inverse of a 4x4 projection matrix (ortho or perspective) <br /></td></tr>
<tr class="separator:a276e2f77d1b78f20cf6de8a259c9ac39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c11c62abcb9193409cf5f0e68fb4078"><td class="memTemplParams" colspan="2"><a id="a4c11c62abcb9193409cf5f0e68fb4078"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4c11c62abcb9193409cf5f0e68fb4078"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 4, 4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a4c11c62abcb9193409cf5f0e68fb4078">stereo_frustum_screen4</a> (T eye, const T &amp;eyeSeparation, const T &amp;screenWidth, const T &amp;screenHeight, const T &amp;zZeroParallax, const T &amp;zNear, const T &amp;zFar)</td></tr>
<tr class="memdesc:a4c11c62abcb9193409cf5f0e68fb4078"><td class="mdescLeft">&#160;</td><td class="mdescRight">return perspective projection for given eye (from -1 ... left most to 1 ... right most) without translation <br /></td></tr>
<tr class="separator:a4c11c62abcb9193409cf5f0e68fb4078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de0abe17d1b99304d3a9a6730e38daa"><td class="memTemplParams" colspan="2"><a id="a2de0abe17d1b99304d3a9a6730e38daa"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2de0abe17d1b99304d3a9a6730e38daa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 4, 4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a2de0abe17d1b99304d3a9a6730e38daa">stereo_translate_screen4</a> (T eye, const T &amp;eyeSeparation, const T &amp;screenWidth)</td></tr>
<tr class="memdesc:a2de0abe17d1b99304d3a9a6730e38daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">return translation from center to eye (from -1 ... left most to 1 ... right most) <br /></td></tr>
<tr class="separator:a2de0abe17d1b99304d3a9a6730e38daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac291d8235a2630778bd7d5da6367b852"><td class="memTemplParams" colspan="2"><a id="ac291d8235a2630778bd7d5da6367b852"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac291d8235a2630778bd7d5da6367b852"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 4, 4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ac291d8235a2630778bd7d5da6367b852">stereo_translate4</a> (T eye, const T &amp;eyeSeparation, const T &amp;fovy, const T &amp;aspect, const T &amp;zZeroParallax)</td></tr>
<tr class="memdesc:ac291d8235a2630778bd7d5da6367b852"><td class="mdescLeft">&#160;</td><td class="mdescRight">return translation from center to eye (from -1 ... left most to 1 ... right most) <br /></td></tr>
<tr class="separator:ac291d8235a2630778bd7d5da6367b852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f519b6b051821618ea8772eb73ad8b"><td class="memTemplParams" colspan="2"><a id="ab7f519b6b051821618ea8772eb73ad8b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab7f519b6b051821618ea8772eb73ad8b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 4, 4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ab7f519b6b051821618ea8772eb73ad8b">stereo_perspective_screen4</a> (T eye, const T &amp;eyeSeparation, const T &amp;screenWidth, const T &amp;screenHeight, const T &amp;zZeroParallax, const T &amp;zNear, const T &amp;zFar)</td></tr>
<tr class="memdesc:ab7f519b6b051821618ea8772eb73ad8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return perspective projection for given eye (from -1 ... left most to 1 ... right most) including translation <br /></td></tr>
<tr class="separator:ab7f519b6b051821618ea8772eb73ad8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a3b7953da2b7fd6b7517eb8b617e4e"><td class="memTemplParams" colspan="2"><a id="ac9a3b7953da2b7fd6b7517eb8b617e4e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac9a3b7953da2b7fd6b7517eb8b617e4e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 4, 4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ac9a3b7953da2b7fd6b7517eb8b617e4e">stereo_perspective4</a> (T eye, const T &amp;eyeSeparation, const T &amp;fovy, const T &amp;aspect, const T &amp;zZeroParallax, const T &amp;zNear, const T &amp;zFar)</td></tr>
<tr class="memdesc:ac9a3b7953da2b7fd6b7517eb8b617e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">return perspective projection for given eye (from -1 ... left most to 1 ... right most) including translation <br /></td></tr>
<tr class="separator:ac9a3b7953da2b7fd6b7517eb8b617e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4a644a254ea830977b0d01fe93d91f"><td class="memItemLeft" align="right" valign="top"><a id="a2a4a644a254ea830977b0d01fe93d91f"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a2a4a644a254ea830977b0d01fe93d91f">compute_unit_ball_volume</a> (unsigned n)</td></tr>
<tr class="memdesc:a2a4a644a254ea830977b0d01fe93d91f"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute volume of unit n-ball living in n-dimensional space with n&gt;=1; results are cached for O(1) runtime <br /></td></tr>
<tr class="separator:a2a4a644a254ea830977b0d01fe93d91f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf9b277cd0690655f553db567b1c053"><td class="memItemLeft" align="right" valign="top"><a id="a1cf9b277cd0690655f553db567b1c053"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a1cf9b277cd0690655f553db567b1c053">compute_ball_volume</a> (unsigned n, double R)</td></tr>
<tr class="memdesc:a1cf9b277cd0690655f553db567b1c053"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute volume of n-ball of radius R living in n-dimensional space with n&gt;=1; results are cached for O(1) runtime <br /></td></tr>
<tr class="separator:a1cf9b277cd0690655f553db567b1c053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d907d9219c652396ff81057de4bae6"><td class="memItemLeft" align="right" valign="top"><a id="ad3d907d9219c652396ff81057de4bae6"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ad3d907d9219c652396ff81057de4bae6">compute_unit_sphere_area</a> (unsigned n)</td></tr>
<tr class="memdesc:ad3d907d9219c652396ff81057de4bae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute surface area of a unit n-ball living in n-dimensional space with n&gt;=2 (this is a n-1 dimensional area); results are cached for O(1) runtime <br /></td></tr>
<tr class="separator:ad3d907d9219c652396ff81057de4bae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4fd0c1095e3805f69c1f5df116ca00"><td class="memItemLeft" align="right" valign="top"><a id="acf4fd0c1095e3805f69c1f5df116ca00"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#acf4fd0c1095e3805f69c1f5df116ca00">compute_sphere_area</a> (unsigned n, double R)</td></tr>
<tr class="memdesc:acf4fd0c1095e3805f69c1f5df116ca00"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute surface area of a n-ball of radius R living in n-dimensional space with n&gt;=2 (this is a n-1 dimensional area); results are cached for O(1) runtime <br /></td></tr>
<tr class="separator:acf4fd0c1095e3805f69c1f5df116ca00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb93f97516015984f2581e7ff178b3f"><td class="memTemplParams" colspan="2"><a id="a2eb93f97516015984f2581e7ff178b3f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2eb93f97516015984f2581e7ff178b3f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a2eb93f97516015984f2581e7ff178b3f">sign</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:a2eb93f97516015984f2581e7ff178b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the abs(a)*sign(b) <br /></td></tr>
<tr class="separator:a2eb93f97516015984f2581e7ff178b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1233597e0b02a8451d874eae9aac6773"><td class="memTemplParams" colspan="2"><a id="a1233597e0b02a8451d874eae9aac6773"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1233597e0b02a8451d874eae9aac6773"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a1233597e0b02a8451d874eae9aac6773">step</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:a1233597e0b02a8451d874eae9aac6773"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns 0 for b &lt; a and 1 otherwise <br /></td></tr>
<tr class="separator:a1233597e0b02a8451d874eae9aac6773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa64c1694fe2203ab12c82d0ef202873f"><td class="memTemplParams" colspan="2"><a id="aa64c1694fe2203ab12c82d0ef202873f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa64c1694fe2203ab12c82d0ef202873f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#aa64c1694fe2203ab12c82d0ef202873f">sign</a> (const T &amp;v)</td></tr>
<tr class="memdesc:aa64c1694fe2203ab12c82d0ef202873f"><td class="mdescLeft">&#160;</td><td class="mdescRight">if v &gt;= 0 returns 1 and otherwise -1 <br /></td></tr>
<tr class="separator:aa64c1694fe2203ab12c82d0ef202873f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ad51a58298ebc80b25c9776e9245a9"><td class="memTemplParams" colspan="2"><a id="a83ad51a58298ebc80b25c9776e9245a9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a83ad51a58298ebc80b25c9776e9245a9"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a83ad51a58298ebc80b25c9776e9245a9">plus</a> (const T &amp;v)</td></tr>
<tr class="memdesc:a83ad51a58298ebc80b25c9776e9245a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">if v &gt;= 0 returns v or 0 otherwise <br /></td></tr>
<tr class="separator:a83ad51a58298ebc80b25c9776e9245a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d164d4a63cb11523ffbbcc5178fe2f2"><td class="memTemplParams" colspan="2"><a id="a6d164d4a63cb11523ffbbcc5178fe2f2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6d164d4a63cb11523ffbbcc5178fe2f2"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a6d164d4a63cb11523ffbbcc5178fe2f2">clamp</a> (const T &amp;v, const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:a6d164d4a63cb11523ffbbcc5178fe2f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">clamp v at [a,b] <br /></td></tr>
<tr class="separator:a6d164d4a63cb11523ffbbcc5178fe2f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109be23833f4f021174bc42277b3a128"><td class="memTemplParams" colspan="2"><a id="a109be23833f4f021174bc42277b3a128"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a109be23833f4f021174bc42277b3a128"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a109be23833f4f021174bc42277b3a128">saturate</a> (const T &amp;v)</td></tr>
<tr class="memdesc:a109be23833f4f021174bc42277b3a128"><td class="mdescLeft">&#160;</td><td class="mdescRight">clamp v at [0,1] <br /></td></tr>
<tr class="separator:a109be23833f4f021174bc42277b3a128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb25a0cc8f05736dfc198866a0d632a2"><td class="memTemplParams" colspan="2"><a id="acb25a0cc8f05736dfc198866a0d632a2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acb25a0cc8f05736dfc198866a0d632a2"><td class="memTemplItemLeft" align="right" valign="top">const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#acb25a0cc8f05736dfc198866a0d632a2">lerp</a> (const T &amp;a, const T &amp;b, T t)</td></tr>
<tr class="memdesc:acb25a0cc8f05736dfc198866a0d632a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">linear interpolate between a and b; returns (1-t)*a + t*b <br /></td></tr>
<tr class="separator:acb25a0cc8f05736dfc198866a0d632a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ae197bbc8387de9e4a9c304f0c840f"><td class="memTemplParams" colspan="2"><a id="ac2ae197bbc8387de9e4a9c304f0c840f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac2ae197bbc8387de9e4a9c304f0c840f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ac2ae197bbc8387de9e4a9c304f0c840f">map</a> (const T &amp;v, const T &amp;a, const T &amp;b, const T &amp;c, const T &amp;d)</td></tr>
<tr class="memdesc:ac2ae197bbc8387de9e4a9c304f0c840f"><td class="mdescLeft">&#160;</td><td class="mdescRight">map v from [a,b] to [c,d] <br /></td></tr>
<tr class="separator:ac2ae197bbc8387de9e4a9c304f0c840f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29647d32e032cc35e52b51591295ca60"><td class="memTemplParams" colspan="2"><a id="a29647d32e032cc35e52b51591295ca60"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a29647d32e032cc35e52b51591295ca60"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a29647d32e032cc35e52b51591295ca60">erf</a> (const T x)</td></tr>
<tr class="memdesc:a29647d32e032cc35e52b51591295ca60"><td class="mdescLeft">&#160;</td><td class="mdescRight">error function <br /></td></tr>
<tr class="separator:a29647d32e032cc35e52b51591295ca60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d3c0f788a80d7dd395ab7585f94ab97"><td class="memTemplParams" colspan="2"><a id="a0d3c0f788a80d7dd395ab7585f94ab97"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0d3c0f788a80d7dd395ab7585f94ab97"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a0d3c0f788a80d7dd395ab7585f94ab97">erfc</a> (const T x)</td></tr>
<tr class="memdesc:a0d3c0f788a80d7dd395ab7585f94ab97"><td class="mdescLeft">&#160;</td><td class="mdescRight">complementary error function <br /></td></tr>
<tr class="separator:a0d3c0f788a80d7dd395ab7585f94ab97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce1cee7f941d273e312febdc800adb6"><td class="memTemplParams" colspan="2"><a id="a4ce1cee7f941d273e312febdc800adb6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4ce1cee7f941d273e312febdc800adb6"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a4ce1cee7f941d273e312febdc800adb6">erfcx</a> (const T x)</td></tr>
<tr class="memdesc:a4ce1cee7f941d273e312febdc800adb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">scaled complementary error function <br /></td></tr>
<tr class="separator:a4ce1cee7f941d273e312febdc800adb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6333ed98afd5457f68b69cd20e69be0"><td class="memTemplParams" colspan="2"><a id="ad6333ed98afd5457f68b69cd20e69be0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad6333ed98afd5457f68b69cd20e69be0"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ad6333ed98afd5457f68b69cd20e69be0">erfc_inv</a> (const T p)</td></tr>
<tr class="memdesc:ad6333ed98afd5457f68b69cd20e69be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">inverse complementary error function <br /></td></tr>
<tr class="separator:ad6333ed98afd5457f68b69cd20e69be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94aee89324bc58017a87e0e4c91a36a7"><td class="memTemplParams" colspan="2"><a id="a94aee89324bc58017a87e0e4c91a36a7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a94aee89324bc58017a87e0e4c91a36a7"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a94aee89324bc58017a87e0e4c91a36a7">erf_inv</a> (const T p)</td></tr>
<tr class="memdesc:a94aee89324bc58017a87e0e4c91a36a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">inverse error function <br /></td></tr>
<tr class="separator:a94aee89324bc58017a87e0e4c91a36a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e38d3a09f964017cf36143d2d1f0a9"><td class="memTemplParams" colspan="2"><a id="ad4e38d3a09f964017cf36143d2d1f0a9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad4e38d3a09f964017cf36143d2d1f0a9"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ad4e38d3a09f964017cf36143d2d1f0a9">Phi</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ad4e38d3a09f964017cf36143d2d1f0a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate the cummulative normal distribution function <br /></td></tr>
<tr class="separator:ad4e38d3a09f964017cf36143d2d1f0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04435f4678d0f753e16f9617551ed2f9"><td class="memTemplParams" colspan="2"><a id="a04435f4678d0f753e16f9617551ed2f9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a04435f4678d0f753e16f9617551ed2f9"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a04435f4678d0f753e16f9617551ed2f9">inv_Phi</a> (const T &amp;p)</td></tr>
<tr class="memdesc:a04435f4678d0f753e16f9617551ed2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate the inverse of the error function Phi^(-1)(p), p=0..1 <br /></td></tr>
<tr class="separator:a04435f4678d0f753e16f9617551ed2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa52c4120248159499bc320aba339c5"><td class="memTemplParams" colspan="2"><a id="abfa52c4120248159499bc320aba339c5"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:abfa52c4120248159499bc320aba339c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#abfa52c4120248159499bc320aba339c5">normalize</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:abfa52c4120248159499bc320aba339c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">return normalized vector <br /></td></tr>
<tr class="separator:abfa52c4120248159499bc320aba339c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b11c05b0b93335aff82154c9cfd0a51"><td class="memTemplParams" colspan="2"><a id="a5b11c05b0b93335aff82154c9cfd0a51"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:a5b11c05b0b93335aff82154c9cfd0a51"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a5b11c05b0b93335aff82154c9cfd0a51">safe_normalize</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:a5b11c05b0b93335aff82154c9cfd0a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">return safely normalized vector <br /></td></tr>
<tr class="separator:a5b11c05b0b93335aff82154c9cfd0a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ddde9beff4b995998d2bb2d24b24ba"><td class="memTemplParams" colspan="2"><a id="ad5ddde9beff4b995998d2bb2d24b24ba"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:ad5ddde9beff4b995998d2bb2d24b24ba"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ad5ddde9beff4b995998d2bb2d24b24ba">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:ad5ddde9beff4b995998d2bb2d24b24ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">output of a vector <br /></td></tr>
<tr class="separator:ad5ddde9beff4b995998d2bb2d24b24ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6bd49e63d6ae0f26d04c577737eeb07"><td class="memTemplParams" colspan="2"><a id="ad6bd49e63d6ae0f26d04c577737eeb07"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:ad6bd49e63d6ae0f26d04c577737eeb07"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ad6bd49e63d6ae0f26d04c577737eeb07">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:ad6bd49e63d6ae0f26d04c577737eeb07"><td class="mdescLeft">&#160;</td><td class="mdescRight">input of a vector <br /></td></tr>
<tr class="separator:ad6bd49e63d6ae0f26d04c577737eeb07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6832e6ddef5feaddd97f2d9599acd42"><td class="memTemplParams" colspan="2"><a id="af6832e6ddef5feaddd97f2d9599acd42"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:af6832e6ddef5feaddd97f2d9599acd42"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#af6832e6ddef5feaddd97f2d9599acd42">to_string</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:af6832e6ddef5feaddd97f2d9599acd42"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector to string <br /></td></tr>
<tr class="separator:af6832e6ddef5feaddd97f2d9599acd42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1729f95111e5557914cca72aaa12a88"><td class="memTemplParams" colspan="2"><a id="ac1729f95111e5557914cca72aaa12a88"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:ac1729f95111e5557914cca72aaa12a88"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ac1729f95111e5557914cca72aaa12a88">from_string</a> (const std::string &amp;s, <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:ac1729f95111e5557914cca72aaa12a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector from string <br /></td></tr>
<tr class="separator:ac1729f95111e5557914cca72aaa12a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141d32ee8c12656a895f74788ceae9a9"><td class="memTemplParams" colspan="2"><a id="a141d32ee8c12656a895f74788ceae9a9"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:a141d32ee8c12656a895f74788ceae9a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a141d32ee8c12656a895f74788ceae9a9">operator*</a> (const T &amp;s, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:a141d32ee8c12656a895f74788ceae9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the product of a scalar s and vector v <br /></td></tr>
<tr class="separator:a141d32ee8c12656a895f74788ceae9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1c5592458b2b53ca2beb55636f23dd"><td class="memTemplParams" colspan="2"><a id="adb1c5592458b2b53ca2beb55636f23dd"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:adb1c5592458b2b53ca2beb55636f23dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#adb1c5592458b2b53ca2beb55636f23dd">operator/</a> (const T &amp;s, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:adb1c5592458b2b53ca2beb55636f23dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a vector containing the quotients of a scalar s with each component of v <br /></td></tr>
<tr class="separator:adb1c5592458b2b53ca2beb55636f23dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9371e75b15a6adc349b95b4e523c6a6"><td class="memTemplParams" colspan="2"><a id="ab9371e75b15a6adc349b95b4e523c6a6"></a>
template&lt;typename T , typename S , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:ab9371e75b15a6adc349b95b4e523c6a6"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ab9371e75b15a6adc349b95b4e523c6a6">dot</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; S, N &gt; &amp;w)</td></tr>
<tr class="memdesc:ab9371e75b15a6adc349b95b4e523c6a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the dot product of vector v and w <br /></td></tr>
<tr class="separator:ab9371e75b15a6adc349b95b4e523c6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651e46cb3504dc30dd03178f6a6062f8"><td class="memTemplParams" colspan="2"><a id="a651e46cb3504dc30dd03178f6a6062f8"></a>
template&lt;typename T , typename S , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:a651e46cb3504dc30dd03178f6a6062f8"><td class="memTemplItemLeft" align="right" valign="top">S&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a651e46cb3504dc30dd03178f6a6062f8">dot_pos</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; S, N+1 &gt; &amp;w)</td></tr>
<tr class="memdesc:a651e46cb3504dc30dd03178f6a6062f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the dot product of N-dimensional vector v and (N+1)-dimensional position vector w, implicitly homogenizing the first operand <br /></td></tr>
<tr class="separator:a651e46cb3504dc30dd03178f6a6062f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5de6ab07865b921e5e3b48a4ebccc4"><td class="memTemplParams" colspan="2"><a id="aca5de6ab07865b921e5e3b48a4ebccc4"></a>
template&lt;typename T , typename S , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:aca5de6ab07865b921e5e3b48a4ebccc4"><td class="memTemplItemLeft" align="right" valign="top">S&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#aca5de6ab07865b921e5e3b48a4ebccc4">dot_pos</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N+1 &gt; &amp;v, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; S, N &gt; &amp;w)</td></tr>
<tr class="memdesc:aca5de6ab07865b921e5e3b48a4ebccc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the dot product of (N+1)-dimensional vector v and N-dimensional position vector w, implicitly homogenizing the second operand <br /></td></tr>
<tr class="separator:aca5de6ab07865b921e5e3b48a4ebccc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94254cd737145b54c5af46755df85964"><td class="memTemplParams" colspan="2"><a id="a94254cd737145b54c5af46755df85964"></a>
template&lt;typename T , typename S , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:a94254cd737145b54c5af46755df85964"><td class="memTemplItemLeft" align="right" valign="top">S&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a94254cd737145b54c5af46755df85964">dot_dir</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; S, N+1 &gt; &amp;w)</td></tr>
<tr class="memdesc:a94254cd737145b54c5af46755df85964"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the dot product of N-dimensional vector v and (N+1)-dimensional direction vector w, implicitly homogenizing the first operand <br /></td></tr>
<tr class="separator:a94254cd737145b54c5af46755df85964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4170aac96f765f232fb262016e8aed36"><td class="memTemplParams" colspan="2"><a id="a4170aac96f765f232fb262016e8aed36"></a>
template&lt;typename T , typename S , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:a4170aac96f765f232fb262016e8aed36"><td class="memTemplItemLeft" align="right" valign="top">S&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a4170aac96f765f232fb262016e8aed36">dot_dir</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N+1 &gt; &amp;v, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; S, N &gt; &amp;w)</td></tr>
<tr class="memdesc:a4170aac96f765f232fb262016e8aed36"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the dot product of (N+1)-dimensional vector v and N-dimensional direction vector w, implicitly homogenizing the second operand <br /></td></tr>
<tr class="separator:a4170aac96f765f232fb262016e8aed36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319fcf5471db921fa80eedf62c03ff02"><td class="memTemplParams" colspan="2"><a id="a319fcf5471db921fa80eedf62c03ff02"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:a319fcf5471db921fa80eedf62c03ff02"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a319fcf5471db921fa80eedf62c03ff02">length</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:a319fcf5471db921fa80eedf62c03ff02"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the length of vector v <br /></td></tr>
<tr class="separator:a319fcf5471db921fa80eedf62c03ff02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff39c6d79c7591eda807d9a5b9e08995"><td class="memTemplParams" colspan="2"><a id="aff39c6d79c7591eda807d9a5b9e08995"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:aff39c6d79c7591eda807d9a5b9e08995"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#aff39c6d79c7591eda807d9a5b9e08995">sign</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:aff39c6d79c7591eda807d9a5b9e08995"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply sign function component wise to vector <br /></td></tr>
<tr class="separator:aff39c6d79c7591eda807d9a5b9e08995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5478867da553a6320dcaee47258a3169"><td class="memTemplParams" colspan="2"><a id="a5478867da553a6320dcaee47258a3169"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:a5478867da553a6320dcaee47258a3169"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a5478867da553a6320dcaee47258a3169">step</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;a, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;b)</td></tr>
<tr class="memdesc:a5478867da553a6320dcaee47258a3169"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply step function component wise to vector <br /></td></tr>
<tr class="separator:a5478867da553a6320dcaee47258a3169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096cb2f44ab3eef36e4fc867e5c2ab99"><td class="memTemplParams" colspan="2"><a id="a096cb2f44ab3eef36e4fc867e5c2ab99"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:a096cb2f44ab3eef36e4fc867e5c2ab99"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a096cb2f44ab3eef36e4fc867e5c2ab99">abs</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:a096cb2f44ab3eef36e4fc867e5c2ab99"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply abs function component wise to vector <br /></td></tr>
<tr class="separator:a096cb2f44ab3eef36e4fc867e5c2ab99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ed9709b6809a4e152a44897a27a6f4"><td class="memTemplParams" colspan="2"><a id="ac3ed9709b6809a4e152a44897a27a6f4"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:ac3ed9709b6809a4e152a44897a27a6f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ac3ed9709b6809a4e152a44897a27a6f4">round</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:ac3ed9709b6809a4e152a44897a27a6f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply round function component wise to vector <br /></td></tr>
<tr class="separator:ac3ed9709b6809a4e152a44897a27a6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4f53fc7cb7dbcb1fa07ec66d99915d"><td class="memTemplParams" colspan="2"><a id="a2a4f53fc7cb7dbcb1fa07ec66d99915d"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:a2a4f53fc7cb7dbcb1fa07ec66d99915d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a2a4f53fc7cb7dbcb1fa07ec66d99915d">floor</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:a2a4f53fc7cb7dbcb1fa07ec66d99915d"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply floor function component wise to vector <br /></td></tr>
<tr class="separator:a2a4f53fc7cb7dbcb1fa07ec66d99915d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bdfc685a508ef94145942bc61929185"><td class="memTemplParams" colspan="2"><a id="a7bdfc685a508ef94145942bc61929185"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:a7bdfc685a508ef94145942bc61929185"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a7bdfc685a508ef94145942bc61929185">ceil</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:a7bdfc685a508ef94145942bc61929185"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply ceil function component wise to vector <br /></td></tr>
<tr class="separator:a7bdfc685a508ef94145942bc61929185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98dec8fec76658745c64947ff97a0915"><td class="memTemplParams" colspan="2"><a id="a98dec8fec76658745c64947ff97a0915"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:a98dec8fec76658745c64947ff97a0915"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a98dec8fec76658745c64947ff97a0915">sqr_length</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:a98dec8fec76658745c64947ff97a0915"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the squared length of vector v <br /></td></tr>
<tr class="separator:a98dec8fec76658745c64947ff97a0915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c477a6a271f0ea40c265e5182c529e"><td class="memTemplParams" colspan="2"><a id="a43c477a6a271f0ea40c265e5182c529e"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:a43c477a6a271f0ea40c265e5182c529e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a43c477a6a271f0ea40c265e5182c529e">cross</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;w)</td></tr>
<tr class="memdesc:a43c477a6a271f0ea40c265e5182c529e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the cross product of vector v and w <br /></td></tr>
<tr class="separator:a43c477a6a271f0ea40c265e5182c529e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62eea7ce2b3664181282b42f3de50d8"><td class="memTemplParams" colspan="2"><a id="ac62eea7ce2b3664181282b42f3de50d8"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:ac62eea7ce2b3664181282b42f3de50d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N+1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ac62eea7ce2b3664181282b42f3de50d8">hom</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:ac62eea7ce2b3664181282b42f3de50d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the cross product of vector v and w <br /></td></tr>
<tr class="separator:ac62eea7ce2b3664181282b42f3de50d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021c54ae9938e48312e58ba9497336d5"><td class="memTemplParams" colspan="2"><a id="a021c54ae9938e48312e58ba9497336d5"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:a021c54ae9938e48312e58ba9497336d5"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a021c54ae9938e48312e58ba9497336d5">min_value</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:a021c54ae9938e48312e58ba9497336d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the minimal entry <br /></td></tr>
<tr class="separator:a021c54ae9938e48312e58ba9497336d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f32aff46cb5d2962caf1123ac1be20"><td class="memTemplParams" colspan="2"><a id="ab9f32aff46cb5d2962caf1123ac1be20"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:ab9f32aff46cb5d2962caf1123ac1be20"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ab9f32aff46cb5d2962caf1123ac1be20">min_index</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:ab9f32aff46cb5d2962caf1123ac1be20"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the index of the smallest value <br /></td></tr>
<tr class="separator:ab9f32aff46cb5d2962caf1123ac1be20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f496231d4b5519a815e6be9387f851"><td class="memTemplParams" colspan="2"><a id="a92f496231d4b5519a815e6be9387f851"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:a92f496231d4b5519a815e6be9387f851"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a92f496231d4b5519a815e6be9387f851">max_index</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:a92f496231d4b5519a815e6be9387f851"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the index of the largest entry <br /></td></tr>
<tr class="separator:a92f496231d4b5519a815e6be9387f851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f7f6756f02d9477d4522f74dfa0ff4"><td class="memTemplParams" colspan="2"><a id="a94f7f6756f02d9477d4522f74dfa0ff4"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:a94f7f6756f02d9477d4522f74dfa0ff4"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a94f7f6756f02d9477d4522f74dfa0ff4">max_value</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:a94f7f6756f02d9477d4522f74dfa0ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the value of the largest entry <br /></td></tr>
<tr class="separator:a94f7f6756f02d9477d4522f74dfa0ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423e76fe335225916db8a8252d744ebd"><td class="memTemplParams" colspan="2"><a id="a423e76fe335225916db8a8252d744ebd"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:a423e76fe335225916db8a8252d744ebd"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a423e76fe335225916db8a8252d744ebd">lerp</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v1, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v2, T t)</td></tr>
<tr class="memdesc:a423e76fe335225916db8a8252d744ebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">linear interpolation returns (1-t)*v1 + t*v2 <br /></td></tr>
<tr class="separator:a423e76fe335225916db8a8252d744ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a15c964f2bfaeea31c1021366354bd"><td class="memTemplParams" colspan="2"><a id="a54a15c964f2bfaeea31c1021366354bd"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:a54a15c964f2bfaeea31c1021366354bd"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a54a15c964f2bfaeea31c1021366354bd">lerp</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v1, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v2, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;t)</td></tr>
<tr class="memdesc:a54a15c964f2bfaeea31c1021366354bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">linear interpolation returns (1-t)*v1 + t*v2 <br /></td></tr>
<tr class="separator:a54a15c964f2bfaeea31c1021366354bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce04f60bc6efa4a280d7fa69cb3151b"><td class="memTemplParams" colspan="2"><a id="a9ce04f60bc6efa4a280d7fa69cb3151b"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:a9ce04f60bc6efa4a280d7fa69cb3151b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a9ce04f60bc6efa4a280d7fa69cb3151b">slerp</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v0, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v1, T t)</td></tr>
<tr class="memdesc:a9ce04f60bc6efa4a280d7fa69cb3151b"><td class="mdescLeft">&#160;</td><td class="mdescRight">spherical linear interpolation <br /></td></tr>
<tr class="separator:a9ce04f60bc6efa4a280d7fa69cb3151b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697846f47aa6a0026f5dc1b3f7be08e8"><td class="memTemplParams" colspan="2"><a id="a697846f47aa6a0026f5dc1b3f7be08e8"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:a697846f47aa6a0026f5dc1b3f7be08e8"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a697846f47aa6a0026f5dc1b3f7be08e8">min</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v, T t)</td></tr>
<tr class="memdesc:a697846f47aa6a0026f5dc1b3f7be08e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a vector containing the minimum value of each component of v and the scalar t <br /></td></tr>
<tr class="separator:a697846f47aa6a0026f5dc1b3f7be08e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58fb8914e970f885d44cbe7c7b15663b"><td class="memTemplParams" colspan="2"><a id="a58fb8914e970f885d44cbe7c7b15663b"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:a58fb8914e970f885d44cbe7c7b15663b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a58fb8914e970f885d44cbe7c7b15663b">min</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;t)</td></tr>
<tr class="memdesc:a58fb8914e970f885d44cbe7c7b15663b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a vector containing the component-wise minimum value <br /></td></tr>
<tr class="separator:a58fb8914e970f885d44cbe7c7b15663b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8b00db94a659bad5e3d273bb70de66"><td class="memTemplParams" colspan="2"><a id="a0c8b00db94a659bad5e3d273bb70de66"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:a0c8b00db94a659bad5e3d273bb70de66"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a0c8b00db94a659bad5e3d273bb70de66">max</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v, T t)</td></tr>
<tr class="memdesc:a0c8b00db94a659bad5e3d273bb70de66"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a vector containing the maximum value of each component of v and the scalar t <br /></td></tr>
<tr class="separator:a0c8b00db94a659bad5e3d273bb70de66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2121f9295313f6d737539f35046571"><td class="memTemplParams" colspan="2"><a id="adb2121f9295313f6d737539f35046571"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:adb2121f9295313f6d737539f35046571"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#adb2121f9295313f6d737539f35046571">max</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;t)</td></tr>
<tr class="memdesc:adb2121f9295313f6d737539f35046571"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a vector containing the component-wise maximum value <br /></td></tr>
<tr class="separator:adb2121f9295313f6d737539f35046571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e094e44d297876f7044cec4793f8da"><td class="memTemplParams" colspan="2"><a id="a14e094e44d297876f7044cec4793f8da"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:a14e094e44d297876f7044cec4793f8da"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a14e094e44d297876f7044cec4793f8da">clamp</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v, T l, T r)</td></tr>
<tr class="memdesc:a14e094e44d297876f7044cec4793f8da"><td class="mdescLeft">&#160;</td><td class="mdescRight">clamp the components to the given range <br /></td></tr>
<tr class="separator:a14e094e44d297876f7044cec4793f8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0007918c8ff8b1fb4b50857a9cf335a7"><td class="memTemplParams" colspan="2"><a id="a0007918c8ff8b1fb4b50857a9cf335a7"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:a0007918c8ff8b1fb4b50857a9cf335a7"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a0007918c8ff8b1fb4b50857a9cf335a7">clamp</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;vl, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;vr)</td></tr>
<tr class="memdesc:a0007918c8ff8b1fb4b50857a9cf335a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">clamp the components to the given range <br /></td></tr>
<tr class="separator:a0007918c8ff8b1fb4b50857a9cf335a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675dd131c6bf12085fcd7d676c1d0ee6"><td class="memTemplParams" colspan="2"><a id="a675dd131c6bf12085fcd7d676c1d0ee6"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:a675dd131c6bf12085fcd7d676c1d0ee6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a675dd131c6bf12085fcd7d676c1d0ee6">saturate</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:a675dd131c6bf12085fcd7d676c1d0ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">shortcut to clamp the components to [0,1] <br /></td></tr>
<tr class="separator:a675dd131c6bf12085fcd7d676c1d0ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41dd3e7ea6d0410abba813f0c6067b6"><td class="memTemplParams" colspan="2"><a id="ab41dd3e7ea6d0410abba813f0c6067b6"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:ab41dd3e7ea6d0410abba813f0c6067b6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ab41dd3e7ea6d0410abba813f0c6067b6">pow</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v, T e)</td></tr>
<tr class="memdesc:ab41dd3e7ea6d0410abba813f0c6067b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">pow function for fvec type <br /></td></tr>
<tr class="separator:ab41dd3e7ea6d0410abba813f0c6067b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8905e503619bb28d6234127a5d8b6a"><td class="memTemplParams" colspan="2"><a id="a5a8905e503619bb28d6234127a5d8b6a"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:a5a8905e503619bb28d6234127a5d8b6a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a5a8905e503619bb28d6234127a5d8b6a">pow</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;e)</td></tr>
<tr class="memdesc:a5a8905e503619bb28d6234127a5d8b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">pow function for fvec type <br /></td></tr>
<tr class="separator:a5a8905e503619bb28d6234127a5d8b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c72e72ef2bc54eaf28001e05518b23"><td class="memTemplParams" colspan="2"><a id="a72c72e72ef2bc54eaf28001e05518b23"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:a72c72e72ef2bc54eaf28001e05518b23"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a72c72e72ef2bc54eaf28001e05518b23">ortho</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, N &gt; &amp;v)=delete</td></tr>
<tr class="memdesc:a72c72e72ef2bc54eaf28001e05518b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an orthogonal vector to v (only defined for 2d and 3d case) <br /></td></tr>
<tr class="separator:a72c72e72ef2bc54eaf28001e05518b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d211a0f56ebfffb14bc900d8d9075c"><td class="memTemplParams" colspan="2"><a id="a08d211a0f56ebfffb14bc900d8d9075c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a08d211a0f56ebfffb14bc900d8d9075c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a08d211a0f56ebfffb14bc900d8d9075c">ortho</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 2 &gt; &amp;v)</td></tr>
<tr class="memdesc:a08d211a0f56ebfffb14bc900d8d9075c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an orthogonal vector to v <br /></td></tr>
<tr class="separator:a08d211a0f56ebfffb14bc900d8d9075c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae09866cba732f8e281ff52a735a9fb"><td class="memTemplParams" colspan="2"><a id="acae09866cba732f8e281ff52a735a9fb"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acae09866cba732f8e281ff52a735a9fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#acae09866cba732f8e281ff52a735a9fb">ortho</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;v)</td></tr>
<tr class="memdesc:acae09866cba732f8e281ff52a735a9fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an orthogonal vector to v <br /></td></tr>
<tr class="separator:acae09866cba732f8e281ff52a735a9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20031ad94f8b2a051428afe3a8ba59d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab20031ad94f8b2a051428afe3a8ba59d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ab20031ad94f8b2a051428afe3a8ba59d">gaussj</a> (<a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;a, <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:ab20031ad94f8b2a051428afe3a8ba59d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gauss-Jordan elimination (A*X=B) with full pivoting: The input matrix a is replaced by its inverse and the right hand side matrix b is replaced by ist corresponding solution matrix x.  <a href="namespacecgv_1_1math.html#ab20031ad94f8b2a051428afe3a8ba59d">More...</a><br /></td></tr>
<tr class="separator:ab20031ad94f8b2a051428afe3a8ba59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc42005ee85cb4bf30107636abfe7d6f"><td class="memTemplParams" colspan="2"><a id="afc42005ee85cb4bf30107636abfe7d6f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afc42005ee85cb4bf30107636abfe7d6f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#afc42005ee85cb4bf30107636abfe7d6f">gaussj</a> (<a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:afc42005ee85cb4bf30107636abfe7d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">inverts a matrix a using gauss jordan elimination returns false if a is singular a is replaced with its inverse <br /></td></tr>
<tr class="separator:afc42005ee85cb4bf30107636abfe7d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad952cb09accb18e3535e7aeb6c8a5957"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad952cb09accb18e3535e7aeb6c8a5957"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fvec.html">cgv::math::fvec</a>&lt; T, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ad952cb09accb18e3535e7aeb6c8a5957">rotate</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">cgv::math::fvec</a>&lt; T, 3 &gt; &amp;v, const <a class="el" href="classcgv_1_1math_1_1fvec.html">cgv::math::fvec</a>&lt; T, 3 &gt; &amp;n, T a)</td></tr>
<tr class="memdesc:ad952cb09accb18e3535e7aeb6c8a5957"><td class="mdescLeft">&#160;</td><td class="mdescRight">rotate vector v around axis n by angle a (given in radian)  <a href="namespacecgv_1_1math.html#ad952cb09accb18e3535e7aeb6c8a5957">More...</a><br /></td></tr>
<tr class="separator:ad952cb09accb18e3535e7aeb6c8a5957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d82df0891c707f07c81f85eb818690"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a06d82df0891c707f07c81f85eb818690"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a06d82df0891c707f07c81f85eb818690">compute_rotation_axis_and_angle_from_vector_pair</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">cgv::math::fvec</a>&lt; T, 3 &gt; &amp;v0, const <a class="el" href="classcgv_1_1math_1_1fvec.html">cgv::math::fvec</a>&lt; T, 3 &gt; &amp;v1, <a class="el" href="classcgv_1_1math_1_1fvec.html">cgv::math::fvec</a>&lt; T, 3 &gt; &amp;axis, T &amp;angle)</td></tr>
<tr class="memdesc:a06d82df0891c707f07c81f85eb818690"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute a rotation axis and a rotation angle in radian that rotates v0 onto v1.  <a href="namespacecgv_1_1math.html#a06d82df0891c707f07c81f85eb818690">More...</a><br /></td></tr>
<tr class="separator:a06d82df0891c707f07c81f85eb818690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a5bdaef42e636106d43ad1273d6534"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab5a5bdaef42e636106d43ad1273d6534"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ab5a5bdaef42e636106d43ad1273d6534">decompose_rotation_to_axis_and_angle</a> (const <a class="el" href="classcgv_1_1math_1_1fmat.html">cgv::math::fmat</a>&lt; T, 3, 3 &gt; &amp;R, <a class="el" href="classcgv_1_1math_1_1fvec.html">cgv::math::fvec</a>&lt; T, 3 &gt; &amp;axis, T &amp;angle)</td></tr>
<tr class="memdesc:ab5a5bdaef42e636106d43ad1273d6534"><td class="mdescLeft">&#160;</td><td class="mdescRight">decompose a rotation matrix into axis angle representation  <a href="namespacecgv_1_1math.html#ab5a5bdaef42e636106d43ad1273d6534">More...</a><br /></td></tr>
<tr class="separator:ab5a5bdaef42e636106d43ad1273d6534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae603218d7efcd704cd6e26a753aa1f98"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae603218d7efcd704cd6e26a753aa1f98"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">cgv::math::fmat</a>&lt; T, 3, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ae603218d7efcd704cd6e26a753aa1f98">build_orthogonal_frame</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">cgv::math::fvec</a>&lt; T, 3 &gt; &amp;v0, const <a class="el" href="classcgv_1_1math_1_1fvec.html">cgv::math::fvec</a>&lt; T, 3 &gt; &amp;v1)</td></tr>
<tr class="memdesc:ae603218d7efcd704cd6e26a753aa1f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two vectors v0 and v1 extend to orthonormal frame and return 3x3 matrix containing frame vectors in the columns.  <a href="namespacecgv_1_1math.html#ae603218d7efcd704cd6e26a753aa1f98">More...</a><br /></td></tr>
<tr class="separator:ae603218d7efcd704cd6e26a753aa1f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0233918261c3cf7f8a433e3e6511f10"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad0233918261c3cf7f8a433e3e6511f10"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ad0233918261c3cf7f8a433e3e6511f10">ray_box_intersection</a> (const <a class="el" href="classcgv_1_1math_1_1ray.html">ray</a>&lt; T, 3 &gt; &amp;<a class="el" href="classcgv_1_1math_1_1ray.html">ray</a>, <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; extent, <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 2 &gt; &amp;out_ts, <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; *out_normal=nullptr)</td></tr>
<tr class="memdesc:ad0233918261c3cf7f8a433e3e6511f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the intersection between a ray and axis aligned box located at the origin and returns the number of intersections.  <a href="namespacecgv_1_1math.html#ad0233918261c3cf7f8a433e3e6511f10">More...</a><br /></td></tr>
<tr class="separator:ad0233918261c3cf7f8a433e3e6511f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab082b1f85d6c8a0223d62a0d5491da15"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab082b1f85d6c8a0223d62a0d5491da15"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ab082b1f85d6c8a0223d62a0d5491da15">ray_box_intersection</a> (const <a class="el" href="classcgv_1_1math_1_1ray.html">ray</a>&lt; T, 3 &gt; &amp;<a class="el" href="classcgv_1_1math_1_1ray.html">ray</a>, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;<a class="el" href="namespacecgv_1_1math.html#a697846f47aa6a0026f5dc1b3f7be08e8">min</a>, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;<a class="el" href="namespacecgv_1_1math.html#a0c8b00db94a659bad5e3d273bb70de66">max</a>, <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 2 &gt; &amp;out_ts)</td></tr>
<tr class="memdesc:ab082b1f85d6c8a0223d62a0d5491da15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the intersection between a ray and axis aligned box and returns the number of intersections.  <a href="namespacecgv_1_1math.html#ab082b1f85d6c8a0223d62a0d5491da15">More...</a><br /></td></tr>
<tr class="separator:ab082b1f85d6c8a0223d62a0d5491da15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb95bc20c76e28a4f330fbc4459cb5b1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acb95bc20c76e28a4f330fbc4459cb5b1"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#acb95bc20c76e28a4f330fbc4459cb5b1">ray_cylinder_intersection</a> (const <a class="el" href="classcgv_1_1math_1_1ray.html">ray</a>&lt; T, 3 &gt; &amp;<a class="el" href="classcgv_1_1math_1_1ray.html">ray</a>, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;position, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;axis, T radius, T &amp;out_t, <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; *out_normal=nullptr)</td></tr>
<tr class="memdesc:acb95bc20c76e28a4f330fbc4459cb5b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the intersection between a ray and oriented cylinder defined by base center and axis and returns the number of intersections.  <a href="namespacecgv_1_1math.html#acb95bc20c76e28a4f330fbc4459cb5b1">More...</a><br /></td></tr>
<tr class="separator:acb95bc20c76e28a4f330fbc4459cb5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b29101809f91572afdfb3349c7fa943"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0b29101809f91572afdfb3349c7fa943"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a0b29101809f91572afdfb3349c7fa943">ray_cylinder_intersection2</a> (const <a class="el" href="classcgv_1_1math_1_1ray.html">ray</a>&lt; T, 3 &gt; &amp;<a class="el" href="classcgv_1_1math_1_1ray.html">ray</a>, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;start_position, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;end_position, T radius, T &amp;out_t, <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; *out_normal=nullptr)</td></tr>
<tr class="memdesc:a0b29101809f91572afdfb3349c7fa943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the intersection between a ray and oriented cylinder defined by start and end position and returns the number of intersections.  <a href="namespacecgv_1_1math.html#a0b29101809f91572afdfb3349c7fa943">More...</a><br /></td></tr>
<tr class="separator:a0b29101809f91572afdfb3349c7fa943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac940672f781e5135fdde91c8e1ac3043"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac940672f781e5135fdde91c8e1ac3043"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ac940672f781e5135fdde91c8e1ac3043">ray_plane_intersection</a> (const <a class="el" href="classcgv_1_1math_1_1ray.html">ray</a>&lt; T, 3 &gt; &amp;<a class="el" href="classcgv_1_1math_1_1ray.html">ray</a>, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;origin, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;normal, T &amp;out_t)</td></tr>
<tr class="memdesc:ac940672f781e5135fdde91c8e1ac3043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the intersection between a ray and infinite plane and returns the number of intersections.  <a href="namespacecgv_1_1math.html#ac940672f781e5135fdde91c8e1ac3043">More...</a><br /></td></tr>
<tr class="separator:ac940672f781e5135fdde91c8e1ac3043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9d4d1815a621c4a3b7d3632671d524"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2b9d4d1815a621c4a3b7d3632671d524"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a2b9d4d1815a621c4a3b7d3632671d524">ray_sphere_intersection</a> (const <a class="el" href="classcgv_1_1math_1_1ray.html">ray</a>&lt; T, 3 &gt; &amp;<a class="el" href="classcgv_1_1math_1_1ray.html">ray</a>, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;center, T radius, <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 2 &gt; &amp;out_ts)</td></tr>
<tr class="memdesc:a2b9d4d1815a621c4a3b7d3632671d524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the intersection between a ray and sphere and returns the number of intersections.  <a href="namespacecgv_1_1math.html#a2b9d4d1815a621c4a3b7d3632671d524">More...</a><br /></td></tr>
<tr class="separator:a2b9d4d1815a621c4a3b7d3632671d524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094390494484e1f786fe835c1820d630"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a094390494484e1f786fe835c1820d630"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a094390494484e1f786fe835c1820d630">first_ray_sphere_intersection</a> (const <a class="el" href="classcgv_1_1math_1_1ray.html">ray</a>&lt; T, 3 &gt; &amp;<a class="el" href="classcgv_1_1math_1_1ray.html">ray</a>, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;center, T radius, T &amp;out_t, <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; *out_normal=nullptr)</td></tr>
<tr class="memdesc:a094390494484e1f786fe835c1820d630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the first intersection between a ray and sphere and returns the number of intersections.  <a href="namespacecgv_1_1math.html#a094390494484e1f786fe835c1820d630">More...</a><br /></td></tr>
<tr class="separator:a094390494484e1f786fe835c1820d630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d772c970e1107e36343bb3caf57165"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab2d772c970e1107e36343bb3caf57165"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ab2d772c970e1107e36343bb3caf57165">ray_torus_intersection</a> (const <a class="el" href="classcgv_1_1math_1_1ray.html">ray</a>&lt; T, 3 &gt; &amp;<a class="el" href="classcgv_1_1math_1_1ray.html">ray</a>, T large_radius, T small_radius, T &amp;out_t, <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; *out_normal=nullptr)</td></tr>
<tr class="memdesc:ab2d772c970e1107e36343bb3caf57165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the intersection between a ray and axis aligned torus with medial axis equal to the y-axis and returns the number of intersections.  <a href="namespacecgv_1_1math.html#ab2d772c970e1107e36343bb3caf57165">More...</a><br /></td></tr>
<tr class="separator:ab2d772c970e1107e36343bb3caf57165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ddd4907f3139db3c3a62b74202d3241"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7ddd4907f3139db3c3a62b74202d3241"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a7ddd4907f3139db3c3a62b74202d3241">ray_torus_intersection</a> (const <a class="el" href="classcgv_1_1math_1_1ray.html">ray</a>&lt; T, 3 &gt; &amp;<a class="el" href="classcgv_1_1math_1_1ray.html">ray</a>, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;center, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;normal, T large_radius, T small_radius, T &amp;out_t, <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; *out_normal=nullptr)</td></tr>
<tr class="memdesc:a7ddd4907f3139db3c3a62b74202d3241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the intersection between a ray and oriented torus defined by origin and medial axis and returns the number of intersections.  <a href="namespacecgv_1_1math.html#a7ddd4907f3139db3c3a62b74202d3241">More...</a><br /></td></tr>
<tr class="separator:a7ddd4907f3139db3c3a62b74202d3241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad173e82d952d395213d5ab62378e79d8"><td class="memTemplParams" colspan="2"><a id="ad173e82d952d395213d5ab62378e79d8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad173e82d952d395213d5ab62378e79d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcgv_1_1math_1_1diag__mat.html">diag_mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ad173e82d952d395213d5ab62378e79d8">inv</a> (const <a class="el" href="structcgv_1_1math_1_1diag__mat.html">diag_mat</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:ad173e82d952d395213d5ab62378e79d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the inverse of a diagonal matrix <br /></td></tr>
<tr class="separator:ad173e82d952d395213d5ab62378e79d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a510fb2781dd399ed8909750064b7a776"><td class="memTemplParams" colspan="2"><a id="a510fb2781dd399ed8909750064b7a776"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a510fb2781dd399ed8909750064b7a776"><td class="memTemplItemLeft" align="right" valign="top">low_tri_mat&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a510fb2781dd399ed8909750064b7a776">inv</a> (const low_tri_mat&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a510fb2781dd399ed8909750064b7a776"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the inverse of a lower triangular matrix <br /></td></tr>
<tr class="separator:a510fb2781dd399ed8909750064b7a776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ccbbbd55e7593c14d4075b3bdfc34c1"><td class="memTemplParams" colspan="2"><a id="a2ccbbbd55e7593c14d4075b3bdfc34c1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2ccbbbd55e7593c14d4075b3bdfc34c1"><td class="memTemplItemLeft" align="right" valign="top">up_tri_mat&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a2ccbbbd55e7593c14d4075b3bdfc34c1">inv</a> (const up_tri_mat&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a2ccbbbd55e7593c14d4075b3bdfc34c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the inverse of an upper triangular matrix <br /></td></tr>
<tr class="separator:a2ccbbbd55e7593c14d4075b3bdfc34c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfec9e29cee38fc3706d844f9e098213"><td class="memTemplParams" colspan="2"><a id="abfec9e29cee38fc3706d844f9e098213"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abfec9e29cee38fc3706d844f9e098213"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#abfec9e29cee38fc3706d844f9e098213">inv</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:abfec9e29cee38fc3706d844f9e098213"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the inverse of a square matrix <br /></td></tr>
<tr class="separator:abfec9e29cee38fc3706d844f9e098213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1403236221a1a8c6f566ac7cd9732fc5"><td class="memTemplParams" colspan="2"><a id="a1403236221a1a8c6f566ac7cd9732fc5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1403236221a1a8c6f566ac7cd9732fc5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a1403236221a1a8c6f566ac7cd9732fc5">inv_22</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a1403236221a1a8c6f566ac7cd9732fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute inverse of 2x2 matrix <br /></td></tr>
<tr class="separator:a1403236221a1a8c6f566ac7cd9732fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504b47389f53413b2111f2c61865e37e"><td class="memTemplParams" colspan="2"><a id="a504b47389f53413b2111f2c61865e37e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a504b47389f53413b2111f2c61865e37e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a504b47389f53413b2111f2c61865e37e">inv_33</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a504b47389f53413b2111f2c61865e37e"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute inverse of 3x3 matrix <br /></td></tr>
<tr class="separator:a504b47389f53413b2111f2c61865e37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93cc7e82440bc8dce27ae800781acb33"><td class="memTemplParams" colspan="2"><a id="a93cc7e82440bc8dce27ae800781acb33"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a93cc7e82440bc8dce27ae800781acb33"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a93cc7e82440bc8dce27ae800781acb33">inv_44</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a93cc7e82440bc8dce27ae800781acb33"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute inverse of 4x4 matrix <br /></td></tr>
<tr class="separator:a93cc7e82440bc8dce27ae800781acb33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8b6263fc4a8cb8b31dc4ad2e0a81b5"><td class="memTemplParams" colspan="2"><a id="a1f8b6263fc4a8cb8b31dc4ad2e0a81b5"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:a1f8b6263fc4a8cb8b31dc4ad2e0a81b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, N, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a1f8b6263fc4a8cb8b31dc4ad2e0a81b5">inv</a> (const <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, N, N &gt; &amp;m)</td></tr>
<tr class="memdesc:a1f8b6263fc4a8cb8b31dc4ad2e0a81b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the inverse of a square matrix <br /></td></tr>
<tr class="separator:a1f8b6263fc4a8cb8b31dc4ad2e0a81b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6eef0ccd4c6d87c8d24d2abc58b4a3"><td class="memTemplParams" colspan="2"><a id="afe6eef0ccd4c6d87c8d24d2abc58b4a3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afe6eef0ccd4c6d87c8d24d2abc58b4a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 2, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#afe6eef0ccd4c6d87c8d24d2abc58b4a3">inv</a> (const <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 2, 2 &gt; &amp;m)</td></tr>
<tr class="memdesc:afe6eef0ccd4c6d87c8d24d2abc58b4a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute inverse of 2x2 matrix <br /></td></tr>
<tr class="separator:afe6eef0ccd4c6d87c8d24d2abc58b4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab544c23aa7baf1ec36a82e91de35e22c"><td class="memTemplParams" colspan="2"><a id="ab544c23aa7baf1ec36a82e91de35e22c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab544c23aa7baf1ec36a82e91de35e22c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ab544c23aa7baf1ec36a82e91de35e22c">inv</a> (const <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 3 &gt; &amp;m)</td></tr>
<tr class="memdesc:ab544c23aa7baf1ec36a82e91de35e22c"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute inverse of 3x3 matrix <br /></td></tr>
<tr class="separator:ab544c23aa7baf1ec36a82e91de35e22c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b359b3b0a2cff5054f1e4f0aa73c57d"><td class="memTemplParams" colspan="2"><a id="a1b359b3b0a2cff5054f1e4f0aa73c57d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1b359b3b0a2cff5054f1e4f0aa73c57d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 4, 4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a1b359b3b0a2cff5054f1e4f0aa73c57d">inv</a> (const <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 4, 4 &gt; &amp;m)</td></tr>
<tr class="memdesc:a1b359b3b0a2cff5054f1e4f0aa73c57d"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute inverse of 4x4 matrix <br /></td></tr>
<tr class="separator:a1b359b3b0a2cff5054f1e4f0aa73c57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627d83610f33d7bbff7d122e789aef12"><td class="memTemplParams" colspan="2"><a id="a627d83610f33d7bbff7d122e789aef12"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a627d83610f33d7bbff7d122e789aef12"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a627d83610f33d7bbff7d122e789aef12">solve</a> (const up_tri_mat&lt; T &gt; &amp;a, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;b, <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a627d83610f33d7bbff7d122e789aef12"><td class="mdescLeft">&#160;</td><td class="mdescRight">solves linear system ax=b a is an upper triangular matrix <br /></td></tr>
<tr class="separator:a627d83610f33d7bbff7d122e789aef12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bda1596ebd16a5de9f634a723a7f9df"><td class="memTemplParams" colspan="2"><a id="a0bda1596ebd16a5de9f634a723a7f9df"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0bda1596ebd16a5de9f634a723a7f9df"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a0bda1596ebd16a5de9f634a723a7f9df">solve</a> (const up_tri_mat&lt; T &gt; &amp;a, const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;b, <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a0bda1596ebd16a5de9f634a723a7f9df"><td class="mdescLeft">&#160;</td><td class="mdescRight">solves multiple linear systems ax=b a is an upper triangular matrix x is the matrix of solution vectors (columns) b is the matrix of right-hand sides (columns) <br /></td></tr>
<tr class="separator:a0bda1596ebd16a5de9f634a723a7f9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e78544b79524eecd69073952b0482f"><td class="memTemplParams" colspan="2"><a id="ad2e78544b79524eecd69073952b0482f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad2e78544b79524eecd69073952b0482f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ad2e78544b79524eecd69073952b0482f">solve</a> (const low_tri_mat&lt; T &gt; &amp;a, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;b, <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:ad2e78544b79524eecd69073952b0482f"><td class="mdescLeft">&#160;</td><td class="mdescRight">solves linear system ax=b a is a lower triangular matrix <br /></td></tr>
<tr class="separator:ad2e78544b79524eecd69073952b0482f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296626461f44b387652e79b84cba2457"><td class="memTemplParams" colspan="2"><a id="a296626461f44b387652e79b84cba2457"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a296626461f44b387652e79b84cba2457"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a296626461f44b387652e79b84cba2457">solve</a> (const low_tri_mat&lt; T &gt; &amp;a, const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;b, <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a296626461f44b387652e79b84cba2457"><td class="mdescLeft">&#160;</td><td class="mdescRight">solves multiple linear systems ax=b a is a lower triangular matrix x is the matrix of solution vectors (columns) b is the matrix of right-hand sides (columns) <br /></td></tr>
<tr class="separator:a296626461f44b387652e79b84cba2457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c0b1e4eef5446ab6a31bb7e568a301"><td class="memTemplParams" colspan="2"><a id="a14c0b1e4eef5446ab6a31bb7e568a301"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a14c0b1e4eef5446ab6a31bb7e568a301"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a14c0b1e4eef5446ab6a31bb7e568a301">solve</a> (const <a class="el" href="structcgv_1_1math_1_1diag__mat.html">diag_mat</a>&lt; T &gt; &amp;a, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;b, <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a14c0b1e4eef5446ab6a31bb7e568a301"><td class="mdescLeft">&#160;</td><td class="mdescRight">solves linear system ax=b a is a diagonal matrix <br /></td></tr>
<tr class="separator:a14c0b1e4eef5446ab6a31bb7e568a301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1751b115b38d5f2219959166602e39"><td class="memTemplParams" colspan="2"><a id="afa1751b115b38d5f2219959166602e39"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afa1751b115b38d5f2219959166602e39"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#afa1751b115b38d5f2219959166602e39">solve</a> (const <a class="el" href="classcgv_1_1math_1_1tri__diag__mat.html">tri_diag_mat</a>&lt; T &gt; &amp;a, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;b, <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:afa1751b115b38d5f2219959166602e39"><td class="mdescLeft">&#160;</td><td class="mdescRight">solves linear system ax=b a is a tri diagonal matrix <br /></td></tr>
<tr class="separator:afa1751b115b38d5f2219959166602e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944f8054ed5b163753b2be3da53535d4"><td class="memTemplParams" colspan="2"><a id="a944f8054ed5b163753b2be3da53535d4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a944f8054ed5b163753b2be3da53535d4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a944f8054ed5b163753b2be3da53535d4">solve</a> (const <a class="el" href="structcgv_1_1math_1_1diag__mat.html">diag_mat</a>&lt; T &gt; &amp;a, const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;b, <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a944f8054ed5b163753b2be3da53535d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">solves multiple linear systems ax=b a is a diagonal matrix x is the matrix of solution vectors (columns) b is the matrix of right-hand sides (columns) <br /></td></tr>
<tr class="separator:a944f8054ed5b163753b2be3da53535d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8063281c4be8efe218d82682385a62"><td class="memTemplParams" colspan="2"><a id="a0e8063281c4be8efe218d82682385a62"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0e8063281c4be8efe218d82682385a62"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a0e8063281c4be8efe218d82682385a62">solve</a> (const <a class="el" href="structcgv_1_1math_1_1perm__mat.html">perm_mat</a> &amp;a, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;b, <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a0e8063281c4be8efe218d82682385a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">solves linear system ax=b a is a permutation matrix <br /></td></tr>
<tr class="separator:a0e8063281c4be8efe218d82682385a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a0d8e1da5521d3dbcad991e8f20649"><td class="memTemplParams" colspan="2"><a id="a28a0d8e1da5521d3dbcad991e8f20649"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a28a0d8e1da5521d3dbcad991e8f20649"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a28a0d8e1da5521d3dbcad991e8f20649">solve</a> (const <a class="el" href="structcgv_1_1math_1_1perm__mat.html">perm_mat</a> &amp;a, const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;b, <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a28a0d8e1da5521d3dbcad991e8f20649"><td class="mdescLeft">&#160;</td><td class="mdescRight">solves multiple linear systems ax=b a is permutation matrix x is the matrix of solution vectors (columns) b is the matrix of right-hand sides (columns) <br /></td></tr>
<tr class="separator:a28a0d8e1da5521d3dbcad991e8f20649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51224bf488aae401d2056c703e4ac56a"><td class="memTemplParams" colspan="2"><a id="a51224bf488aae401d2056c703e4ac56a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a51224bf488aae401d2056c703e4ac56a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a51224bf488aae401d2056c703e4ac56a">lu_solve</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;a, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;b, <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a51224bf488aae401d2056c703e4ac56a"><td class="mdescLeft">&#160;</td><td class="mdescRight">solve ax=b with lu decomposition a is a full storage matrix <br /></td></tr>
<tr class="separator:a51224bf488aae401d2056c703e4ac56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4191d37dabc43d6cbc7e5da4dc8f3edd"><td class="memTemplParams" colspan="2"><a id="a4191d37dabc43d6cbc7e5da4dc8f3edd"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4191d37dabc43d6cbc7e5da4dc8f3edd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a4191d37dabc43d6cbc7e5da4dc8f3edd">solve</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;a, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;b, <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a4191d37dabc43d6cbc7e5da4dc8f3edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">solve ax=b, standard solver for full storage matrix is lu_solve a is a full storage matrix <br /></td></tr>
<tr class="separator:a4191d37dabc43d6cbc7e5da4dc8f3edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667e247eda3efd7411015db02d15a111"><td class="memTemplParams" colspan="2"><a id="a667e247eda3efd7411015db02d15a111"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a667e247eda3efd7411015db02d15a111"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a667e247eda3efd7411015db02d15a111">lu_solve</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;a, const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;b, <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a667e247eda3efd7411015db02d15a111"><td class="mdescLeft">&#160;</td><td class="mdescRight">solves multiple linear systems ax=b a is full storage matrix x is the matrix of solution vectors (columns) b is the matrix of right-hand sides (columns) <br /></td></tr>
<tr class="separator:a667e247eda3efd7411015db02d15a111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f874a4044596e0d7f8c4e77e59f4fb"><td class="memTemplParams" colspan="2"><a id="af1f874a4044596e0d7f8c4e77e59f4fb"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af1f874a4044596e0d7f8c4e77e59f4fb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#af1f874a4044596e0d7f8c4e77e59f4fb">solve</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;a, const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;b, <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:af1f874a4044596e0d7f8c4e77e59f4fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">solves multiple linear systems ax=b with the svd solver a is full storage matrix x is the matrix of solution vectors (columns) b is the matrix of right-hand sides (columns) <br /></td></tr>
<tr class="separator:af1f874a4044596e0d7f8c4e77e59f4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36ab77a746697862a6c5887fb985b60"><td class="memTemplParams" colspan="2"><a id="af36ab77a746697862a6c5887fb985b60"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af36ab77a746697862a6c5887fb985b60"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#af36ab77a746697862a6c5887fb985b60">qr_solve</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;a, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;b, <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:af36ab77a746697862a6c5887fb985b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">solve ax=b with qr decomposition <br /></td></tr>
<tr class="separator:af36ab77a746697862a6c5887fb985b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39153e84c1ba0d7cd907ea31a1897f0b"><td class="memTemplParams" colspan="2"><a id="a39153e84c1ba0d7cd907ea31a1897f0b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a39153e84c1ba0d7cd907ea31a1897f0b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a39153e84c1ba0d7cd907ea31a1897f0b">qr_solve</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;a, const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;b, <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a39153e84c1ba0d7cd907ea31a1897f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">solves multiple linear systems ax=b with qr solver a is full storage matrix x is the matrix of solution vectors (columns) b is the matrix of right-hand sides (columns) <br /></td></tr>
<tr class="separator:a39153e84c1ba0d7cd907ea31a1897f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dbdf6fbf49a08e616601b2ac1a7895b"><td class="memTemplParams" colspan="2"><a id="a5dbdf6fbf49a08e616601b2ac1a7895b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5dbdf6fbf49a08e616601b2ac1a7895b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a5dbdf6fbf49a08e616601b2ac1a7895b">svd_solve</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;a, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;b, <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a5dbdf6fbf49a08e616601b2ac1a7895b"><td class="mdescLeft">&#160;</td><td class="mdescRight">solve ax=b with svd decomposition <br /></td></tr>
<tr class="separator:a5dbdf6fbf49a08e616601b2ac1a7895b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c3d68b3185b9031190ee28d1b627dc"><td class="memTemplParams" colspan="2"><a id="ab3c3d68b3185b9031190ee28d1b627dc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab3c3d68b3185b9031190ee28d1b627dc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ab3c3d68b3185b9031190ee28d1b627dc">svd_solve</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;a, const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;b, <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:ab3c3d68b3185b9031190ee28d1b627dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">solve ax=b with svd decomposition <br /></td></tr>
<tr class="separator:ab3c3d68b3185b9031190ee28d1b627dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ef4f4081f46949400e12412536d4ff"><td class="memTemplParams" colspan="2"><a id="a58ef4f4081f46949400e12412536d4ff"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a58ef4f4081f46949400e12412536d4ff"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a58ef4f4081f46949400e12412536d4ff">operator&lt;&lt;</a> (std::ostream &amp;out, const low_tri_mat&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a58ef4f4081f46949400e12412536d4ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">output of a lower triangular matrix onto an ostream <br /></td></tr>
<tr class="separator:a58ef4f4081f46949400e12412536d4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e136f0e04d838c812480264371ed1be"><td class="memTemplParams" colspan="2"><a id="a1e136f0e04d838c812480264371ed1be"></a>
template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:a1e136f0e04d838c812480264371ed1be"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a1e136f0e04d838c812480264371ed1be">operator*</a> (const low_tri_mat&lt; T &gt; &amp;m1, const low_tri_mat&lt; S &gt; &amp;m2)</td></tr>
<tr class="memdesc:a1e136f0e04d838c812480264371ed1be"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplication of two lower triangular matrices <br /></td></tr>
<tr class="separator:a1e136f0e04d838c812480264371ed1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb40b8cf269e19d2dd02c8e5d7f2605"><td class="memTemplParams" colspan="2"><a id="abbb40b8cf269e19d2dd02c8e5d7f2605"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abbb40b8cf269e19d2dd02c8e5d7f2605"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#abbb40b8cf269e19d2dd02c8e5d7f2605">lu</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;a, <a class="el" href="structcgv_1_1math_1_1perm__mat.html">perm_mat</a> &amp;p, low_tri_mat&lt; T &gt; &amp;l, up_tri_mat&lt; T &gt; &amp;u)</td></tr>
<tr class="memdesc:abbb40b8cf269e19d2dd02c8e5d7f2605"><td class="mdescLeft">&#160;</td><td class="mdescRight">(P)LU decomposition of a matrix returns false if matrix is singular otherwise a = p*l*u <br /></td></tr>
<tr class="separator:abbb40b8cf269e19d2dd02c8e5d7f2605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dff5987034becd48b49ff280d63b8fe"><td class="memTemplParams" colspan="2"><a id="a4dff5987034becd48b49ff280d63b8fe"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4dff5987034becd48b49ff280d63b8fe"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a4dff5987034becd48b49ff280d63b8fe">ceil</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a4dff5987034becd48b49ff280d63b8fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">ceil all components of the matrix <br /></td></tr>
<tr class="separator:a4dff5987034becd48b49ff280d63b8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93aee66ad9e05a128e33680753b5705a"><td class="memTemplParams" colspan="2"><a id="a93aee66ad9e05a128e33680753b5705a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a93aee66ad9e05a128e33680753b5705a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a93aee66ad9e05a128e33680753b5705a">floor</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a93aee66ad9e05a128e33680753b5705a"><td class="mdescLeft">&#160;</td><td class="mdescRight">floor all components of the matrix <br /></td></tr>
<tr class="separator:a93aee66ad9e05a128e33680753b5705a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348ea2051480f9e505e5aae599493074"><td class="memTemplParams" colspan="2"><a id="a348ea2051480f9e505e5aae599493074"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a348ea2051480f9e505e5aae599493074"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a348ea2051480f9e505e5aae599493074">round</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a348ea2051480f9e505e5aae599493074"><td class="mdescLeft">&#160;</td><td class="mdescRight">round all components of the matrix <br /></td></tr>
<tr class="separator:a348ea2051480f9e505e5aae599493074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750d95c2509cf60ee60e33443412e13f"><td class="memTemplParams" colspan="2"><a id="a750d95c2509cf60ee60e33443412e13f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a750d95c2509cf60ee60e33443412e13f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a750d95c2509cf60ee60e33443412e13f">operator*</a> (const T &amp;s, const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a750d95c2509cf60ee60e33443412e13f"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the product of a scalar s and a matrix m <br /></td></tr>
<tr class="separator:a750d95c2509cf60ee60e33443412e13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9075b0df2e84047b5eccc4dfff7931d0"><td class="memTemplParams" colspan="2"><a id="a9075b0df2e84047b5eccc4dfff7931d0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9075b0df2e84047b5eccc4dfff7931d0"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a9075b0df2e84047b5eccc4dfff7931d0">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a9075b0df2e84047b5eccc4dfff7931d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">output of a matrix onto an ostream <br /></td></tr>
<tr class="separator:a9075b0df2e84047b5eccc4dfff7931d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0ec942d309201e672426563a171cd8"><td class="memTemplParams" colspan="2"><a id="a5f0ec942d309201e672426563a171cd8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5f0ec942d309201e672426563a171cd8"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a5f0ec942d309201e672426563a171cd8">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a5f0ec942d309201e672426563a171cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">input of a matrix onto an ostream <br /></td></tr>
<tr class="separator:a5f0ec942d309201e672426563a171cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f884462214d37af98d55984170fb1c5"><td class="memTemplParams" colspan="2"><a id="a2f884462214d37af98d55984170fb1c5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2f884462214d37af98d55984170fb1c5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a2f884462214d37af98d55984170fb1c5">Atx</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;a, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;x, <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;atx)</td></tr>
<tr class="memdesc:a2f884462214d37af98d55984170fb1c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiply A^T*x A is a matrix and x is a vector <br /></td></tr>
<tr class="separator:a2f884462214d37af98d55984170fb1c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82788036c8f08a2cdce123c0717c6b2"><td class="memTemplParams" colspan="2"><a id="aa82788036c8f08a2cdce123c0717c6b2"></a>
template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:aa82788036c8f08a2cdce123c0717c6b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#aa82788036c8f08a2cdce123c0717c6b2">dyad</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;v, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; S &gt; &amp;w)</td></tr>
<tr class="memdesc:aa82788036c8f08a2cdce123c0717c6b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the outer product of vector v and w <br /></td></tr>
<tr class="separator:aa82788036c8f08a2cdce123c0717c6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412054fabb1f60c7076fb8f714dbe77b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a412054fabb1f60c7076fb8f714dbe77b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a412054fabb1f60c7076fb8f714dbe77b">AIC</a> (int k, const T &amp;L)</td></tr>
<tr class="memdesc:a412054fabb1f60c7076fb8f714dbe77b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Akaike's: An Information Criterion k...number of parameters L...maximized value of likelihood function for estimated model n/k should be &gt; 40 otherwise use AICc (n ...  <a href="namespacecgv_1_1math.html#a412054fabb1f60c7076fb8f714dbe77b">More...</a><br /></td></tr>
<tr class="separator:a412054fabb1f60c7076fb8f714dbe77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c949211e1bdcfb28758a678bdf06b5d"><td class="memTemplParams" colspan="2"><a id="a7c949211e1bdcfb28758a678bdf06b5d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7c949211e1bdcfb28758a678bdf06b5d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a7c949211e1bdcfb28758a678bdf06b5d">AIC_ls</a> (int k, int n, const T &amp;RSS)</td></tr>
<tr class="memdesc:a7c949211e1bdcfb28758a678bdf06b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Akaike's: An information criterion for <br  />
 k...number of parameters n...number of samples RSS...the residual sum of squares n/k should be greater 40 otherwise use AICc. <br /></td></tr>
<tr class="separator:a7c949211e1bdcfb28758a678bdf06b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c70cac0aed64ef9cb752790c0c1a23"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa3c70cac0aed64ef9cb752790c0c1a23"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#aa3c70cac0aed64ef9cb752790c0c1a23">AICc</a> (int k, int n, const T &amp;L)</td></tr>
<tr class="memdesc:aa3c70cac0aed64ef9cb752790c0c1a23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Akaike's: An information criterion with second order correction term k...number of parameters n.  <a href="namespacecgv_1_1math.html#aa3c70cac0aed64ef9cb752790c0c1a23">More...</a><br /></td></tr>
<tr class="separator:aa3c70cac0aed64ef9cb752790c0c1a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93ba61da7f07c4a49a79060d92a28ef"><td class="memTemplParams" colspan="2"><a id="ab93ba61da7f07c4a49a79060d92a28ef"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab93ba61da7f07c4a49a79060d92a28ef"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ab93ba61da7f07c4a49a79060d92a28ef">AICc_ls</a> (int k, int n, const T &amp;RSS)</td></tr>
<tr class="memdesc:ab93ba61da7f07c4a49a79060d92a28ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Akaike's: An information criterion k...number of parameters n...number of samples RSS...the residual sum of squares. <br /></td></tr>
<tr class="separator:ab93ba61da7f07c4a49a79060d92a28ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5ea1af956e9651fccbedf5419f7adf"><td class="memTemplParams" colspan="2"><a id="aae5ea1af956e9651fccbedf5419f7adf"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aae5ea1af956e9651fccbedf5419f7adf"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#aae5ea1af956e9651fccbedf5419f7adf">AICu_ls</a> (int k, int n, const T &amp;RSS)</td></tr>
<tr class="memdesc:aae5ea1af956e9651fccbedf5419f7adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Akaike's: An information criterion k...number of parameters n...number of samples RSS...the residual sum of squares from the estimated model. <br /></td></tr>
<tr class="separator:aae5ea1af956e9651fccbedf5419f7adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5c2da55ba6e9caaac77a70bec26e92"><td class="memTemplParams" colspan="2"><a id="aef5c2da55ba6e9caaac77a70bec26e92"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aef5c2da55ba6e9caaac77a70bec26e92"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#aef5c2da55ba6e9caaac77a70bec26e92">BIC</a> (int k, int n, const T &amp;L)</td></tr>
<tr class="memdesc:aef5c2da55ba6e9caaac77a70bec26e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bayesian information criterion (Schwarz Information Criterion) k...number of parameters n...number of samples. <br /></td></tr>
<tr class="separator:aef5c2da55ba6e9caaac77a70bec26e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4d7e7d0b479a4fcf81fd38af9fda4b"><td class="memTemplParams" colspan="2"><a id="ace4d7e7d0b479a4fcf81fd38af9fda4b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ace4d7e7d0b479a4fcf81fd38af9fda4b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ace4d7e7d0b479a4fcf81fd38af9fda4b">BIC_ls</a> (int k, int n, const T &amp;RSS)</td></tr>
<tr class="memdesc:ace4d7e7d0b479a4fcf81fd38af9fda4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bayesian information criterion (Schwarz Information Criterion) k...number of parameters n...number of samples RSS...the residual sum of squares from the estimated model. <br /></td></tr>
<tr class="separator:ace4d7e7d0b479a4fcf81fd38af9fda4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72df463c830e9334b8903566afb95fb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a72df463c830e9334b8903566afb95fb4">estimate_normal_ls</a> (unsigned nr_points, const float *_points, float *_normal, float *_evals=0, float *_mean=0, float *_evecs=0)</td></tr>
<tr class="memdesc:a72df463c830e9334b8903566afb95fb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute least squares normal from an array of 3D points.  <a href="namespacecgv_1_1math.html#a72df463c830e9334b8903566afb95fb4">More...</a><br /></td></tr>
<tr class="separator:a72df463c830e9334b8903566afb95fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1e437b67fa2ac3e34fa7643a0d8eac"><td class="memItemLeft" align="right" valign="top"><a id="a3b1e437b67fa2ac3e34fa7643a0d8eac"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a3b1e437b67fa2ac3e34fa7643a0d8eac">estimate_normal_wls</a> (unsigned nr_points, const float *_points, const float *_weights, float *_normal, float *_evals=0, float *_mean=0, float *_evecs=0)</td></tr>
<tr class="memdesc:a3b1e437b67fa2ac3e34fa7643a0d8eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weighted version of <code>estimate_normal_ls</code> with additional input <code>_weights</code> pointing to <code>nr_points</code> scalar weights. <br /></td></tr>
<tr class="separator:a3b1e437b67fa2ac3e34fa7643a0d8eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed94b33c020f613384ed757f032e7b8"><td class="memTemplParams" colspan="2"><a id="a6ed94b33c020f613384ed757f032e7b8"></a>
template&lt;typename T , typename I &gt; </td></tr>
<tr class="memitem:a6ed94b33c020f613384ed757f032e7b8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a6ed94b33c020f613384ed757f032e7b8">permute_array</a> (size_t N, T *A, I *P)</td></tr>
<tr class="memdesc:a6ed94b33c020f613384ed757f032e7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">permute array <code>A</code> with <code>N</code> values of type <code>T</code> according to permutation <code>P</code> such that <code>A</code>[i] moves to <code>A</code>[P[i]] <br /></td></tr>
<tr class="separator:a6ed94b33c020f613384ed757f032e7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b277b91cc121749e9c2de21e4e0806"><td class="memTemplParams" colspan="2"><a id="ad9b277b91cc121749e9c2de21e4e0806"></a>
template&lt;typename T , typename I &gt; </td></tr>
<tr class="memitem:ad9b277b91cc121749e9c2de21e4e0806"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ad9b277b91cc121749e9c2de21e4e0806">permute_vector</a> (std::vector&lt; T &gt; &amp;V, std::vector&lt; I &gt; &amp;P)</td></tr>
<tr class="memdesc:ad9b277b91cc121749e9c2de21e4e0806"><td class="mdescLeft">&#160;</td><td class="mdescRight">interface to permute function for arrays and permutations stored in vectors <br /></td></tr>
<tr class="separator:ad9b277b91cc121749e9c2de21e4e0806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533e215a27ea03a63a404cd7c2286a98"><td class="memTemplParams" colspan="2"><a id="a533e215a27ea03a63a404cd7c2286a98"></a>
template&lt;typename T , typename I &gt; </td></tr>
<tr class="memitem:a533e215a27ea03a63a404cd7c2286a98"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a533e215a27ea03a63a404cd7c2286a98">permute_arrays</a> (T *data, I *P, size_t nr_rows, size_t nr_columns, size_t row_step, size_t column_step)</td></tr>
<tr class="memdesc:a533e215a27ea03a63a404cd7c2286a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">permute <code>nr_rows</code> rows of nested 2D array with <code>nr_columns</code> columns, step sizes to step by one row / column need to be provided <br /></td></tr>
<tr class="separator:a533e215a27ea03a63a404cd7c2286a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa33183d42422e47e25d8c55bbc9faa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6fa33183d42422e47e25d8c55bbc9faa"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a6fa33183d42422e47e25d8c55bbc9faa">plane_val</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;plane, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a6fa33183d42422e47e25d8c55bbc9faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">A plane is defined as a vector (a,b,c,d) =&gt; a*x1 + b*x2 +c*x3 +d = 0.  <a href="namespacecgv_1_1math.html#a6fa33183d42422e47e25d8c55bbc9faa">More...</a><br /></td></tr>
<tr class="separator:a6fa33183d42422e47e25d8c55bbc9faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f68ed2925f866ed12dbc4b043b104a2"><td class="memTemplParams" colspan="2"><a id="a1f68ed2925f866ed12dbc4b043b104a2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1f68ed2925f866ed12dbc4b043b104a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a1f68ed2925f866ed12dbc4b043b104a2">plane_val</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;plane, const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;xs)</td></tr>
<tr class="memdesc:a1f68ed2925f866ed12dbc4b043b104a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate plame equation on multiple positions xs <br /></td></tr>
<tr class="separator:a1f68ed2925f866ed12dbc4b043b104a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980c68f5c243fa1a32c157ff23041952"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a980c68f5c243fa1a32c157ff23041952"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a980c68f5c243fa1a32c157ff23041952">ransac_plane_fit</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;points, const T p_out=0.8, const T d_max=0.001, const T p_surety=0.99, bool msac=true)</td></tr>
<tr class="memdesc:a980c68f5c243fa1a32c157ff23041952"><td class="mdescLeft">&#160;</td><td class="mdescRight">ransac plane fit p_out...  <a href="namespacecgv_1_1math.html#a980c68f5c243fa1a32c157ff23041952">More...</a><br /></td></tr>
<tr class="separator:a980c68f5c243fa1a32c157ff23041952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11a737a3535c089fc6ba9c5970d399d"><td class="memTemplParams" colspan="2"><a id="ab11a737a3535c089fc6ba9c5970d399d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab11a737a3535c089fc6ba9c5970d399d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ab11a737a3535c089fc6ba9c5970d399d">mean</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;points)</td></tr>
<tr class="memdesc:ab11a737a3535c089fc6ba9c5970d399d"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the mean of all column vectors <br /></td></tr>
<tr class="separator:ab11a737a3535c089fc6ba9c5970d399d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47423e8f43fdf220cc4baea42c5360c"><td class="memTemplParams" colspan="2"><a id="ab47423e8f43fdf220cc4baea42c5360c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab47423e8f43fdf220cc4baea42c5360c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1vec.html">cgv::math::vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ab47423e8f43fdf220cc4baea42c5360c">geometric_median</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">cgv::math::mat</a>&lt; T &gt; &amp;points, const T &amp;eps=0.0001, const unsigned max_iter=100)</td></tr>
<tr class="memdesc:ab47423e8f43fdf220cc4baea42c5360c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the geometric median of a set of points <br /></td></tr>
<tr class="separator:ab47423e8f43fdf220cc4baea42c5360c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75402440f907260dc42b4eddb0caa4f"><td class="memTemplParams" colspan="2"><a id="ad75402440f907260dc42b4eddb0caa4f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad75402440f907260dc42b4eddb0caa4f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ad75402440f907260dc42b4eddb0caa4f">weighted_mean</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;weights, const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;points)</td></tr>
<tr class="memdesc:ad75402440f907260dc42b4eddb0caa4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the weighted mean of all column vectors <br /></td></tr>
<tr class="separator:ad75402440f907260dc42b4eddb0caa4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4720e06972baa64a69acb0bb8b8d3e"><td class="memTemplParams" colspan="2"><a id="a3f4720e06972baa64a69acb0bb8b8d3e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3f4720e06972baa64a69acb0bb8b8d3e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a3f4720e06972baa64a69acb0bb8b8d3e">covmat</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;points)</td></tr>
<tr class="memdesc:a3f4720e06972baa64a69acb0bb8b8d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute covariance matrix of the column vectors of points <br /></td></tr>
<tr class="separator:a3f4720e06972baa64a69acb0bb8b8d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a43b507e6de46542c40ad378471557"><td class="memTemplParams" colspan="2"><a id="ac5a43b507e6de46542c40ad378471557"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac5a43b507e6de46542c40ad378471557"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ac5a43b507e6de46542c40ad378471557">weighted_covmat</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;weights, const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;points)</td></tr>
<tr class="memdesc:ac5a43b507e6de46542c40ad378471557"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute weighted covariance matrix of the column vectors of points <br /></td></tr>
<tr class="separator:ac5a43b507e6de46542c40ad378471557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6160ff5a9e773979900dc4a6f54f8330"><td class="memTemplParams" colspan="2"><a id="a6160ff5a9e773979900dc4a6f54f8330"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6160ff5a9e773979900dc4a6f54f8330"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a6160ff5a9e773979900dc4a6f54f8330">weighted_covmat_and_mean</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;weights, const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;points, <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;wcovmat, <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;wmean)</td></tr>
<tr class="memdesc:a6160ff5a9e773979900dc4a6f54f8330"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute covariance matrix and mean of the column vectors of points in one step <br /></td></tr>
<tr class="separator:a6160ff5a9e773979900dc4a6f54f8330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add56cb42b150686bf69c39de5b71ae4b"><td class="memTemplParams" colspan="2"><a id="add56cb42b150686bf69c39de5b71ae4b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:add56cb42b150686bf69c39de5b71ae4b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#add56cb42b150686bf69c39de5b71ae4b">covmat_and_mean</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;points, <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;<a class="el" href="namespacecgv_1_1math.html#a3f4720e06972baa64a69acb0bb8b8d3e">covmat</a>, <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;<a class="el" href="namespacecgv_1_1math.html#a329a46cc70edfd039f85153dc8aefc0e">mean</a>)</td></tr>
<tr class="memdesc:add56cb42b150686bf69c39de5b71ae4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute covariance matrix and mean of the column vectors of points in one step <br /></td></tr>
<tr class="separator:add56cb42b150686bf69c39de5b71ae4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41efc72e1a7aad03a48a289c7fad23c8"><td class="memTemplParams" colspan="2"><a id="a41efc72e1a7aad03a48a289c7fad23c8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a41efc72e1a7aad03a48a289c7fad23c8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a41efc72e1a7aad03a48a289c7fad23c8">swap_XYZ_2_XZY</a> (<a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;points)</td></tr>
<tr class="memdesc:a41efc72e1a7aad03a48a289c7fad23c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap second with third row of point matrix <br /></td></tr>
<tr class="separator:a41efc72e1a7aad03a48a289c7fad23c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740272723e8fd8a035b306d85b0b1e3f"><td class="memTemplParams" colspan="2"><a id="a740272723e8fd8a035b306d85b0b1e3f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a740272723e8fd8a035b306d85b0b1e3f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a740272723e8fd8a035b306d85b0b1e3f">homog</a> (<a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;points)</td></tr>
<tr class="memdesc:a740272723e8fd8a035b306d85b0b1e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a set of non-homogeneous points into homogeneous points. <br /></td></tr>
<tr class="separator:a740272723e8fd8a035b306d85b0b1e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec60c75ddff3f844d673f8147410106"><td class="memTemplParams" colspan="2"><a id="a9ec60c75ddff3f844d673f8147410106"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9ec60c75ddff3f844d673f8147410106"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a9ec60c75ddff3f844d673f8147410106">unhomog</a> (<a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;points)</td></tr>
<tr class="memdesc:a9ec60c75ddff3f844d673f8147410106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a set of homogeneous points into non-homogeneous points by dividing with the last component. <br /></td></tr>
<tr class="separator:a9ec60c75ddff3f844d673f8147410106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227ca8bca8d01aa6cad1f74c79994f2c"><td class="memTemplParams" colspan="2"><a id="a227ca8bca8d01aa6cad1f74c79994f2c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a227ca8bca8d01aa6cad1f74c79994f2c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a227ca8bca8d01aa6cad1f74c79994f2c">polar</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;c, <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;r, <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;a, int num_iter=15)</td></tr>
<tr class="memdesc:a227ca8bca8d01aa6cad1f74c79994f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">polar decomposition of matrix c=r*a r orthonormal matrix a positive semi-definite matrix <br  />
 <br /></td></tr>
<tr class="separator:a227ca8bca8d01aa6cad1f74c79994f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13d980b9726467aeb59b55256fedda0"><td class="memTemplParams" colspan="2"><a id="ad13d980b9726467aeb59b55256fedda0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad13d980b9726467aeb59b55256fedda0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ad13d980b9726467aeb59b55256fedda0">decompose_rotation</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">cgv::math::mat</a>&lt; T &gt; &amp;R, <a class="el" href="classcgv_1_1math_1_1vec.html">cgv::math::vec</a>&lt; T &gt; &amp;axis, T &amp;angle)</td></tr>
<tr class="memdesc:ad13d980b9726467aeb59b55256fedda0"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract axis and angle from rotation matrix returns true if successful problematic cases are angle == 0° and angle == 180° <br /></td></tr>
<tr class="separator:ad13d980b9726467aeb59b55256fedda0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f72457452fa12679ad840de7b06df1c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9f72457452fa12679ad840de7b06df1c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a9f72457452fa12679ad840de7b06df1c">poly_val</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;p, const T &amp;x)</td></tr>
<tr class="memdesc:a9f72457452fa12679ad840de7b06df1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">polynomials are stored in vectors in the following order: [a,b,c,d] ...a*x^3 + b*x^2 + c*x + d  <a href="namespacecgv_1_1math.html#a9f72457452fa12679ad840de7b06df1c">More...</a><br /></td></tr>
<tr class="separator:a9f72457452fa12679ad840de7b06df1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556f6aef31de955ddca54cf92650b5f4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a556f6aef31de955ddca54cf92650b5f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a556f6aef31de955ddca54cf92650b5f4">poly_val</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;p, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a556f6aef31de955ddca54cf92650b5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate a polynomial p at multiple positions x p is the vector of length n+1 whose elements are the coefficients of the polynomial in descending powers.  <a href="namespacecgv_1_1math.html#a556f6aef31de955ddca54cf92650b5f4">More...</a><br /></td></tr>
<tr class="separator:a556f6aef31de955ddca54cf92650b5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8848108dc554c9e2d68c8ee728126e33"><td class="memTemplParams" colspan="2"><a id="a8848108dc554c9e2d68c8ee728126e33"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8848108dc554c9e2d68c8ee728126e33"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a8848108dc554c9e2d68c8ee728126e33">poly_mult</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;u, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a8848108dc554c9e2d68c8ee728126e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">1d convolution or polynomial multiplication <br /></td></tr>
<tr class="separator:a8848108dc554c9e2d68c8ee728126e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9edb1c4b430e362c3cf62aae108746b5"><td class="memTemplParams" colspan="2"><a id="a9edb1c4b430e362c3cf62aae108746b5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9edb1c4b430e362c3cf62aae108746b5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a9edb1c4b430e362c3cf62aae108746b5">poly_div</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;f, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;g, <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;q, <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;r)</td></tr>
<tr class="memdesc:a9edb1c4b430e362c3cf62aae108746b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">polynomial division f(x)/g(x) = q(x) + r(x)/g(x) returns true if r(x)=0 (rest 0) <br /></td></tr>
<tr class="separator:a9edb1c4b430e362c3cf62aae108746b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec5e342963d8b8db068c541d386f71f"><td class="memTemplParams" colspan="2"><a id="adec5e342963d8b8db068c541d386f71f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:adec5e342963d8b8db068c541d386f71f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#adec5e342963d8b8db068c541d386f71f">bernstein_polynomial</a> (unsigned j, unsigned g)</td></tr>
<tr class="memdesc:adec5e342963d8b8db068c541d386f71f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns bernstein polynomial (bezier basis) <br /></td></tr>
<tr class="separator:adec5e342963d8b8db068c541d386f71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa269f4a4b34be1c09f8815f1dc8f8b9f"><td class="memTemplParams" colspan="2"><a id="aa269f4a4b34be1c09f8815f1dc8f8b9f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa269f4a4b34be1c09f8815f1dc8f8b9f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 3 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#aa269f4a4b34be1c09f8815f1dc8f8b9f">pose_orientation</a> (<a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 4 &gt; &amp;pose)</td></tr>
<tr class="memdesc:aa269f4a4b34be1c09f8815f1dc8f8b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract orientation matrix from pose matrix <br /></td></tr>
<tr class="separator:aa269f4a4b34be1c09f8815f1dc8f8b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2057dc986ed011c47d9983e478a96be"><td class="memTemplParams" colspan="2"><a id="ad2057dc986ed011c47d9983e478a96be"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad2057dc986ed011c47d9983e478a96be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ad2057dc986ed011c47d9983e478a96be">pose_position</a> (<a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 4 &gt; &amp;pose)</td></tr>
<tr class="memdesc:ad2057dc986ed011c47d9983e478a96be"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract position vector from pose matrix <br /></td></tr>
<tr class="separator:ad2057dc986ed011c47d9983e478a96be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b98c7dfcf59b6f2a763397ec086d2f6"><td class="memTemplParams" colspan="2"><a id="a0b98c7dfcf59b6f2a763397ec086d2f6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0b98c7dfcf59b6f2a763397ec086d2f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a0b98c7dfcf59b6f2a763397ec086d2f6">pose_transform_point</a> (const <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 4 &gt; &amp;pose, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;p)</td></tr>
<tr class="memdesc:a0b98c7dfcf59b6f2a763397ec086d2f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">transform point with pose matrix <br /></td></tr>
<tr class="separator:a0b98c7dfcf59b6f2a763397ec086d2f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8ce5d5b5c6a8e7a8b4bbc5dd21e6e2"><td class="memTemplParams" colspan="2"><a id="a8f8ce5d5b5c6a8e7a8b4bbc5dd21e6e2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8f8ce5d5b5c6a8e7a8b4bbc5dd21e6e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a8f8ce5d5b5c6a8e7a8b4bbc5dd21e6e2">pose_transform_point</a> (const <a class="el" href="classcgv_1_1math_1_1quaternion.html">quaternion</a>&lt; T &gt; &amp;q, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;pos, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;p)</td></tr>
<tr class="memdesc:a8f8ce5d5b5c6a8e7a8b4bbc5dd21e6e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">transform point with pose quaternion-position pair <br /></td></tr>
<tr class="separator:a8f8ce5d5b5c6a8e7a8b4bbc5dd21e6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77cd9f33ae2ff3dc85ba638a89e7d138"><td class="memTemplParams" colspan="2"><a id="a77cd9f33ae2ff3dc85ba638a89e7d138"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a77cd9f33ae2ff3dc85ba638a89e7d138"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a77cd9f33ae2ff3dc85ba638a89e7d138">pose_transform_vector</a> (const <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 4 &gt; &amp;pose, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;v)</td></tr>
<tr class="memdesc:a77cd9f33ae2ff3dc85ba638a89e7d138"><td class="mdescLeft">&#160;</td><td class="mdescRight">transform vector with pose matrix <br /></td></tr>
<tr class="separator:a77cd9f33ae2ff3dc85ba638a89e7d138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95557270bc213638b5744d472916bb76"><td class="memTemplParams" colspan="2"><a id="a95557270bc213638b5744d472916bb76"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a95557270bc213638b5744d472916bb76"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a95557270bc213638b5744d472916bb76">inverse_pose_transform_point</a> (const <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 4 &gt; &amp;pose, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;p)</td></tr>
<tr class="memdesc:a95557270bc213638b5744d472916bb76"><td class="mdescLeft">&#160;</td><td class="mdescRight">transform point with inverse of pose matrix <br /></td></tr>
<tr class="separator:a95557270bc213638b5744d472916bb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee48774502024cdddc71b52b60871d5"><td class="memTemplParams" colspan="2"><a id="a1ee48774502024cdddc71b52b60871d5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1ee48774502024cdddc71b52b60871d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a1ee48774502024cdddc71b52b60871d5">inverse_pose_transform_vector</a> (const <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 4 &gt; &amp;pose, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;v)</td></tr>
<tr class="memdesc:a1ee48774502024cdddc71b52b60871d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">transform vector with inverse of pose matrix <br /></td></tr>
<tr class="separator:a1ee48774502024cdddc71b52b60871d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceae92ef51f7e3bf026a1ca8787c1e77"><td class="memTemplParams" colspan="2"><a id="aceae92ef51f7e3bf026a1ca8787c1e77"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aceae92ef51f7e3bf026a1ca8787c1e77"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#aceae92ef51f7e3bf026a1ca8787c1e77">invert_pose</a> (<a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 4 &gt; &amp;pose)</td></tr>
<tr class="memdesc:aceae92ef51f7e3bf026a1ca8787c1e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">inplace inversion of pose transformation <br /></td></tr>
<tr class="separator:aceae92ef51f7e3bf026a1ca8787c1e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6639c658d1365965333bcc6052413d1d"><td class="memTemplParams" colspan="2"><a id="a6639c658d1365965333bcc6052413d1d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6639c658d1365965333bcc6052413d1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a6639c658d1365965333bcc6052413d1d">pose_inverse</a> (const <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 4 &gt; &amp;pose)</td></tr>
<tr class="memdesc:a6639c658d1365965333bcc6052413d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a pose matrix with the inverse pose transformation <br /></td></tr>
<tr class="separator:a6639c658d1365965333bcc6052413d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b7bf300948cf813549d31cfc36337e"><td class="memTemplParams" colspan="2"><a id="ac6b7bf300948cf813549d31cfc36337e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac6b7bf300948cf813549d31cfc36337e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ac6b7bf300948cf813549d31cfc36337e">pose_construct</a> (const <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 3 &gt; &amp;orientation, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;position)</td></tr>
<tr class="memdesc:ac6b7bf300948cf813549d31cfc36337e"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct pose from rotation matrix and position vector <br /></td></tr>
<tr class="separator:ac6b7bf300948cf813549d31cfc36337e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5413d2ee8541d4ee8047973d2908f8"><td class="memTemplParams" colspan="2"><a id="a8e5413d2ee8541d4ee8047973d2908f8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8e5413d2ee8541d4ee8047973d2908f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a8e5413d2ee8541d4ee8047973d2908f8">pose_construct</a> (const <a class="el" href="classcgv_1_1math_1_1quaternion.html">quaternion</a>&lt; T &gt; &amp;orientation, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;position)</td></tr>
<tr class="memdesc:a8e5413d2ee8541d4ee8047973d2908f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct pose from rotation quaternion and position vector <br /></td></tr>
<tr class="separator:a8e5413d2ee8541d4ee8047973d2908f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391d6023a11bec61f0cff72783bf0a72"><td class="memTemplParams" colspan="2"><a id="a391d6023a11bec61f0cff72783bf0a72"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a391d6023a11bec61f0cff72783bf0a72"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a391d6023a11bec61f0cff72783bf0a72">pose_append</a> (<a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 4 &gt; &amp;pose_1, const <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 4 &gt; &amp;pose_2)</td></tr>
<tr class="memdesc:a391d6023a11bec61f0cff72783bf0a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">inplace concatenation of a pose matrix <br /></td></tr>
<tr class="separator:a391d6023a11bec61f0cff72783bf0a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca865894540c9bfcd01b46932c4ff09"><td class="memTemplParams" colspan="2"><a id="a2ca865894540c9bfcd01b46932c4ff09"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2ca865894540c9bfcd01b46932c4ff09"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a2ca865894540c9bfcd01b46932c4ff09">pose_transform</a> (const <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 4 &gt; &amp;pose_transform, <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 4 &gt; &amp;pose)</td></tr>
<tr class="memdesc:a2ca865894540c9bfcd01b46932c4ff09"><td class="mdescLeft">&#160;</td><td class="mdescRight">inplace transformation of a pose matrix with another pose transformation matrix <br /></td></tr>
<tr class="separator:a2ca865894540c9bfcd01b46932c4ff09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da2fd70896c09c55304f4d1118b8588"><td class="memTemplParams" colspan="2"><a id="a5da2fd70896c09c55304f4d1118b8588"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5da2fd70896c09c55304f4d1118b8588"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a5da2fd70896c09c55304f4d1118b8588">pose_concat</a> (const <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 4 &gt; &amp;pose_1, const <a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 4 &gt; &amp;pose_2)</td></tr>
<tr class="memdesc:a5da2fd70896c09c55304f4d1118b8588"><td class="mdescLeft">&#160;</td><td class="mdescRight">return concatenate of two pose transformations <br /></td></tr>
<tr class="separator:a5da2fd70896c09c55304f4d1118b8588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3367473071e0f1969635d77dac5b7988"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3367473071e0f1969635d77dac5b7988"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a3367473071e0f1969635d77dac5b7988">closest_point_on_sphere_to_point</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;so, T sr, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;p, <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;q, <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;n)</td></tr>
<tr class="memdesc:a3367473071e0f1969635d77dac5b7988"><td class="mdescLeft">&#160;</td><td class="mdescRight">find point on sphere closest to reference point  <a href="namespacecgv_1_1math.html#a3367473071e0f1969635d77dac5b7988">More...</a><br /></td></tr>
<tr class="separator:a3367473071e0f1969635d77dac5b7988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8efb9003373293771346e3144e312c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6b8efb9003373293771346e3144e312c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a6b8efb9003373293771346e3144e312c">closest_point_on_box_to_point</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;bo, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;be, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;p, <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;q, <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;n)</td></tr>
<tr class="memdesc:a6b8efb9003373293771346e3144e312c"><td class="mdescLeft">&#160;</td><td class="mdescRight">find point on box closest to reference point.  <a href="namespacecgv_1_1math.html#a6b8efb9003373293771346e3144e312c">More...</a><br /></td></tr>
<tr class="separator:a6b8efb9003373293771346e3144e312c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4576ca7326c745f021e3a2a643064ccf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4576ca7326c745f021e3a2a643064ccf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a4576ca7326c745f021e3a2a643064ccf">closest_point_on_box_to_point</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;bo, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;be, const <a class="el" href="classcgv_1_1math_1_1quaternion.html">quaternion</a>&lt; T &gt; &amp;bq, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;p, <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;q, <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;n)</td></tr>
<tr class="memdesc:a4576ca7326c745f021e3a2a643064ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">find point on box closest to reference point.  <a href="namespacecgv_1_1math.html#a4576ca7326c745f021e3a2a643064ccf">More...</a><br /></td></tr>
<tr class="separator:a4576ca7326c745f021e3a2a643064ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381120144e883526bd8d28c3b49d1fb8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a381120144e883526bd8d28c3b49d1fb8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a381120144e883526bd8d28c3b49d1fb8">closest_point_on_cylinder_to_point</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;co, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;cd, T cr, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;p, <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;q, <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;n)</td></tr>
<tr class="memdesc:a381120144e883526bd8d28c3b49d1fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">find point on cylinder closest to reference point  <a href="namespacecgv_1_1math.html#a381120144e883526bd8d28c3b49d1fb8">More...</a><br /></td></tr>
<tr class="separator:a381120144e883526bd8d28c3b49d1fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84f2ddcc7c3affdf4a7d2b1131c8511"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad84f2ddcc7c3affdf4a7d2b1131c8511"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ad84f2ddcc7c3affdf4a7d2b1131c8511">closest_point_on_line_to_line</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;lo, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;ld, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;lo2, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;ld2, <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;q)</td></tr>
<tr class="memdesc:ad84f2ddcc7c3affdf4a7d2b1131c8511"><td class="mdescLeft">&#160;</td><td class="mdescRight">find point on line closest to second line  <a href="namespacecgv_1_1math.html#ad84f2ddcc7c3affdf4a7d2b1131c8511">More...</a><br /></td></tr>
<tr class="separator:ad84f2ddcc7c3affdf4a7d2b1131c8511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed179d706cf4cd3f0168caa47569dff"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0ed179d706cf4cd3f0168caa47569dff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a0ed179d706cf4cd3f0168caa47569dff">closest_point_on_line_to_point</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;lo, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;ld, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;p)</td></tr>
<tr class="memdesc:a0ed179d706cf4cd3f0168caa47569dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">find point on line closest to reference point  <a href="namespacecgv_1_1math.html#a0ed179d706cf4cd3f0168caa47569dff">More...</a><br /></td></tr>
<tr class="separator:a0ed179d706cf4cd3f0168caa47569dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74963f56ae9f1d8eb6b0820b8a3debe8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a74963f56ae9f1d8eb6b0820b8a3debe8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a74963f56ae9f1d8eb6b0820b8a3debe8">closest_point_on_circle_to_point</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;co, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;cn, T cr, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;p, <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;q)</td></tr>
<tr class="memdesc:a74963f56ae9f1d8eb6b0820b8a3debe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">find point on circle closest to reference point  <a href="namespacecgv_1_1math.html#a74963f56ae9f1d8eb6b0820b8a3debe8">More...</a><br /></td></tr>
<tr class="separator:a74963f56ae9f1d8eb6b0820b8a3debe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3404ef1e90d66524a348a4cc5b181ae"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac3404ef1e90d66524a348a4cc5b181ae"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ac3404ef1e90d66524a348a4cc5b181ae">closest_point_on_line_to_circle</a> (const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;lo, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;ld, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;co, const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;cn, T cr, <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;q, int *iter_ptr=0)</td></tr>
<tr class="memdesc:ac3404ef1e90d66524a348a4cc5b181ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">find point on line closest to circle  <a href="namespacecgv_1_1math.html#ac3404ef1e90d66524a348a4cc5b181ae">More...</a><br /></td></tr>
<tr class="separator:ac3404ef1e90d66524a348a4cc5b181ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea16e699f66a3153080cf69a50b9146"><td class="memTemplParams" colspan="2"><a id="a5ea16e699f66a3153080cf69a50b9146"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5ea16e699f66a3153080cf69a50b9146"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1qem.html">qem</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a5ea16e699f66a3153080cf69a50b9146">operator*</a> (const T &amp;s, const <a class="el" href="classcgv_1_1math_1_1qem.html">qem</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a5ea16e699f66a3153080cf69a50b9146"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the product of a scalar s and qem v <br /></td></tr>
<tr class="separator:a5ea16e699f66a3153080cf69a50b9146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80c8817a7542063b7bb3bc47860ede6"><td class="memTemplParams" colspan="2"><a id="ac80c8817a7542063b7bb3bc47860ede6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac80c8817a7542063b7bb3bc47860ede6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ac80c8817a7542063b7bb3bc47860ede6">quat_multiply</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;v, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;q)</td></tr>
<tr class="memdesc:ac80c8817a7542063b7bb3bc47860ede6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quaterions are stored in vectors in the following order: [w, x, y, z] -&gt; w + x*i + y*j + z*k. <br /></td></tr>
<tr class="separator:ac80c8817a7542063b7bb3bc47860ede6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ff4fb26f360378f4a2dce97875f671"><td class="memTemplParams" colspan="2"><a id="a16ff4fb26f360378f4a2dce97875f671"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a16ff4fb26f360378f4a2dce97875f671"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a16ff4fb26f360378f4a2dce97875f671">axis_angle_2_quat</a> (<a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; axis, T angle)</td></tr>
<tr class="memdesc:a16ff4fb26f360378f4a2dce97875f671"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a quaterion q defined by the given axis and angle <br /></td></tr>
<tr class="separator:a16ff4fb26f360378f4a2dce97875f671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e17e86fbb77d2e81c3955d56b666ea6"><td class="memTemplParams" colspan="2"><a id="a4e17e86fbb77d2e81c3955d56b666ea6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4e17e86fbb77d2e81c3955d56b666ea6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a4e17e86fbb77d2e81c3955d56b666ea6">quat_2_axis_angle</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;q, <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;axis, T &amp;angle)</td></tr>
<tr class="memdesc:a4e17e86fbb77d2e81c3955d56b666ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract the axis and angle in degree from quaternion q <br /></td></tr>
<tr class="separator:a4e17e86fbb77d2e81c3955d56b666ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91fb0987f4f9ded50a594aea9c052a5d"><td class="memTemplParams" colspan="2"><a id="a91fb0987f4f9ded50a594aea9c052a5d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a91fb0987f4f9ded50a594aea9c052a5d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a91fb0987f4f9ded50a594aea9c052a5d">quat_rotate</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;q, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a91fb0987f4f9ded50a594aea9c052a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the rotation of vector v by quaternion q <br /></td></tr>
<tr class="separator:a91fb0987f4f9ded50a594aea9c052a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148f0a4608ecd5d41bc6ffc1b83c11f3"><td class="memTemplParams" colspan="2"><a id="a148f0a4608ecd5d41bc6ffc1b83c11f3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a148f0a4608ecd5d41bc6ffc1b83c11f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a148f0a4608ecd5d41bc6ffc1b83c11f3">quat_conj</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;q)</td></tr>
<tr class="memdesc:a148f0a4608ecd5d41bc6ffc1b83c11f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the conjugate quaternion q <br /></td></tr>
<tr class="separator:a148f0a4608ecd5d41bc6ffc1b83c11f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2818f7c5d47390e87b50fe008452b0"><td class="memTemplParams" colspan="2"><a id="afa2818f7c5d47390e87b50fe008452b0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afa2818f7c5d47390e87b50fe008452b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#afa2818f7c5d47390e87b50fe008452b0">quat_normalize</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;q)</td></tr>
<tr class="memdesc:afa2818f7c5d47390e87b50fe008452b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a normalize version of quaternion q <br /></td></tr>
<tr class="separator:afa2818f7c5d47390e87b50fe008452b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d67840aca927a20bc061ff724401ea"><td class="memTemplParams" colspan="2"><a id="a62d67840aca927a20bc061ff724401ea"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a62d67840aca927a20bc061ff724401ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a62d67840aca927a20bc061ff724401ea">quat_inv</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;q)</td></tr>
<tr class="memdesc:a62d67840aca927a20bc061ff724401ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the inverse of quaterion q <br /></td></tr>
<tr class="separator:a62d67840aca927a20bc061ff724401ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81aff26fbcb622a458ea9ad3f053c9e2"><td class="memTemplParams" colspan="2"><a id="a81aff26fbcb622a458ea9ad3f053c9e2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a81aff26fbcb622a458ea9ad3f053c9e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a81aff26fbcb622a458ea9ad3f053c9e2">quat_2_mat_33</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;q)</td></tr>
<tr class="memdesc:a81aff26fbcb622a458ea9ad3f053c9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert unit quaternion to 3x3 rotation matrix <br /></td></tr>
<tr class="separator:a81aff26fbcb622a458ea9ad3f053c9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24fcb46517f4106ddcfd5b2a2fd256ff"><td class="memTemplParams" colspan="2"><a id="a24fcb46517f4106ddcfd5b2a2fd256ff"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a24fcb46517f4106ddcfd5b2a2fd256ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a24fcb46517f4106ddcfd5b2a2fd256ff">quat_2_mat_44</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;q)</td></tr>
<tr class="memdesc:a24fcb46517f4106ddcfd5b2a2fd256ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert unit quaternion to 4x4 rotation matrix <br /></td></tr>
<tr class="separator:a24fcb46517f4106ddcfd5b2a2fd256ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1134ce876e614d9d0484700d45bb0e"><td class="memTemplParams" colspan="2"><a id="a1b1134ce876e614d9d0484700d45bb0e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1b1134ce876e614d9d0484700d45bb0e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1quaternion.html">quaternion</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a1b1134ce876e614d9d0484700d45bb0e">operator*</a> (const T &amp;s, const <a class="el" href="classcgv_1_1math_1_1quaternion.html">quaternion</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a1b1134ce876e614d9d0484700d45bb0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the product of a scalar s and vector v <br /></td></tr>
<tr class="separator:a1b1134ce876e614d9d0484700d45bb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272db28d4d7d4cc2f6e608c50918a664"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a272db28d4d7d4cc2f6e608c50918a664"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a272db28d4d7d4cc2f6e608c50918a664">num_ransac_iterations</a> (unsigned n_min, const T p_out, const T p_surety=0.99)</td></tr>
<tr class="memdesc:a272db28d4d7d4cc2f6e608c50918a664"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of needed ransac iterations n_min...  <a href="namespacecgv_1_1math.html#a272db28d4d7d4cc2f6e608c50918a664">More...</a><br /></td></tr>
<tr class="separator:a272db28d4d7d4cc2f6e608c50918a664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4fe68403e329af9ace512b1d945bb53"><td class="memItemLeft" align="right" valign="top"><a id="ae4fe68403e329af9ace512b1d945bb53"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ae4fe68403e329af9ace512b1d945bb53">solve_quadric</a> (double c[3], double s[2], bool replicate_multiple_solutions=false)</td></tr>
<tr class="memdesc:ae4fe68403e329af9ace512b1d945bb53"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the solutions to c[0]+c[1]*x+c[2]*x*x = 0 into s and return the number of solutions <br /></td></tr>
<tr class="separator:ae4fe68403e329af9ace512b1d945bb53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a18eac44663bd5bff968c8a98ad4b1b"><td class="memItemLeft" align="right" valign="top"><a id="a2a18eac44663bd5bff968c8a98ad4b1b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a2a18eac44663bd5bff968c8a98ad4b1b">solve_cubic</a> (double c[4], double s[3], bool replicate_multiple_solutions=false)</td></tr>
<tr class="memdesc:a2a18eac44663bd5bff968c8a98ad4b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the solutions to c[0]+c[1]*x+c[2]*x*x+c[3]*x*x*x = 0 into s and return the number of solutions <br /></td></tr>
<tr class="separator:a2a18eac44663bd5bff968c8a98ad4b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc0e7b7f9374468390e175c7c8d719c"><td class="memItemLeft" align="right" valign="top"><a id="aadc0e7b7f9374468390e175c7c8d719c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#aadc0e7b7f9374468390e175c7c8d719c">solve_quartic</a> (double c[5], double s[4])</td></tr>
<tr class="memdesc:aadc0e7b7f9374468390e175c7c8d719c"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the solutions to c[0]+c[1]*x+c[2]*x*x+c[3]*x*x*x+c[4]*x*x*x*x = 0 into s and return the number of solutions <br /></td></tr>
<tr class="separator:aadc0e7b7f9374468390e175c7c8d719c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f80cfa8700f246807ae76fa63bbc1e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa0f80cfa8700f246807ae76fa63bbc1e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#aa0f80cfa8700f246807ae76fa63bbc1e">sphere_val</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;sphere, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:aa0f80cfa8700f246807ae76fa63bbc1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sphere is defined as a vector (a,b,c,r) =&gt; center (a,b,c) and radius r.  <a href="namespacecgv_1_1math.html#aa0f80cfa8700f246807ae76fa63bbc1e">More...</a><br /></td></tr>
<tr class="separator:aa0f80cfa8700f246807ae76fa63bbc1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6452e4900f24398889506f6d1625a0"><td class="memTemplParams" colspan="2"><a id="a1c6452e4900f24398889506f6d1625a0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1c6452e4900f24398889506f6d1625a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a1c6452e4900f24398889506f6d1625a0">sphere_val</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;sphere, const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;xs)</td></tr>
<tr class="memdesc:a1c6452e4900f24398889506f6d1625a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate implicit sphere equation at x =(x1,x2,x3) returns signed dist <br  />
 <br /></td></tr>
<tr class="separator:a1c6452e4900f24398889506f6d1625a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c64d492a52f234bd13234c434c12c39"><td class="memTemplParams" colspan="2"><a id="a2c64d492a52f234bd13234c434c12c39"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2c64d492a52f234bd13234c434c12c39"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a2c64d492a52f234bd13234c434c12c39">sphere_val2</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;sphere, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a2c64d492a52f234bd13234c434c12c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate implicit sphere equation at x =(x1,x2,x3) returns signed squared dist <br  />
 <br /></td></tr>
<tr class="separator:a2c64d492a52f234bd13234c434c12c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc48a1fe7f24ebdc9910d2bf512e6908"><td class="memTemplParams" colspan="2"><a id="acc48a1fe7f24ebdc9910d2bf512e6908"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acc48a1fe7f24ebdc9910d2bf512e6908"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#acc48a1fe7f24ebdc9910d2bf512e6908">sphere_val2</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;sphere, const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;xs)</td></tr>
<tr class="memdesc:acc48a1fe7f24ebdc9910d2bf512e6908"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate implicit sphere equation at x =(x1,x2,x3) returns signed dist <br  />
 <br /></td></tr>
<tr class="separator:acc48a1fe7f24ebdc9910d2bf512e6908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83af4b14f8e4dbc6cdc8dcaa66d5f0e"><td class="memTemplParams" colspan="2"><a id="ad83af4b14f8e4dbc6cdc8dcaa66d5f0e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad83af4b14f8e4dbc6cdc8dcaa66d5f0e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ad83af4b14f8e4dbc6cdc8dcaa66d5f0e">sphere_fit</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;p1)</td></tr>
<tr class="memdesc:ad83af4b14f8e4dbc6cdc8dcaa66d5f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct smallest enclosing sphere of one point <br /></td></tr>
<tr class="separator:ad83af4b14f8e4dbc6cdc8dcaa66d5f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af977cf5721c056df0c03918934c41eec"><td class="memTemplParams" colspan="2"><a id="af977cf5721c056df0c03918934c41eec"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af977cf5721c056df0c03918934c41eec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#af977cf5721c056df0c03918934c41eec">sphere_fit</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;p1, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;p2)</td></tr>
<tr class="memdesc:af977cf5721c056df0c03918934c41eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">sphere through 2 points <br /></td></tr>
<tr class="separator:af977cf5721c056df0c03918934c41eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60162fd6544ef9225c3d0680266a84f7"><td class="memTemplParams" colspan="2"><a id="a60162fd6544ef9225c3d0680266a84f7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a60162fd6544ef9225c3d0680266a84f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a60162fd6544ef9225c3d0680266a84f7">sphere_fit</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;O, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;A, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;B)</td></tr>
<tr class="memdesc:a60162fd6544ef9225c3d0680266a84f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">sphere through 3 points <br /></td></tr>
<tr class="separator:a60162fd6544ef9225c3d0680266a84f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa668eda4b3e0077fdeced5dfac9652c6"><td class="memTemplParams" colspan="2"><a id="aa668eda4b3e0077fdeced5dfac9652c6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa668eda4b3e0077fdeced5dfac9652c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#aa668eda4b3e0077fdeced5dfac9652c6">sphere_fit</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;x1, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;x2, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;x3, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;x4)</td></tr>
<tr class="memdesc:aa668eda4b3e0077fdeced5dfac9652c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">sphere through 4 points <br /></td></tr>
<tr class="separator:aa668eda4b3e0077fdeced5dfac9652c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13036c077a8de74c02b7646d08012c04"><td class="memTemplParams" colspan="2"><a id="a13036c077a8de74c02b7646d08012c04"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a13036c077a8de74c02b7646d08012c04"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a13036c077a8de74c02b7646d08012c04">mini_ball</a> (<a class="el" href="classcgv_1_1math_1_1mat.html">cgv::math::mat</a>&lt; T &gt; &amp;points)</td></tr>
<tr class="memdesc:a13036c077a8de74c02b7646d08012c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute smallest enclosing sphere of points <br /></td></tr>
<tr class="separator:a13036c077a8de74c02b7646d08012c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab694baa8c568f3b1b8ce1bce8eff34d5"><td class="memTemplParams" colspan="2"><a id="ab694baa8c568f3b1b8ce1bce8eff34d5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab694baa8c568f3b1b8ce1bce8eff34d5"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ab694baa8c568f3b1b8ce1bce8eff34d5">norm_pdf</a> (const T x, const T mu=0, const T sig=1)</td></tr>
<tr class="memdesc:ab694baa8c568f3b1b8ce1bce8eff34d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">normal distribution prob density function <br /></td></tr>
<tr class="separator:ab694baa8c568f3b1b8ce1bce8eff34d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec476dd99fd70352b186271b3e26fce"><td class="memTemplParams" colspan="2"><a id="a0ec476dd99fd70352b186271b3e26fce"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0ec476dd99fd70352b186271b3e26fce"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a0ec476dd99fd70352b186271b3e26fce">norm_cdf</a> (const T x, const T mu=0, const T sig=1)</td></tr>
<tr class="memdesc:a0ec476dd99fd70352b186271b3e26fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">normal cumulative distribution function <br /></td></tr>
<tr class="separator:a0ec476dd99fd70352b186271b3e26fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6085e1cc9615134e20dd06f98c0b93"><td class="memTemplParams" colspan="2"><a id="aca6085e1cc9615134e20dd06f98c0b93"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca6085e1cc9615134e20dd06f98c0b93"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#aca6085e1cc9615134e20dd06f98c0b93">norm_inv</a> (const T &amp;p, const T mu=0, const T sig=1)</td></tr>
<tr class="memdesc:aca6085e1cc9615134e20dd06f98c0b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">inverse normal cumulative distribution function <br /></td></tr>
<tr class="separator:aca6085e1cc9615134e20dd06f98c0b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf88fb10568cfdc08badf9f1689cb9da"><td class="memTemplParams" colspan="2"><a id="abf88fb10568cfdc08badf9f1689cb9da"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abf88fb10568cfdc08badf9f1689cb9da"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#abf88fb10568cfdc08badf9f1689cb9da">logn_pdf</a> (const T x, const T mu=0, const T sig=1)</td></tr>
<tr class="memdesc:abf88fb10568cfdc08badf9f1689cb9da"><td class="mdescLeft">&#160;</td><td class="mdescRight">lognormal normal prob distribution function <br /></td></tr>
<tr class="separator:abf88fb10568cfdc08badf9f1689cb9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b474dd6ff829663a8a4d47453505b4"><td class="memTemplParams" colspan="2"><a id="ae7b474dd6ff829663a8a4d47453505b4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae7b474dd6ff829663a8a4d47453505b4"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ae7b474dd6ff829663a8a4d47453505b4">logn_cdf</a> (const T x, const T mu=0, const T sig=1)</td></tr>
<tr class="memdesc:ae7b474dd6ff829663a8a4d47453505b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">log normal cumulative distribution function <br /></td></tr>
<tr class="separator:ae7b474dd6ff829663a8a4d47453505b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076f812d3f95cae1c4f4fa71084aeae5"><td class="memTemplParams" colspan="2"><a id="a076f812d3f95cae1c4f4fa71084aeae5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a076f812d3f95cae1c4f4fa71084aeae5"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a076f812d3f95cae1c4f4fa71084aeae5">logn_inv</a> (const T p, const T mu=0, const T sig=1)</td></tr>
<tr class="memdesc:a076f812d3f95cae1c4f4fa71084aeae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">inverse log normal cumulative distribution function <br /></td></tr>
<tr class="separator:a076f812d3f95cae1c4f4fa71084aeae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9478f2f6720791cffd14e8abdd7860d9"><td class="memTemplParams" colspan="2"><a id="a9478f2f6720791cffd14e8abdd7860d9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9478f2f6720791cffd14e8abdd7860d9"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a9478f2f6720791cffd14e8abdd7860d9">uniform_pdf</a> (const T x, const T a, const T b)</td></tr>
<tr class="memdesc:a9478f2f6720791cffd14e8abdd7860d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">uniform distribution prob density function <br /></td></tr>
<tr class="separator:a9478f2f6720791cffd14e8abdd7860d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72681a74de04e7781633ccde28edd34f"><td class="memTemplParams" colspan="2"><a id="a72681a74de04e7781633ccde28edd34f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a72681a74de04e7781633ccde28edd34f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a72681a74de04e7781633ccde28edd34f">uniform_cdf</a> (const T x, const T a, const T b)</td></tr>
<tr class="memdesc:a72681a74de04e7781633ccde28edd34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">uniform cumulative distribution function <br /></td></tr>
<tr class="separator:a72681a74de04e7781633ccde28edd34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb57efeef3c6f8caac9f2769628a623"><td class="memTemplParams" colspan="2"><a id="abfb57efeef3c6f8caac9f2769628a623"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abfb57efeef3c6f8caac9f2769628a623"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#abfb57efeef3c6f8caac9f2769628a623">ksc_cdf</a> (const T z)</td></tr>
<tr class="memdesc:abfb57efeef3c6f8caac9f2769628a623"><td class="mdescLeft">&#160;</td><td class="mdescRight">complementary cumulative kolmogorov-smirnov distribution function <br /></td></tr>
<tr class="separator:abfb57efeef3c6f8caac9f2769628a623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127fbe38e376c844bf6b64674149e358"><td class="memTemplParams" colspan="2"><a id="a127fbe38e376c844bf6b64674149e358"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a127fbe38e376c844bf6b64674149e358"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a127fbe38e376c844bf6b64674149e358">invxlogx</a> (const T y)</td></tr>
<tr class="memdesc:a127fbe38e376c844bf6b64674149e358"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function to compute ksc_inv <br /></td></tr>
<tr class="separator:a127fbe38e376c844bf6b64674149e358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08886183ded948207b97a4a3c15f8adf"><td class="memTemplParams" colspan="2"><a id="a08886183ded948207b97a4a3c15f8adf"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a08886183ded948207b97a4a3c15f8adf"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a08886183ded948207b97a4a3c15f8adf">ksc_inv</a> (const T q)</td></tr>
<tr class="memdesc:a08886183ded948207b97a4a3c15f8adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">inverse complementary cumulative kolmogorv-smirnov distribution function <br /></td></tr>
<tr class="separator:a08886183ded948207b97a4a3c15f8adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeadccc22955d27028af5e260dc236da3"><td class="memTemplParams" colspan="2"><a id="aeadccc22955d27028af5e260dc236da3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeadccc22955d27028af5e260dc236da3"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#aeadccc22955d27028af5e260dc236da3">ks_inv</a> (const T p)</td></tr>
<tr class="memdesc:aeadccc22955d27028af5e260dc236da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">inverse of the cumulative kolmogorv-smirnov distribution function <br /></td></tr>
<tr class="separator:aeadccc22955d27028af5e260dc236da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c4dd7de30e965b53e1c482e2508acd6"><td class="memTemplParams" colspan="2"><a id="a8c4dd7de30e965b53e1c482e2508acd6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8c4dd7de30e965b53e1c482e2508acd6"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a8c4dd7de30e965b53e1c482e2508acd6">norm_ks_test</a> (const T mu, const T sig, <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; data)</td></tr>
<tr class="memdesc:a8c4dd7de30e965b53e1c482e2508acd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">kolmogorov-smirnov test for comparing samples with given normal distribution returns the p-value for the null hypothesis that the data is drawn from a normal distribution defined by mu and sigma <br /></td></tr>
<tr class="separator:a8c4dd7de30e965b53e1c482e2508acd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5126d3fba41bcf13dea265548d9c21c1"><td class="memTemplParams" colspan="2"><a id="a5126d3fba41bcf13dea265548d9c21c1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5126d3fba41bcf13dea265548d9c21c1"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a5126d3fba41bcf13dea265548d9c21c1">ks_test</a> (<a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; data1, <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; data2)</td></tr>
<tr class="memdesc:a5126d3fba41bcf13dea265548d9c21c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">kolmogorov-smirnov test for comparing two sampled distributions returns the p-value for the null hypothesis that the the samples data1 are drawn from the same distribution as the samples of data2 <br /></td></tr>
<tr class="separator:a5126d3fba41bcf13dea265548d9c21c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a005510b7ffa2c6a772d826ba2c164"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab6a005510b7ffa2c6a772d826ba2c164"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ab6a005510b7ffa2c6a772d826ba2c164">svd</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;a, <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;u, <a class="el" href="structcgv_1_1math_1_1diag__mat.html">diag_mat</a>&lt; T &gt; &amp;w, <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;v, bool ordering=true, int maxiter=30)</td></tr>
<tr class="memdesc:ab6a005510b7ffa2c6a772d826ba2c164"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the singular value decomposition of an MxN matrix a = u* w * v^t where u is an MxN matrix, w is a diagonal NxN matrix and v is a NxN square matrix.  <a href="namespacecgv_1_1math.html#ab6a005510b7ffa2c6a772d826ba2c164">More...</a><br /></td></tr>
<tr class="separator:ab6a005510b7ffa2c6a772d826ba2c164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac466ec1d1ddb11e3baef1c3d7e93296f"><td class="memTemplParams" colspan="2"><a id="ac466ec1d1ddb11e3baef1c3d7e93296f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac466ec1d1ddb11e3baef1c3d7e93296f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ac466ec1d1ddb11e3baef1c3d7e93296f">null</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:ac466ec1d1ddb11e3baef1c3d7e93296f"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the null space of a matrix <br /></td></tr>
<tr class="separator:ac466ec1d1ddb11e3baef1c3d7e93296f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8801c55a874b826030c7e4fa60d26f59"><td class="memTemplParams" colspan="2"><a id="a8801c55a874b826030c7e4fa60d26f59"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8801c55a874b826030c7e4fa60d26f59"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a8801c55a874b826030c7e4fa60d26f59">null</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;a, T tol)</td></tr>
<tr class="memdesc:a8801c55a874b826030c7e4fa60d26f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the effective null space of a matrix using user defined tolerance <br /></td></tr>
<tr class="separator:a8801c55a874b826030c7e4fa60d26f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d19805e29525bb8e3450411eaf43f4"><td class="memTemplParams" colspan="2"><a id="a15d19805e29525bb8e3450411eaf43f4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a15d19805e29525bb8e3450411eaf43f4"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a15d19805e29525bb8e3450411eaf43f4">rank</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:a15d19805e29525bb8e3450411eaf43f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the rank of a matrix using svd <br /></td></tr>
<tr class="separator:a15d19805e29525bb8e3450411eaf43f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fce4e1b725798d6fdd6f8ab2a0ea89"><td class="memTemplParams" colspan="2"><a id="ad3fce4e1b725798d6fdd6f8ab2a0ea89"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad3fce4e1b725798d6fdd6f8ab2a0ea89"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ad3fce4e1b725798d6fdd6f8ab2a0ea89">rank</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;a, T tol)</td></tr>
<tr class="memdesc:ad3fce4e1b725798d6fdd6f8ab2a0ea89"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the effective rank of a matrix using svd and the given tolerance tol <br /></td></tr>
<tr class="separator:ad3fce4e1b725798d6fdd6f8ab2a0ea89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01f02edd8e30cf1e4341c07c7c3afae"><td class="memTemplParams" colspan="2"><a id="ac01f02edd8e30cf1e4341c07c7c3afae"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac01f02edd8e30cf1e4341c07c7c3afae"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ac01f02edd8e30cf1e4341c07c7c3afae">solve_underdetermined_system</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">cgv::math::mat</a>&lt; T &gt; &amp;A, const <a class="el" href="classcgv_1_1math_1_1vec.html">cgv::math::vec</a>&lt; T &gt; &amp;b, <a class="el" href="classcgv_1_1math_1_1vec.html">cgv::math::vec</a>&lt; T &gt; &amp;p, <a class="el" href="classcgv_1_1math_1_1mat.html">cgv::math::mat</a>&lt; T &gt; &amp;N)</td></tr>
<tr class="memdesc:ac01f02edd8e30cf1e4341c07c7c3afae"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the rank of m x n matrix A with m &lt; n the solution of the system Ax=b is given as x= p + N *(l_1,...,l_{n-r})^T, r is the rank of A, are the free parameters and N is the nullspace <br  />
 <br /></td></tr>
<tr class="separator:ac01f02edd8e30cf1e4341c07c7c3afae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d643dede4f904b08dc0f5eb1db7b287"><td class="memTemplParams" colspan="2"><a id="a6d643dede4f904b08dc0f5eb1db7b287"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6d643dede4f904b08dc0f5eb1db7b287"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a6d643dede4f904b08dc0f5eb1db7b287">find_nonrigid_transformation</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;points1, const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;points2, <a class="el" href="structcgv_1_1math_1_1thin__plate__spline.html">thin_plate_spline</a>&lt; T &gt; &amp;spline)</td></tr>
<tr class="memdesc:a6d643dede4f904b08dc0f5eb1db7b287"><td class="mdescLeft">&#160;</td><td class="mdescRight">fit thin plate spline to interpolate point correspondences suc that for columns i spline.map_position(points1.col(i)) == points2.col(i) points1 and points2 must contain at least 3 2d point correspondences <br /></td></tr>
<tr class="separator:a6d643dede4f904b08dc0f5eb1db7b287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac970ad822a64c86702f1ec3ac21af1b6"><td class="memTemplParams" colspan="2"><a id="ac970ad822a64c86702f1ec3ac21af1b6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac970ad822a64c86702f1ec3ac21af1b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ac970ad822a64c86702f1ec3ac21af1b6">find_nonrigid_transformation</a> (const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;points1, const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;points2, <a class="el" href="structcgv_1_1math_1_1thin__hyper__plate__spline.html">thin_hyper_plate_spline</a>&lt; T &gt; &amp;spline)</td></tr>
<tr class="memdesc:ac970ad822a64c86702f1ec3ac21af1b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">fit thin hyperplate spline to interpolate point correspondences such that for columns i spline.map_position(points1.col(i)) == points2.col(i) points1 and points2 must contain at least 4 3d point correspondences <br /></td></tr>
<tr class="separator:ac970ad822a64c86702f1ec3ac21af1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9716f3d02a56270fbad9174562bec242"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9716f3d02a56270fbad9174562bec242"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a9716f3d02a56270fbad9174562bec242">apply_nonrigid_transformation</a> (const <a class="el" href="structcgv_1_1math_1_1thin__plate__spline.html">thin_plate_spline</a>&lt; T &gt; &amp;s, <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;points)</td></tr>
<tr class="memdesc:a9716f3d02a56270fbad9174562bec242"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply thin-plate-spline deformation in-place (without producing a copy of the points).  <a href="namespacecgv_1_1math.html#a9716f3d02a56270fbad9174562bec242">More...</a><br /></td></tr>
<tr class="separator:a9716f3d02a56270fbad9174562bec242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb844540e70f134515a6e5114f163da"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adfb844540e70f134515a6e5114f163da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#adfb844540e70f134515a6e5114f163da">apply_nonrigid_transformation</a> (const <a class="el" href="structcgv_1_1math_1_1thin__hyper__plate__spline.html">thin_hyper_plate_spline</a>&lt; T &gt; &amp;s, <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;points)</td></tr>
<tr class="memdesc:adfb844540e70f134515a6e5114f163da"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply thin-hyper-plate-spline deformation in-place (without producing a copy of the points).  <a href="namespacecgv_1_1math.html#adfb844540e70f134515a6e5114f163da">More...</a><br /></td></tr>
<tr class="separator:adfb844540e70f134515a6e5114f163da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85897d2b217993a9a037e398cb5b3574"><td class="memTemplParams" colspan="2"><a id="a85897d2b217993a9a037e398cb5b3574"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a85897d2b217993a9a037e398cb5b3574"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a85897d2b217993a9a037e398cb5b3574">scale_33</a> (const T &amp;sx, const T &amp;sy, const T &amp;sz)</td></tr>
<tr class="memdesc:a85897d2b217993a9a037e398cb5b3574"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a 3x3 scale matrix <br /></td></tr>
<tr class="separator:a85897d2b217993a9a037e398cb5b3574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac596cebb0e1bb3d7c3a3c6a7f09d40"><td class="memTemplParams" colspan="2"><a id="a3ac596cebb0e1bb3d7c3a3c6a7f09d40"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3ac596cebb0e1bb3d7c3a3c6a7f09d40"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a3ac596cebb0e1bb3d7c3a3c6a7f09d40">scale_33</a> (const T &amp;s)</td></tr>
<tr class="memdesc:a3ac596cebb0e1bb3d7c3a3c6a7f09d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a 3x3 uniform scale matrix <br /></td></tr>
<tr class="separator:a3ac596cebb0e1bb3d7c3a3c6a7f09d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e0707a52e79e75a0cfc92fb9692440"><td class="memTemplParams" colspan="2"><a id="ab0e0707a52e79e75a0cfc92fb9692440"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab0e0707a52e79e75a0cfc92fb9692440"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ab0e0707a52e79e75a0cfc92fb9692440">rotatex_33</a> (const T &amp;angle)</td></tr>
<tr class="memdesc:ab0e0707a52e79e75a0cfc92fb9692440"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a 3x3 rotation matrix around the x axis, the angle is in degree <br  />
 <br /></td></tr>
<tr class="separator:ab0e0707a52e79e75a0cfc92fb9692440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086592be0c324c31e0288e3049575da9"><td class="memTemplParams" colspan="2"><a id="a086592be0c324c31e0288e3049575da9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a086592be0c324c31e0288e3049575da9"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a086592be0c324c31e0288e3049575da9">rotatey_33</a> (const T &amp;angle)</td></tr>
<tr class="memdesc:a086592be0c324c31e0288e3049575da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a 3x3 rotation matrix around the y axis, the angle is in degree <br  />
 <br /></td></tr>
<tr class="separator:a086592be0c324c31e0288e3049575da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0cc5ddf263bbdc7ae430b3fa059c363"><td class="memTemplParams" colspan="2"><a id="ac0cc5ddf263bbdc7ae430b3fa059c363"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac0cc5ddf263bbdc7ae430b3fa059c363"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ac0cc5ddf263bbdc7ae430b3fa059c363">rotatez_33</a> (const T &amp;angle)</td></tr>
<tr class="memdesc:ac0cc5ddf263bbdc7ae430b3fa059c363"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a 3x3 rotation matrix around the z axis, the angle is in degree <br  />
 <br /></td></tr>
<tr class="separator:ac0cc5ddf263bbdc7ae430b3fa059c363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b1dab60bc2f964bdb9aa6a3952bf88"><td class="memTemplParams" colspan="2"><a id="ab3b1dab60bc2f964bdb9aa6a3952bf88"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab3b1dab60bc2f964bdb9aa6a3952bf88"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ab3b1dab60bc2f964bdb9aa6a3952bf88">rotate_22</a> (const T &amp;angle)</td></tr>
<tr class="memdesc:ab3b1dab60bc2f964bdb9aa6a3952bf88"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a 2x2 rotation matrix around the z axis, the angle is in degree <br  />
 <br /></td></tr>
<tr class="separator:ab3b1dab60bc2f964bdb9aa6a3952bf88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be9e16273ef156049f7766118d2d1c2"><td class="memTemplParams" colspan="2"><a id="a7be9e16273ef156049f7766118d2d1c2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7be9e16273ef156049f7766118d2d1c2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a7be9e16273ef156049f7766118d2d1c2">rotate_euler_33</a> (const T &amp;yaw, const T &amp;pitch, const T &amp;roll)</td></tr>
<tr class="memdesc:a7be9e16273ef156049f7766118d2d1c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a 3x3 euler rotation matrix from yaw, pitch and roll given in degree <br /></td></tr>
<tr class="separator:a7be9e16273ef156049f7766118d2d1c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e87c4efe1ce93998b6e87a667dcf463"><td class="memTemplParams" colspan="2"><a id="a0e87c4efe1ce93998b6e87a667dcf463"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0e87c4efe1ce93998b6e87a667dcf463"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a0e87c4efe1ce93998b6e87a667dcf463">rotate_rodrigues_33</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;r)</td></tr>
<tr class="memdesc:a0e87c4efe1ce93998b6e87a667dcf463"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a 3x3 rotation matrix from a rodrigues vector <br /></td></tr>
<tr class="separator:a0e87c4efe1ce93998b6e87a667dcf463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8880baf768a767a53dbf0261b356a8"><td class="memTemplParams" colspan="2"><a id="aee8880baf768a767a53dbf0261b356a8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aee8880baf768a767a53dbf0261b356a8"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#aee8880baf768a767a53dbf0261b356a8">shearxy_33</a> (const T &amp;shx, const T &amp;shy)</td></tr>
<tr class="memdesc:aee8880baf768a767a53dbf0261b356a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a homogen 3x3 shear matrix with given shears shx in x direction, and shy in y direction <br /></td></tr>
<tr class="separator:aee8880baf768a767a53dbf0261b356a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dcd77ed27e7f6f1a6039a8d5b9aa7d2"><td class="memTemplParams" colspan="2"><a id="a9dcd77ed27e7f6f1a6039a8d5b9aa7d2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9dcd77ed27e7f6f1a6039a8d5b9aa7d2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a9dcd77ed27e7f6f1a6039a8d5b9aa7d2">shearxz_33</a> (const T &amp;shx, const T &amp;shz)</td></tr>
<tr class="memdesc:a9dcd77ed27e7f6f1a6039a8d5b9aa7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a homogen 3x3 shear matrix with given shears shx in x direction, and shy in y direction <br /></td></tr>
<tr class="separator:a9dcd77ed27e7f6f1a6039a8d5b9aa7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2d0dcf002caa9b75644e2e26485b84"><td class="memTemplParams" colspan="2"><a id="aed2d0dcf002caa9b75644e2e26485b84"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aed2d0dcf002caa9b75644e2e26485b84"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#aed2d0dcf002caa9b75644e2e26485b84">shearyz_33</a> (const T &amp;shy, const T &amp;shz)</td></tr>
<tr class="memdesc:aed2d0dcf002caa9b75644e2e26485b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a homogen 3x3 shear matrix with given shears shy in y direction, and shz in z direction <br /></td></tr>
<tr class="separator:aed2d0dcf002caa9b75644e2e26485b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dce7e66246f1276129c1e05e87ede77"><td class="memTemplParams" colspan="2"><a id="a8dce7e66246f1276129c1e05e87ede77"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8dce7e66246f1276129c1e05e87ede77"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a8dce7e66246f1276129c1e05e87ede77">shear_33</a> (const T &amp;syx, const T &amp;szx, const T &amp;sxy, const T &amp;szy, const T &amp;sxz, const T &amp;syz)</td></tr>
<tr class="memdesc:a8dce7e66246f1276129c1e05e87ede77"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a homogen 3x3 shear matrix <br /></td></tr>
<tr class="separator:a8dce7e66246f1276129c1e05e87ede77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2334fc8abf0502a02e53c0fe3f50fe1"><td class="memTemplParams" colspan="2"><a id="ae2334fc8abf0502a02e53c0fe3f50fe1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae2334fc8abf0502a02e53c0fe3f50fe1"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ae2334fc8abf0502a02e53c0fe3f50fe1">translate_44</a> (const T &amp;x, const T &amp;y, const T &amp;z)</td></tr>
<tr class="memdesc:ae2334fc8abf0502a02e53c0fe3f50fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a 4x4 translation matrix <br /></td></tr>
<tr class="separator:ae2334fc8abf0502a02e53c0fe3f50fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568b4d99cf097823e39290ab0de26e69"><td class="memTemplParams" colspan="2"><a id="a568b4d99cf097823e39290ab0de26e69"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a568b4d99cf097823e39290ab0de26e69"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a568b4d99cf097823e39290ab0de26e69">translate_44</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a568b4d99cf097823e39290ab0de26e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a 4x4 translation matrix <br /></td></tr>
<tr class="separator:a568b4d99cf097823e39290ab0de26e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0bceb8808fb01a77d3470ed3fc5d88"><td class="memTemplParams" colspan="2"><a id="aaa0bceb8808fb01a77d3470ed3fc5d88"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaa0bceb8808fb01a77d3470ed3fc5d88"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#aaa0bceb8808fb01a77d3470ed3fc5d88">scale_44</a> (const T &amp;sx, const T &amp;sy, const T &amp;sz)</td></tr>
<tr class="memdesc:aaa0bceb8808fb01a77d3470ed3fc5d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a 4x4 scale matrix <br /></td></tr>
<tr class="separator:aaa0bceb8808fb01a77d3470ed3fc5d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d32bbb09e0fecd28e0c212b33c0646f"><td class="memTemplParams" colspan="2"><a id="a0d32bbb09e0fecd28e0c212b33c0646f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0d32bbb09e0fecd28e0c212b33c0646f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a0d32bbb09e0fecd28e0c212b33c0646f">scale_44</a> (const T &amp;s)</td></tr>
<tr class="memdesc:a0d32bbb09e0fecd28e0c212b33c0646f"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a 4x4 uniform scale matrix <br /></td></tr>
<tr class="separator:a0d32bbb09e0fecd28e0c212b33c0646f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf10e12d3be0022b5a5b6ff7a4a3edc"><td class="memTemplParams" colspan="2"><a id="aabf10e12d3be0022b5a5b6ff7a4a3edc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aabf10e12d3be0022b5a5b6ff7a4a3edc"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#aabf10e12d3be0022b5a5b6ff7a4a3edc">rotatex_44</a> (const T &amp;angle)</td></tr>
<tr class="memdesc:aabf10e12d3be0022b5a5b6ff7a4a3edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a 4x4 rotation matrix around the x axis, the angle is in degree <br  />
 <br /></td></tr>
<tr class="separator:aabf10e12d3be0022b5a5b6ff7a4a3edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af1012c37e89444fe07e1db7095ce48"><td class="memTemplParams" colspan="2"><a id="a3af1012c37e89444fe07e1db7095ce48"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3af1012c37e89444fe07e1db7095ce48"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a3af1012c37e89444fe07e1db7095ce48">rotatey_44</a> (const T &amp;angle)</td></tr>
<tr class="memdesc:a3af1012c37e89444fe07e1db7095ce48"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a 4x4 rotation matrix around the y axis, the angle is in degree <br  />
 <br /></td></tr>
<tr class="separator:a3af1012c37e89444fe07e1db7095ce48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae6299da0f3744cc6b530f51c605d3d"><td class="memTemplParams" colspan="2"><a id="a8ae6299da0f3744cc6b530f51c605d3d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8ae6299da0f3744cc6b530f51c605d3d"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a8ae6299da0f3744cc6b530f51c605d3d">rotatez_44</a> (const T &amp;angle)</td></tr>
<tr class="memdesc:a8ae6299da0f3744cc6b530f51c605d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a 4x4 rotation matrix around the z axis, the angle is in degree <br  />
 <br /></td></tr>
<tr class="separator:a8ae6299da0f3744cc6b530f51c605d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e1fe663d9b1c90559970dbc8a67a63"><td class="memTemplParams" colspan="2"><a id="a02e1fe663d9b1c90559970dbc8a67a63"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a02e1fe663d9b1c90559970dbc8a67a63"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a02e1fe663d9b1c90559970dbc8a67a63">rotate_euler_44</a> (const T &amp;yaw, const T &amp;pitch, const T &amp;roll)</td></tr>
<tr class="memdesc:a02e1fe663d9b1c90559970dbc8a67a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a 4x4 euler rotation matrix from yaw, pitch and roll given in degree <br /></td></tr>
<tr class="separator:a02e1fe663d9b1c90559970dbc8a67a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018df25110f4041d6785f92dbc4d62bb"><td class="memTemplParams" colspan="2"><a id="a018df25110f4041d6785f92dbc4d62bb"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a018df25110f4041d6785f92dbc4d62bb"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a018df25110f4041d6785f92dbc4d62bb">shearxy_44</a> (const T &amp;shx, const T &amp;shy)</td></tr>
<tr class="memdesc:a018df25110f4041d6785f92dbc4d62bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a homogen 4x4 shear matrix with given shears shx in x direction, and shy in y direction <br /></td></tr>
<tr class="separator:a018df25110f4041d6785f92dbc4d62bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27af5bc5a31543c397b23cf457bb1ded"><td class="memTemplParams" colspan="2"><a id="a27af5bc5a31543c397b23cf457bb1ded"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a27af5bc5a31543c397b23cf457bb1ded"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a27af5bc5a31543c397b23cf457bb1ded">shearxz_44</a> (const T &amp;shx, const T &amp;shz)</td></tr>
<tr class="memdesc:a27af5bc5a31543c397b23cf457bb1ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a homogen 4x4 shear matrix with given shears shx in x direction, and shy in y direction <br /></td></tr>
<tr class="separator:a27af5bc5a31543c397b23cf457bb1ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5acdd483aead1daa92d9817fb46c68"><td class="memTemplParams" colspan="2"><a id="a5d5acdd483aead1daa92d9817fb46c68"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5d5acdd483aead1daa92d9817fb46c68"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a5d5acdd483aead1daa92d9817fb46c68">shearyz_44</a> (const T &amp;shy, const T &amp;shz)</td></tr>
<tr class="memdesc:a5d5acdd483aead1daa92d9817fb46c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a homogen 4x4 shear matrix with given shears shy in y direction, and shz in z direction <br /></td></tr>
<tr class="separator:a5d5acdd483aead1daa92d9817fb46c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f2a62ee6584cf62da2425dc7ee3d29"><td class="memTemplParams" colspan="2"><a id="a01f2a62ee6584cf62da2425dc7ee3d29"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a01f2a62ee6584cf62da2425dc7ee3d29"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a01f2a62ee6584cf62da2425dc7ee3d29">shear_44</a> (const T &amp;syx, const T &amp;szx, const T &amp;sxy, const T &amp;szy, const T &amp;sxz, const T &amp;syz)</td></tr>
<tr class="memdesc:a01f2a62ee6584cf62da2425dc7ee3d29"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a homogen 4x4 shear matrix <br /></td></tr>
<tr class="separator:a01f2a62ee6584cf62da2425dc7ee3d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba648b00ae542924b1b616fb3ebd1970"><td class="memTemplParams" colspan="2"><a id="aba648b00ae542924b1b616fb3ebd1970"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aba648b00ae542924b1b616fb3ebd1970"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#aba648b00ae542924b1b616fb3ebd1970">perspective_44</a> (const T &amp;fovy, const T &amp;aspect, const T &amp;znear, const T &amp;zfar)</td></tr>
<tr class="memdesc:aba648b00ae542924b1b616fb3ebd1970"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a perspective transformation matrix in the same way as gluPerspective does <br /></td></tr>
<tr class="separator:aba648b00ae542924b1b616fb3ebd1970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a5d4054e3dd13ffa072bc48e71e4fa"><td class="memTemplParams" colspan="2"><a id="a38a5d4054e3dd13ffa072bc48e71e4fa"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a38a5d4054e3dd13ffa072bc48e71e4fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a38a5d4054e3dd13ffa072bc48e71e4fa">viewport_44</a> (const T &amp;xoff, const T yoff, const T &amp;width, const T &amp;height)</td></tr>
<tr class="memdesc:a38a5d4054e3dd13ffa072bc48e71e4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a viewport transformation matrix <br /></td></tr>
<tr class="separator:a38a5d4054e3dd13ffa072bc48e71e4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66aa3ebe8fea232a892cb4d573d7417"><td class="memTemplParams" colspan="2"><a id="aa66aa3ebe8fea232a892cb4d573d7417"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa66aa3ebe8fea232a892cb4d573d7417"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#aa66aa3ebe8fea232a892cb4d573d7417">look_at_44</a> (const T &amp;eyex, const T &amp;eyey, const T &amp;eyez, const T &amp;centerx, const T &amp;centery, const T &amp;centerz, const T &amp;upx, const T &amp;upy, const T &amp;upz)</td></tr>
<tr class="memdesc:aa66aa3ebe8fea232a892cb4d573d7417"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a look at transformation matrix in the same way as gluLookAt does <br /></td></tr>
<tr class="separator:aa66aa3ebe8fea232a892cb4d573d7417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2863bde90a02f899c542ae1cc32050d6"><td class="memTemplParams" colspan="2"><a id="a2863bde90a02f899c542ae1cc32050d6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2863bde90a02f899c542ae1cc32050d6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a2863bde90a02f899c542ae1cc32050d6">frustrum_44</a> (const T &amp;left, const T &amp;right, const T &amp;bottom, const T &amp;top, const T &amp;znear, const T &amp;zfar)</td></tr>
<tr class="memdesc:a2863bde90a02f899c542ae1cc32050d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a frustrum projection matrix in the same way as glFrustum does <br /></td></tr>
<tr class="separator:a2863bde90a02f899c542ae1cc32050d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8f1728daa988d11083043934c019d6"><td class="memTemplParams" colspan="2"><a id="a6c8f1728daa988d11083043934c019d6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6c8f1728daa988d11083043934c019d6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a6c8f1728daa988d11083043934c019d6">ortho_44</a> (const T &amp;left, const T &amp;right, const T &amp;bottom, const T &amp;top, const T &amp;znear, const T &amp;zfar)</td></tr>
<tr class="memdesc:a6c8f1728daa988d11083043934c019d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates an orthographic projection matrix in the same way as glOrtho does <br /></td></tr>
<tr class="separator:a6c8f1728daa988d11083043934c019d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df8b010b858a0a2fd2913861084c5c2"><td class="memTemplParams" colspan="2"><a id="a0df8b010b858a0a2fd2913861084c5c2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0df8b010b858a0a2fd2913861084c5c2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a0df8b010b858a0a2fd2913861084c5c2">ortho2d_44</a> (const T &amp;left, const T &amp;right, const T &amp;bottom, const T &amp;top)</td></tr>
<tr class="memdesc:a0df8b010b858a0a2fd2913861084c5c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates an orthographic projection matrix in the same way as glOrtho2d does <br /></td></tr>
<tr class="separator:a0df8b010b858a0a2fd2913861084c5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1b531c1e2ddf68b8739abb1d882231"><td class="memTemplParams" colspan="2"><a id="a2c1b531c1e2ddf68b8739abb1d882231"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2c1b531c1e2ddf68b8739abb1d882231"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a2c1b531c1e2ddf68b8739abb1d882231">pick_44</a> (const T &amp;x, const T &amp;y, const T &amp;width, const T &amp;height, int viewport[4], const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; double &gt; &amp;modelviewproj, bool flipy=true)</td></tr>
<tr class="memdesc:a2c1b531c1e2ddf68b8739abb1d882231"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a picking matrix like gluPickMatrix with pixel (0,0) in the lower left corner if flipy=false <br /></td></tr>
<tr class="separator:a2c1b531c1e2ddf68b8739abb1d882231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01d48e28fc77aefd5993faaa641e01a"><td class="memTemplParams" colspan="2"><a id="ad01d48e28fc77aefd5993faaa641e01a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad01d48e28fc77aefd5993faaa641e01a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ad01d48e28fc77aefd5993faaa641e01a">operator&lt;&lt;</a> (std::ostream &amp;out, const up_tri_mat&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:ad01d48e28fc77aefd5993faaa641e01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">output of a upper triangular matrix onto an ostream <br /></td></tr>
<tr class="separator:ad01d48e28fc77aefd5993faaa641e01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978d343e4d9cdf3c74249b3a9aefef15"><td class="memTemplParams" colspan="2"><a id="a978d343e4d9cdf3c74249b3a9aefef15"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a978d343e4d9cdf3c74249b3a9aefef15"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a978d343e4d9cdf3c74249b3a9aefef15">normalize</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a978d343e4d9cdf3c74249b3a9aefef15"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a normalized version of v <br /></td></tr>
<tr class="separator:a978d343e4d9cdf3c74249b3a9aefef15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260bd673b8bd169234bb7c214f80e7c4"><td class="memTemplParams" colspan="2"><a id="a260bd673b8bd169234bb7c214f80e7c4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a260bd673b8bd169234bb7c214f80e7c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a260bd673b8bd169234bb7c214f80e7c4">safe_normalize</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a260bd673b8bd169234bb7c214f80e7c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a normalized version of v or zero vector if length is zero <br /></td></tr>
<tr class="separator:a260bd673b8bd169234bb7c214f80e7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411bac494c2af0cff2a023a575ddeb2a"><td class="memTemplParams" colspan="2"><a id="a411bac494c2af0cff2a023a575ddeb2a"></a>
template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:a411bac494c2af0cff2a023a575ddeb2a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a411bac494c2af0cff2a023a575ddeb2a">p_norm</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;values, const S &amp;p=1)</td></tr>
<tr class="memdesc:a411bac494c2af0cff2a023a575ddeb2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the p-norm of the vector default is p == 1 <br /></td></tr>
<tr class="separator:a411bac494c2af0cff2a023a575ddeb2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d1188e252c04e6abccec35eed56d8f"><td class="memTemplParams" colspan="2"><a id="af8d1188e252c04e6abccec35eed56d8f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af8d1188e252c04e6abccec35eed56d8f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#af8d1188e252c04e6abccec35eed56d8f">inf_norm</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;values)</td></tr>
<tr class="memdesc:af8d1188e252c04e6abccec35eed56d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the infinity norm of the vector <br /></td></tr>
<tr class="separator:af8d1188e252c04e6abccec35eed56d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa61b101ea94ade16da7638005ec0401"><td class="memTemplParams" colspan="2"><a id="aaa61b101ea94ade16da7638005ec0401"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaa61b101ea94ade16da7638005ec0401"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#aaa61b101ea94ade16da7638005ec0401">length</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:aaa61b101ea94ade16da7638005ec0401"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the length of v L2-norm <br /></td></tr>
<tr class="separator:aaa61b101ea94ade16da7638005ec0401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28f6653e67305af650b4403934a1c13"><td class="memTemplParams" colspan="2"><a id="ab28f6653e67305af650b4403934a1c13"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab28f6653e67305af650b4403934a1c13"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ab28f6653e67305af650b4403934a1c13">sqr_length</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:ab28f6653e67305af650b4403934a1c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the square length of v <br /></td></tr>
<tr class="separator:ab28f6653e67305af650b4403934a1c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1b0c1188a0d3f1778c36ec35a32168"><td class="memTemplParams" colspan="2"><a id="abc1b0c1188a0d3f1778c36ec35a32168"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abc1b0c1188a0d3f1778c36ec35a32168"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#abc1b0c1188a0d3f1778c36ec35a32168">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:abc1b0c1188a0d3f1778c36ec35a32168"><td class="mdescLeft">&#160;</td><td class="mdescRight">output of a vector <br /></td></tr>
<tr class="separator:abc1b0c1188a0d3f1778c36ec35a32168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ef485c2fbf3a9f9b9caed9aa4df0e1"><td class="memTemplParams" colspan="2"><a id="a89ef485c2fbf3a9f9b9caed9aa4df0e1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a89ef485c2fbf3a9f9b9caed9aa4df0e1"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a89ef485c2fbf3a9f9b9caed9aa4df0e1">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a89ef485c2fbf3a9f9b9caed9aa4df0e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">input of a vector <br /></td></tr>
<tr class="separator:a89ef485c2fbf3a9f9b9caed9aa4df0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0587d310c6306b8bde844d11bac48504"><td class="memTemplParams" colspan="2"><a id="a0587d310c6306b8bde844d11bac48504"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0587d310c6306b8bde844d11bac48504"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a0587d310c6306b8bde844d11bac48504">operator*</a> (const T &amp;s, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a0587d310c6306b8bde844d11bac48504"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the product of a scalar s and vector v <br /></td></tr>
<tr class="separator:a0587d310c6306b8bde844d11bac48504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04bd0d69da4c57797eb232aca3b0d6b"><td class="memTemplParams" colspan="2"><a id="ad04bd0d69da4c57797eb232aca3b0d6b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad04bd0d69da4c57797eb232aca3b0d6b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ad04bd0d69da4c57797eb232aca3b0d6b">dot</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;v, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;w)</td></tr>
<tr class="memdesc:ad04bd0d69da4c57797eb232aca3b0d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the dot product of vector v and w <br /></td></tr>
<tr class="separator:ad04bd0d69da4c57797eb232aca3b0d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a44bdf6929252f47d50baac7da1425"><td class="memTemplParams" colspan="2"><a id="ae9a44bdf6929252f47d50baac7da1425"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae9a44bdf6929252f47d50baac7da1425"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ae9a44bdf6929252f47d50baac7da1425">cross</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;v, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;w)</td></tr>
<tr class="memdesc:ae9a44bdf6929252f47d50baac7da1425"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the cross product of vector v and w <br /></td></tr>
<tr class="separator:ae9a44bdf6929252f47d50baac7da1425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0b909a09ab10500fd3683689258851"><td class="memTemplParams" colspan="2"><a id="a2b0b909a09ab10500fd3683689258851"></a>
template&lt;typename T , typename S , typename U &gt; </td></tr>
<tr class="memitem:a2b0b909a09ab10500fd3683689258851"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a2b0b909a09ab10500fd3683689258851">dbl_cross</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;a, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; S &gt; &amp;b, <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; U &gt; &amp;c)</td></tr>
<tr class="memdesc:a2b0b909a09ab10500fd3683689258851"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the double cross product of vector a, b and c a x(b x c) <br /></td></tr>
<tr class="separator:a2b0b909a09ab10500fd3683689258851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a062bc927d2831ed28939db3703480"><td class="memTemplParams" colspan="2"><a id="a69a062bc927d2831ed28939db3703480"></a>
template&lt;typename T , typename S , typename U &gt; </td></tr>
<tr class="memitem:a69a062bc927d2831ed28939db3703480"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a69a062bc927d2831ed28939db3703480">spat</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;a, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; S &gt; &amp;b, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; U &gt; &amp;c)</td></tr>
<tr class="memdesc:a69a062bc927d2831ed28939db3703480"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the spat product (mixed vector product) of the vectors a, b and c <br /></td></tr>
<tr class="separator:a69a062bc927d2831ed28939db3703480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f1b79975130902277a2c38eb2ad56b"><td class="memTemplParams" colspan="2"><a id="a92f1b79975130902277a2c38eb2ad56b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a92f1b79975130902277a2c38eb2ad56b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a92f1b79975130902277a2c38eb2ad56b">project</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;v, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;n)</td></tr>
<tr class="memdesc:a92f1b79975130902277a2c38eb2ad56b"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates the projection of v onto n <br /></td></tr>
<tr class="separator:a92f1b79975130902277a2c38eb2ad56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5be51992b338933231c56f5b235e3e"><td class="memTemplParams" colspan="2"><a id="afa5be51992b338933231c56f5b235e3e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afa5be51992b338933231c56f5b235e3e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#afa5be51992b338933231c56f5b235e3e">reflect</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;v, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;n)</td></tr>
<tr class="memdesc:afa5be51992b338933231c56f5b235e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates the reflected direction of v; n is the normal of the reflecting surface <br /></td></tr>
<tr class="separator:afa5be51992b338933231c56f5b235e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b97afa2f0ea55aa60e8e2bbb16da022"><td class="memTemplParams" colspan="2"><a id="a7b97afa2f0ea55aa60e8e2bbb16da022"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7b97afa2f0ea55aa60e8e2bbb16da022"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a7b97afa2f0ea55aa60e8e2bbb16da022">refract</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;v, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;n, T c1, T c2, bool *total_reflection=NULL)</td></tr>
<tr class="memdesc:a7b97afa2f0ea55aa60e8e2bbb16da022"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates the refracted direction of v on a surface with normal n and refraction indices c1,c2, *the optional parameter total reflection will be set true if a total reflection occured otherwise false <br /></td></tr>
<tr class="separator:a7b97afa2f0ea55aa60e8e2bbb16da022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769b0239ad7921d1debc13210eed9f1d"><td class="memTemplParams" colspan="2"><a id="a769b0239ad7921d1debc13210eed9f1d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a769b0239ad7921d1debc13210eed9f1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a769b0239ad7921d1debc13210eed9f1d">zeros</a> (const unsigned dim)</td></tr>
<tr class="memdesc:a769b0239ad7921d1debc13210eed9f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a zero vector <br /></td></tr>
<tr class="separator:a769b0239ad7921d1debc13210eed9f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9867b26ce794ca923d333cfaddcc5a"><td class="memTemplParams" colspan="2"><a id="a0b9867b26ce794ca923d333cfaddcc5a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0b9867b26ce794ca923d333cfaddcc5a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a0b9867b26ce794ca923d333cfaddcc5a">ones</a> (const unsigned dim)</td></tr>
<tr class="memdesc:a0b9867b26ce794ca923d333cfaddcc5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a one vector <br /></td></tr>
<tr class="separator:a0b9867b26ce794ca923d333cfaddcc5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51fdbe5f90df73b06330b40a7183aeb5"><td class="memTemplParams" colspan="2"><a id="a51fdbe5f90df73b06330b40a7183aeb5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a51fdbe5f90df73b06330b40a7183aeb5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a51fdbe5f90df73b06330b40a7183aeb5">floor</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a51fdbe5f90df73b06330b40a7183aeb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of componentwise floor values <br /></td></tr>
<tr class="separator:a51fdbe5f90df73b06330b40a7183aeb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afafe8353045ba1bc1dd078cedb40ab4b"><td class="memTemplParams" colspan="2"><a id="afafe8353045ba1bc1dd078cedb40ab4b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afafe8353045ba1bc1dd078cedb40ab4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#afafe8353045ba1bc1dd078cedb40ab4b">ceil</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:afafe8353045ba1bc1dd078cedb40ab4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of componentwise ceil values <br /></td></tr>
<tr class="separator:afafe8353045ba1bc1dd078cedb40ab4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944f7ad3594fbba4d34b9cef164f5943"><td class="memTemplParams" colspan="2"><a id="a944f7ad3594fbba4d34b9cef164f5943"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a944f7ad3594fbba4d34b9cef164f5943"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a944f7ad3594fbba4d34b9cef164f5943">round</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a944f7ad3594fbba4d34b9cef164f5943"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of componentwise ceil values <br /></td></tr>
<tr class="separator:a944f7ad3594fbba4d34b9cef164f5943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80001be79832e6abc3a7aa6493b3ea93"><td class="memTemplParams" colspan="2"><a id="a80001be79832e6abc3a7aa6493b3ea93"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a80001be79832e6abc3a7aa6493b3ea93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a80001be79832e6abc3a7aa6493b3ea93">abs</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a80001be79832e6abc3a7aa6493b3ea93"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of componentwise absolute values <br /></td></tr>
<tr class="separator:a80001be79832e6abc3a7aa6493b3ea93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c1c814d97961c2e09941d1b139d050"><td class="memTemplParams" colspan="2"><a id="a20c1c814d97961c2e09941d1b139d050"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a20c1c814d97961c2e09941d1b139d050"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a20c1c814d97961c2e09941d1b139d050">min_value</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a20c1c814d97961c2e09941d1b139d050"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the minimal entry <br /></td></tr>
<tr class="separator:a20c1c814d97961c2e09941d1b139d050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad026e67ce49ceabab907db2eb48d418"><td class="memTemplParams" colspan="2"><a id="aad026e67ce49ceabab907db2eb48d418"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aad026e67ce49ceabab907db2eb48d418"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#aad026e67ce49ceabab907db2eb48d418">min_index</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:aad026e67ce49ceabab907db2eb48d418"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the index of the smallest value <br /></td></tr>
<tr class="separator:aad026e67ce49ceabab907db2eb48d418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b30264dcb43c9e0fc553384e2568a2"><td class="memTemplParams" colspan="2"><a id="ad6b30264dcb43c9e0fc553384e2568a2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad6b30264dcb43c9e0fc553384e2568a2"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ad6b30264dcb43c9e0fc553384e2568a2">max_index</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:ad6b30264dcb43c9e0fc553384e2568a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the index of the largest entry <br /></td></tr>
<tr class="separator:ad6b30264dcb43c9e0fc553384e2568a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711536231cafdd24b89b94059ba6ec46"><td class="memTemplParams" colspan="2"><a id="a711536231cafdd24b89b94059ba6ec46"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a711536231cafdd24b89b94059ba6ec46"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a711536231cafdd24b89b94059ba6ec46">max_value</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a711536231cafdd24b89b94059ba6ec46"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the value of the largest entry <br /></td></tr>
<tr class="separator:a711536231cafdd24b89b94059ba6ec46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe46549a352cc0c03a921e1a54531b1"><td class="memTemplParams" colspan="2"><a id="abbe46549a352cc0c03a921e1a54531b1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abbe46549a352cc0c03a921e1a54531b1"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#abbe46549a352cc0c03a921e1a54531b1">mean_value</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;values)</td></tr>
<tr class="memdesc:abbe46549a352cc0c03a921e1a54531b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the mean of all values <br /></td></tr>
<tr class="separator:abbe46549a352cc0c03a921e1a54531b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c378b0c8a7b79005500080d18dfdf0"><td class="memTemplParams" colspan="2"><a id="a59c378b0c8a7b79005500080d18dfdf0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a59c378b0c8a7b79005500080d18dfdf0"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a59c378b0c8a7b79005500080d18dfdf0">var_value</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;values)</td></tr>
<tr class="memdesc:a59c378b0c8a7b79005500080d18dfdf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the variance of all values, normalization is done with n-1 (unbiased estimator) <br /></td></tr>
<tr class="separator:a59c378b0c8a7b79005500080d18dfdf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b51b9b6a031832d8f5e61daae591d23"><td class="memTemplParams" colspan="2"><a id="a3b51b9b6a031832d8f5e61daae591d23"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3b51b9b6a031832d8f5e61daae591d23"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a3b51b9b6a031832d8f5e61daae591d23">range_value</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;values)</td></tr>
<tr class="memdesc:a3b51b9b6a031832d8f5e61daae591d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the range of all values <br /></td></tr>
<tr class="separator:a3b51b9b6a031832d8f5e61daae591d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d78d215cba9ac902cf783e07cacba82"><td class="memTemplParams" colspan="2"><a id="a1d78d215cba9ac902cf783e07cacba82"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1d78d215cba9ac902cf783e07cacba82"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a1d78d215cba9ac902cf783e07cacba82">mad_value</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;values)</td></tr>
<tr class="memdesc:a1d78d215cba9ac902cf783e07cacba82"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the median absolut deviation MAD <br /></td></tr>
<tr class="separator:a1d78d215cba9ac902cf783e07cacba82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fcaec03b9e45ded6d1f1e9eadfdffac"><td class="memTemplParams" colspan="2"><a id="a5fcaec03b9e45ded6d1f1e9eadfdffac"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5fcaec03b9e45ded6d1f1e9eadfdffac"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a5fcaec03b9e45ded6d1f1e9eadfdffac">std_value</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;values)</td></tr>
<tr class="memdesc:a5fcaec03b9e45ded6d1f1e9eadfdffac"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the standard deviation (sigma) of all values, normalization is done by n-1 (unbiased estimator) <br /></td></tr>
<tr class="separator:a5fcaec03b9e45ded6d1f1e9eadfdffac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a8c243810ff53fe2dba27b052ae806"><td class="memTemplParams" colspan="2"><a id="a10a8c243810ff53fe2dba27b052ae806"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a10a8c243810ff53fe2dba27b052ae806"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a10a8c243810ff53fe2dba27b052ae806">var_and_mean_value</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;values, T &amp;mu, T &amp;var)</td></tr>
<tr class="memdesc:a10a8c243810ff53fe2dba27b052ae806"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the mean and the variance (sigma^2) of all values <br /></td></tr>
<tr class="separator:a10a8c243810ff53fe2dba27b052ae806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52846938f1183bd690188020682e84b"><td class="memTemplParams" colspan="2"><a id="aa52846938f1183bd690188020682e84b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa52846938f1183bd690188020682e84b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#aa52846938f1183bd690188020682e84b">sort_values</a> (<a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;values, bool ascending=true)</td></tr>
<tr class="memdesc:aa52846938f1183bd690188020682e84b"><td class="mdescLeft">&#160;</td><td class="mdescRight">sort vector elements in ascending or descending order <br /></td></tr>
<tr class="separator:aa52846938f1183bd690188020682e84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ebc3f83af00eb06620f61e7e3e06e4"><td class="memTemplParams" colspan="2"><a id="a68ebc3f83af00eb06620f61e7e3e06e4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a68ebc3f83af00eb06620f61e7e3e06e4"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a68ebc3f83af00eb06620f61e7e3e06e4">sum_values</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;values)</td></tr>
<tr class="memdesc:a68ebc3f83af00eb06620f61e7e3e06e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the sum of all entries <br /></td></tr>
<tr class="separator:a68ebc3f83af00eb06620f61e7e3e06e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb1cc83fc48654f1d5bd9982e1db1e2"><td class="memTemplParams" colspan="2"><a id="a7fb1cc83fc48654f1d5bd9982e1db1e2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7fb1cc83fc48654f1d5bd9982e1db1e2"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a7fb1cc83fc48654f1d5bd9982e1db1e2">cumsum_values</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;values, <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;cumsumvalues)</td></tr>
<tr class="memdesc:a7fb1cc83fc48654f1d5bd9982e1db1e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes cumulative sums in cumsumvalues cumsumvalues[i] = values[0]+...+values[i-1] returns the sum of all entries <br /></td></tr>
<tr class="separator:a7fb1cc83fc48654f1d5bd9982e1db1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1a24be3eae3ff595cecbaa3a4f4ad3"><td class="memTemplParams" colspan="2"><a id="adf1a24be3eae3ff595cecbaa3a4f4ad3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:adf1a24be3eae3ff595cecbaa3a4f4ad3"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#adf1a24be3eae3ff595cecbaa3a4f4ad3">prod_values</a> (<a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;values)</td></tr>
<tr class="memdesc:adf1a24be3eae3ff595cecbaa3a4f4ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the product of all entries <br /></td></tr>
<tr class="separator:adf1a24be3eae3ff595cecbaa3a4f4ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9115b6999049fb851dc6da02c0ca31"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0d9115b6999049fb851dc6da02c0ca31"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a0d9115b6999049fb851dc6da02c0ca31">select_value</a> (unsigned k, <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;values)</td></tr>
<tr class="memdesc:a0d9115b6999049fb851dc6da02c0ca31"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the kth-smallest value of values the input vector values will be rearranged to have this value in location arr[k], with all smaller elements moved to values[0..k-1] (in arbitrary order) and all larger elements in values[k+1..n] (also in arbitrary order).  <a href="namespacecgv_1_1math.html#a0d9115b6999049fb851dc6da02c0ca31">More...</a><br /></td></tr>
<tr class="separator:a0d9115b6999049fb851dc6da02c0ca31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10dff5b4a5e3e3f3727272dc9b129be5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a10dff5b4a5e3e3f3727272dc9b129be5"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a10dff5b4a5e3e3f3727272dc9b129be5">select_median_value</a> (<a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;values)</td></tr>
<tr class="memdesc:a10dff5b4a5e3e3f3727272dc9b129be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the value of values the input vector arr will be rearanged to have this value in location arr[k], with all smaller elements moved to values[0..k-1] (in arbitrary order) and all larger elements in values[k+1..n] (also in arbitrary order).  <a href="namespacecgv_1_1math.html#a10dff5b4a5e3e3f3727272dc9b129be5">More...</a><br /></td></tr>
<tr class="separator:a10dff5b4a5e3e3f3727272dc9b129be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64f0dd9dca92bc57478fd01ec0abf57"><td class="memTemplParams" colspan="2"><a id="ab64f0dd9dca92bc57478fd01ec0abf57"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab64f0dd9dca92bc57478fd01ec0abf57"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ab64f0dd9dca92bc57478fd01ec0abf57">median_value</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;values)</td></tr>
<tr class="memdesc:ab64f0dd9dca92bc57478fd01ec0abf57"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns median element without modifying the given vector <br /></td></tr>
<tr class="separator:ab64f0dd9dca92bc57478fd01ec0abf57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d770ccb1369c369afc7f1f5b01c2c1"><td class="memTemplParams" colspan="2"><a id="a62d770ccb1369c369afc7f1f5b01c2c1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a62d770ccb1369c369afc7f1f5b01c2c1"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a62d770ccb1369c369afc7f1f5b01c2c1">lin_space</a> (const T &amp;first_val, const T &amp;last_val, unsigned N=10)</td></tr>
<tr class="memdesc:a62d770ccb1369c369afc7f1f5b01c2c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a linearly spaced vector with N values starting at first_val and ending ant last_val <br /></td></tr>
<tr class="separator:a62d770ccb1369c369afc7f1f5b01c2c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33cb46398dd66cb74e2355ce3d2373f"><td class="memTemplParams" colspan="2"><a id="ab33cb46398dd66cb74e2355ce3d2373f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab33cb46398dd66cb74e2355ce3d2373f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ab33cb46398dd66cb74e2355ce3d2373f">log_space</a> (const T &amp;first_pow_of_10, const T &amp;last_pow_of_10, unsigned N=10)</td></tr>
<tr class="memdesc:ab33cb46398dd66cb74e2355ce3d2373f"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a log spaced vector with N values starting at 10^first_pow_of_10 and ending at 10 last_val <br /></td></tr>
<tr class="separator:ab33cb46398dd66cb74e2355ce3d2373f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1bd16fe490d8607e7b1051795cd9ad4"><td class="memTemplParams" colspan="2"><a id="ae1bd16fe490d8607e7b1051795cd9ad4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae1bd16fe490d8607e7b1051795cd9ad4"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ae1bd16fe490d8607e7b1051795cd9ad4">lerp</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;v1, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;v2, T t)</td></tr>
<tr class="memdesc:ae1bd16fe490d8607e7b1051795cd9ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">linear interpolation returns (1-t)*v1 + t*v2 <br /></td></tr>
<tr class="separator:ae1bd16fe490d8607e7b1051795cd9ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106cc64d2bdc02a0c169d79901eea313"><td class="memTemplParams" colspan="2"><a id="a106cc64d2bdc02a0c169d79901eea313"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a106cc64d2bdc02a0c169d79901eea313"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a106cc64d2bdc02a0c169d79901eea313">slerp</a> (const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;v0, const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;v1, T t)</td></tr>
<tr class="memdesc:a106cc64d2bdc02a0c169d79901eea313"><td class="mdescLeft">&#160;</td><td class="mdescRight">spherical linear interpolation <br /></td></tr>
<tr class="separator:a106cc64d2bdc02a0c169d79901eea313"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a586480b4ea85b19aef8d6a1b752f9815"><td class="memItemLeft" align="right" valign="top"><a id="a586480b4ea85b19aef8d6a1b752f9815"></a>
static const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#a586480b4ea85b19aef8d6a1b752f9815">WGS84_a</a> = 6378137.0</td></tr>
<tr class="memdesc:a586480b4ea85b19aef8d6a1b752f9815"><td class="mdescLeft">&#160;</td><td class="mdescRight">major axis length of WGS84 ellipsoid <br /></td></tr>
<tr class="separator:a586480b4ea85b19aef8d6a1b752f9815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d04164120bee6630b604a2a0f6a4ee"><td class="memItemLeft" align="right" valign="top"><a id="ac9d04164120bee6630b604a2a0f6a4ee"></a>
static const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1math.html#ac9d04164120bee6630b604a2a0f6a4ee">WGS84_e</a> = 0.081819191</td></tr>
<tr class="memdesc:ac9d04164120bee6630b604a2a0f6a4ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">excentricity of WGS84 ellipsoid <br /></td></tr>
<tr class="separator:ac9d04164120bee6630b604a2a0f6a4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>namespace with classes and algorithms for mathematics </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a412054fabb1f60c7076fb8f714dbe77b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a412054fabb1f60c7076fb8f714dbe77b">&#9670;&nbsp;</a></span>AIC()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T cgv::math::AIC </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Akaike's: An Information Criterion k...number of parameters L...maximized value of likelihood function for estimated model n/k should be &gt; 40 otherwise use AICc (n ... </p>
<p>number of samples) </p>

<p class="definition">Definition at line <a class="el" href="model__comp_8h_source.html#l00013">13</a> of file <a class="el" href="model__comp_8h_source.html">model_comp.h</a>.</p>

</div>
</div>
<a id="aa3c70cac0aed64ef9cb752790c0c1a23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3c70cac0aed64ef9cb752790c0c1a23">&#9670;&nbsp;</a></span>AICc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T cgv::math::AICc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Akaike's: An information criterion with second order correction term k...number of parameters n. </p>
<p>. number of samples L...maximized value of likelihood function for estimated model </p>

<p class="definition">Definition at line <a class="el" href="model__comp_8h_source.html#l00035">35</a> of file <a class="el" href="model__comp_8h_source.html">model_comp.h</a>.</p>

</div>
</div>
<a id="aa8527540ec203ab48b8d29c34602218f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8527540ec203ab48b8d29c34602218f">&#9670;&nbsp;</a></span>align()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T_SVD  = T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cgv::math::align </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>source_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcgv_1_1math_1_1fmat.html">fmat</a>&lt; T, 3, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>O</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>scale_ptr</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_reflection</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute rigid body transformation and optionally uniform scaling to align source point set to target point set in least squares sense </p>
<p>Given source points X and target points Y find orthogonal matrix O\in O(3), translation vector t\in R^3 and optionally scale factor s &gt; 0 to minimize</p>
<p>\sum_i ||y_i - (s*O*x_i + t)||^2</p>
<p>Optionally, one can enforce O to be a rotation. Algorithm taken from</p>
<p>Umeyama, Shinji. "Least-squares estimation of transformation parameters between two point patterns." IEEE Transactions on pattern analysis and machine intelligence 13.4 (1991): 376-380.</p>
<p>Second template argument allows to specify a different number type for svd computation </p>

<p class="definition">Definition at line <a class="el" href="align_8h_source.html#l00053">53</a> of file <a class="el" href="align_8h_source.html">align.h</a>.</p>

<p class="reference">References <a class="el" href="fmat_8h_source.html#l00241">cgv::math::fmat&lt; T, N, M &gt;::identity()</a>, <a class="el" href="align_8h_source.html#l00014">mean()</a>, <a class="el" href="fvec_8h_source.html#l00466">sqr_length()</a>, and <a class="el" href="align_8h_source.html#l00025">svd()</a>.</p>

</div>
</div>
<a id="adfb844540e70f134515a6e5114f163da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb844540e70f134515a6e5114f163da">&#9670;&nbsp;</a></span>apply_nonrigid_transformation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cgv::math::apply_nonrigid_transformation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcgv_1_1math_1_1thin__hyper__plate__spline.html">thin_hyper_plate_spline</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>apply thin-hyper-plate-spline deformation in-place (without producing a copy of the points). </p>
<p>This method should be used if a large number of points have to be deformed </p>

<p class="definition">Definition at line <a class="el" href="thin__plate__spline_8h_source.html#l00289">289</a> of file <a class="el" href="thin__plate__spline_8h_source.html">thin_plate_spline.h</a>.</p>

<p class="reference">References <a class="el" href="mat_8h_source.html#l00839">cgv::math::mat&lt; T &gt;::col()</a>, <a class="el" href="thin__plate__spline_8h_source.html#l00161">cgv::math::thin_hyper_plate_spline&lt; T &gt;::map_position()</a>, <a class="el" href="mat_8h_source.html#l00547">cgv::math::mat&lt; T &gt;::ncols()</a>, <a class="el" href="mat_8h_source.html#l00541">cgv::math::mat&lt; T &gt;::nrows()</a>, and <a class="el" href="mat_8h_source.html#l00852">cgv::math::mat&lt; T &gt;::set_col()</a>.</p>

</div>
</div>
<a id="a9716f3d02a56270fbad9174562bec242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9716f3d02a56270fbad9174562bec242">&#9670;&nbsp;</a></span>apply_nonrigid_transformation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cgv::math::apply_nonrigid_transformation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcgv_1_1math_1_1thin__plate__spline.html">thin_plate_spline</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>apply thin-plate-spline deformation in-place (without producing a copy of the points). </p>
<p>This method should be used if a large number of points have to be deformed </p>

<p class="definition">Definition at line <a class="el" href="thin__plate__spline_8h_source.html#l00277">277</a> of file <a class="el" href="thin__plate__spline_8h_source.html">thin_plate_spline.h</a>.</p>

<p class="reference">References <a class="el" href="mat_8h_source.html#l00839">cgv::math::mat&lt; T &gt;::col()</a>, <a class="el" href="thin__plate__spline_8h_source.html#l00021">cgv::math::thin_plate_spline&lt; T &gt;::map_position()</a>, <a class="el" href="mat_8h_source.html#l00547">cgv::math::mat&lt; T &gt;::ncols()</a>, <a class="el" href="mat_8h_source.html#l00541">cgv::math::mat&lt; T &gt;::nrows()</a>, and <a class="el" href="mat_8h_source.html#l00852">cgv::math::mat&lt; T &gt;::set_col()</a>.</p>

</div>
</div>
<a id="a334232cf858e03e53db9bbf416fc76e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a334232cf858e03e53db9bbf416fc76e3">&#9670;&nbsp;</a></span>bipoly_val()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T cgv::math::bipoly_val </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>bp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>bivariate polynomials are stored in matrices in the following order: [a,b,c,d a*x1^3*x2^3 + b*x1^2*x2^3 + c*x1*x2^3 + d*x2^3 + e,f,g,h e*x1^3*x2^2 + f*x1^2*x2^2 + g*x1*x2^2 + h*x2^2 + i,j,k,l i*x1^3*x2 + j*x1^2*x2 + k*x1*x2 + l*x2 + m,n,o,p] m*x1^3 + n*x1^2 + o*x1 + p <br  />
 </p>
<p>evaluate a bivariate polynomial p at (x1,x2) p is the coefficients matrix of the bivariate polynomial evaluation is done by using the horner scheme </p>

<p class="definition">Definition at line <a class="el" href="bi__polynomial_8h_source.html#l00020">20</a> of file <a class="el" href="bi__polynomial_8h_source.html">bi_polynomial.h</a>.</p>

<p class="reference">References <a class="el" href="mat_8h_source.html#l00547">cgv::math::mat&lt; T &gt;::ncols()</a>, <a class="el" href="mat_8h_source.html#l00541">cgv::math::mat&lt; T &gt;::nrows()</a>, <a class="el" href="polynomial_8h_source.html#l00026">poly_val()</a>, and <a class="el" href="mat_8h_source.html#l00816">cgv::math::mat&lt; T &gt;::row()</a>.</p>

</div>
</div>
<a id="a6c08fa6907f5b41a0f22362f9013f220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c08fa6907f5b41a0f22362f9013f220">&#9670;&nbsp;</a></span>bresenham()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;<a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt;int, 2&gt; &gt; cgv::math::bresenham </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; int, 2 &gt;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; int, 2 &gt;&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a list of points along a rasterized line according to Bresenham's line drawing algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The line start point. </td></tr>
    <tr><td class="paramname">end</td><td>The line end point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of rasterized points. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bresenham_8h_source.html#l00015">15</a> of file <a class="el" href="bresenham_8h_source.html">bresenham.h</a>.</p>

<p class="reference">References <a class="el" href="fvec_8h_source.html#l00154">cgv::math::fvec&lt; T, N &gt;::x()</a>, and <a class="el" href="fvec_8h_source.html#l00158">cgv::math::fvec&lt; T, N &gt;::y()</a>.</p>

</div>
</div>
<a id="ae603218d7efcd704cd6e26a753aa1f98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae603218d7efcd704cd6e26a753aa1f98">&#9670;&nbsp;</a></span>build_orthogonal_frame()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcgv_1_1math_1_1fmat.html">cgv::math::fmat</a>&lt;T, 3, 3&gt; cgv::math::build_orthogonal_frame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">cgv::math::fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">cgv::math::fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given two vectors v0 and v1 extend to orthonormal frame and return 3x3 matrix containing frame vectors in the columns. </p>
<p>The implementation has the following assumptions that are not checked:</p><ul>
<li>v0.length() &gt; 0</li>
<li>v1.length() &gt; 0</li>
<li>v0 and v1 are not parallel or anti-parallel If the result matrix has columns x,y, and z,</li>
<li>x will point in direction of v0</li>
<li>z will point orthogonal to x and v1</li>
<li>y will point orthogonal to x and z as good as possible in direction of v1. If v0 and v1 are orthogonal, y is in direction of v1. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="geom_8h_source.html#l00076">76</a> of file <a class="el" href="geom_8h_source.html">geom.h</a>.</p>

<p class="reference">References <a class="el" href="fvec_8h_source.html#l00473">cross()</a>, and <a class="el" href="fvec_8h_source.html#l00297">cgv::math::fvec&lt; T, N &gt;::normalize()</a>.</p>

<p class="reference">Referenced by <a class="el" href="view_8cxx_source.html#l00027">cgv::render::view::compute_axis_and_angle()</a>.</p>

</div>
</div>
<a id="a6b8efb9003373293771346e3144e312c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b8efb9003373293771346e3144e312c">&#9670;&nbsp;</a></span>closest_point_on_box_to_point() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cgv::math::closest_point_on_box_to_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>bo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>be</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find point on box closest to reference point. </p>
<p>If reference point is in the interior, return reference point</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>coordinate type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bo</td><td>box center</td></tr>
    <tr><td class="paramname">be</td><td>box extent</td></tr>
    <tr><td class="paramname">p</td><td>reference point</td></tr>
    <tr><td class="paramname">q</td><td>closest point</td></tr>
    <tr><td class="paramname">n</td><td>normal at closest point if this is on the box surfaces, otherwise the 0 vector</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="proximity_8h_source.html#l00036">36</a> of file <a class="el" href="proximity_8h_source.html">proximity.h</a>.</p>

</div>
</div>
<a id="a4576ca7326c745f021e3a2a643064ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4576ca7326c745f021e3a2a643064ccf">&#9670;&nbsp;</a></span>closest_point_on_box_to_point() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cgv::math::closest_point_on_box_to_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>bo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>be</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1quaternion.html">quaternion</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>bq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find point on box closest to reference point. </p>
<p>If reference point is in the interior, return reference point</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>coordinate type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bo</td><td>box center</td></tr>
    <tr><td class="paramname">be</td><td>box extent</td></tr>
    <tr><td class="paramname">bq</td><td>box rotation as quaternion</td></tr>
    <tr><td class="paramname">p</td><td>reference point</td></tr>
    <tr><td class="paramname">q</td><td>closest point</td></tr>
    <tr><td class="paramname">n</td><td>normal at closest point if this is on the box surfaces, otherwise the 0 vector</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="proximity_8h_source.html#l00076">76</a> of file <a class="el" href="proximity_8h_source.html">proximity.h</a>.</p>

<p class="reference">References <a class="el" href="quaternion_8h_source.html#l00217">cgv::math::quaternion&lt; T &gt;::inverse_rotate()</a>, and <a class="el" href="quaternion_8h_source.html#l00198">cgv::math::quaternion&lt; T &gt;::rotate()</a>.</p>

</div>
</div>
<a id="a74963f56ae9f1d8eb6b0820b8a3debe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74963f56ae9f1d8eb6b0820b8a3debe8">&#9670;&nbsp;</a></span>closest_point_on_circle_to_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::math::closest_point_on_circle_to_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>co</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>cn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>cr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find point on circle closest to reference point </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>coordinate type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">co</td><td>circle center</td></tr>
    <tr><td class="paramname">cn</td><td>circle plane normal</td></tr>
    <tr><td class="paramname">cr</td><td>circle radius</td></tr>
    <tr><td class="paramname">p</td><td>reference point</td></tr>
    <tr><td class="paramname">q</td><td>point on circle closest to reference point, if this exists</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether closest point on circle exists, what is not the case for points on line through circle center orthogonal to circle plane</dd></dl>

<p class="definition">Definition at line <a class="el" href="proximity_8h_source.html#l00203">203</a> of file <a class="el" href="proximity_8h_source.html">proximity.h</a>.</p>

<p class="reference">References <a class="el" href="fvec_8h_source.html#l00386">dot()</a>, and <a class="el" href="fvec_8h_source.html#l00244">cgv::math::fvec&lt; T, N &gt;::length()</a>.</p>

</div>
</div>
<a id="a381120144e883526bd8d28c3b49d1fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a381120144e883526bd8d28c3b49d1fb8">&#9670;&nbsp;</a></span>closest_point_on_cylinder_to_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cgv::math::closest_point_on_cylinder_to_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>co</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>cd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>cr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find point on cylinder closest to reference point </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>coordinate type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">co</td><td>cylinder base center</td></tr>
    <tr><td class="paramname">cd</td><td>vector pointing from cylinder base center to cylinder top center</td></tr>
    <tr><td class="paramname">cr</td><td>cylinder radius</td></tr>
    <tr><td class="paramname">p</td><td>reference point</td></tr>
    <tr><td class="paramname">q</td><td>point on cylinder closest to reference point</td></tr>
    <tr><td class="paramname">n</td><td>cylinder normal at reference point</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="proximity_8h_source.html#l00119">119</a> of file <a class="el" href="proximity_8h_source.html">proximity.h</a>.</p>

<p class="reference">References <a class="el" href="fvec_8h_source.html#l00386">dot()</a>, and <a class="el" href="fvec_8h_source.html#l00438">length()</a>.</p>

</div>
</div>
<a id="ac3404ef1e90d66524a348a4cc5b181ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3404ef1e90d66524a348a4cc5b181ae">&#9670;&nbsp;</a></span>closest_point_on_line_to_circle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T cgv::math::closest_point_on_line_to_circle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>ld</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>co</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>cn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>cr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iter_ptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find point on line closest to circle </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>line point</td></tr>
    <tr><td class="paramname">ld</td><td>line direction</td></tr>
    <tr><td class="paramname">co</td><td>circle center</td></tr>
    <tr><td class="paramname">cn</td><td>circle plane normal</td></tr>
    <tr><td class="paramname">cr</td><td>circle radius</td></tr>
    <tr><td class="paramname">q</td><td>point on line closest to circle, if exists</td></tr>
    <tr><td class="paramname">iter_ptr</td><td>pointer to receive iteration count</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return distance to circle or std::numeric_limits&lt;T&gt;::max() is iterative procedure fails</dd></dl>

<p class="definition">Definition at line <a class="el" href="proximity_8h_source.html#l00260">260</a> of file <a class="el" href="proximity_8h_source.html">proximity.h</a>.</p>

<p class="reference">References <a class="el" href="proximity_8h_source.html#l00188">closest_point_on_line_to_point()</a>.</p>

</div>
</div>
<a id="ad84f2ddcc7c3affdf4a7d2b1131c8511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad84f2ddcc7c3affdf4a7d2b1131c8511">&#9670;&nbsp;</a></span>closest_point_on_line_to_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::math::closest_point_on_line_to_line </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>ld</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lo2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>ld2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find point on line closest to second line </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>coordinate type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>point on line</td></tr>
    <tr><td class="paramname">ld</td><td>direction of line</td></tr>
    <tr><td class="paramname">lo2</td><td>point on second line</td></tr>
    <tr><td class="paramname">ld2</td><td>direction of second line</td></tr>
    <tr><td class="paramname">q</td><td>point on line closest to second line if this exists</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns whether closest point exists, what is not the case for parallel lines </dd></dl>

<p class="definition">Definition at line <a class="el" href="proximity_8h_source.html#l00162">162</a> of file <a class="el" href="proximity_8h_source.html">proximity.h</a>.</p>

<p class="reference">References <a class="el" href="fvec_8h_source.html#l00386">dot()</a>.</p>

</div>
</div>
<a id="a0ed179d706cf4cd3f0168caa47569dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed179d706cf4cd3f0168caa47569dff">&#9670;&nbsp;</a></span>closest_point_on_line_to_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt;T, 3&gt; cgv::math::closest_point_on_line_to_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>ld</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find point on line closest to reference point </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>coordinate type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>point on line</td></tr>
    <tr><td class="paramname">ld</td><td>direction of line</td></tr>
    <tr><td class="paramname">p</td><td>reference point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>point on line closest to reference point</dd></dl>

<p class="definition">Definition at line <a class="el" href="proximity_8h_source.html#l00188">188</a> of file <a class="el" href="proximity_8h_source.html">proximity.h</a>.</p>

<p class="reference">References <a class="el" href="fvec_8h_source.html#l00386">dot()</a>.</p>

<p class="reference">Referenced by <a class="el" href="proximity_8h_source.html#l00260">closest_point_on_line_to_circle()</a>.</p>

</div>
</div>
<a id="a3367473071e0f1969635d77dac5b7988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3367473071e0f1969635d77dac5b7988">&#9670;&nbsp;</a></span>closest_point_on_sphere_to_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cgv::math::closest_point_on_sphere_to_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>so</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>sr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find point on sphere closest to reference point </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>coordinate type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">so</td><td>sphere center</td></tr>
    <tr><td class="paramname">sr</td><td>sphere radius</td></tr>
    <tr><td class="paramname">p</td><td>reference point</td></tr>
    <tr><td class="paramname">q</td><td>closest point</td></tr>
    <tr><td class="paramname">n</td><td>normal at closest point</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="proximity_8h_source.html#l00020">20</a> of file <a class="el" href="proximity_8h_source.html">proximity.h</a>.</p>

<p class="reference">References <a class="el" href="fvec_8h_source.html#l00320">normalize()</a>.</p>

</div>
</div>
<a id="a06d82df0891c707f07c81f85eb818690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d82df0891c707f07c81f85eb818690">&#9670;&nbsp;</a></span>compute_rotation_axis_and_angle_from_vector_pair()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cgv::math::compute_rotation_axis_and_angle_from_vector_pair </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">cgv::math::fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">cgv::math::fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcgv_1_1math_1_1fvec.html">cgv::math::fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute a rotation axis and a rotation angle in radian that rotates v0 onto v1. </p>
<p>An alternative solution is given by the negated axis with negated angle. </p>

<p class="definition">Definition at line <a class="el" href="geom_8h_source.html#l00018">18</a> of file <a class="el" href="geom_8h_source.html">geom.h</a>.</p>

<p class="reference">References <a class="el" href="fvec_8h_source.html#l00473">cross()</a>, <a class="el" href="fvec_8h_source.html#l00386">dot()</a>, and <a class="el" href="fvec_8h_source.html#l00244">cgv::math::fvec&lt; T, N &gt;::length()</a>.</p>

<p class="reference">Referenced by <a class="el" href="gl__context_8cxx_source.html#l00748">cgv::render::gl::gl_context::rotate_vector_to_target()</a>.</p>

</div>
</div>
<a id="a2b594665950a0417ea397d6d419fe826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b594665950a0417ea397d6d419fe826">&#9670;&nbsp;</a></span>create_color_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt;T&gt; cgv::math::create_color_map </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>steps</em> = <code>256</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;jet&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>creates different type of color map matrices colors are stored as columns in the resulting matrix the number of columns is defined by the parameter steps colormaps can be chosen by name : possible colormaps are "gray" black . </p>
<p>. white "bone" grayscale colormap with a higher blue component (looks like xray images) "jet" blue .. cyan .. yellow .. orange .. red "hot" black .. red .. yellow .. white "thermo" black .. magenta .. blue.. cyan..green .. yellow ..red.. white "hsv" red .. yellow .. green .. cyan .. blue .. magenta .. red </p>

<p class="definition">Definition at line <a class="el" href="color__operations_8h_source.html#l00024">24</a> of file <a class="el" href="color__operations_8h_source.html">color_operations.h</a>.</p>

<p class="reference">References <a class="el" href="functions_8h_source.html#l00037">map()</a>.</p>

</div>
</div>
<a id="ab5a5bdaef42e636106d43ad1273d6534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a5bdaef42e636106d43ad1273d6534">&#9670;&nbsp;</a></span>decompose_rotation_to_axis_and_angle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int cgv::math::decompose_rotation_to_axis_and_angle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fmat.html">cgv::math::fmat</a>&lt; T, 3, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcgv_1_1math_1_1fvec.html">cgv::math::fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>decompose a rotation matrix into axis angle representation </p>
<p>The implementation assumes that R is orthonormal and that det(R) = 1, thus no reflections are handled. Negation of axis and angle yield another solution. The function returns three possible status values:</p><ul>
<li>0 ... axis and angle where unique up to joined negation</li>
<li>1 ... angle is M_PI can be negated independently of axis yielding another solution</li>
<li>2 ... angle is 0 and axis can be choosen arbitrarily. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="geom_8h_source.html#l00037">37</a> of file <a class="el" href="geom_8h_source.html">geom.h</a>.</p>

<p class="reference">References <a class="el" href="fvec_8h_source.html#l00244">cgv::math::fvec&lt; T, N &gt;::length()</a>, and <a class="el" href="fmat_8h_source.html#l00223">cgv::math::fmat&lt; T, N, M &gt;::trace()</a>.</p>

<p class="reference">Referenced by <a class="el" href="view_8cxx_source.html#l00027">cgv::render::view::compute_axis_and_angle()</a>.</p>

</div>
</div>
<a id="a72df463c830e9334b8903566afb95fb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72df463c830e9334b8903566afb95fb4">&#9670;&nbsp;</a></span>estimate_normal_ls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CGV_API void cgv::math::estimate_normal_ls </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nr_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_evals</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_mean</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_evecs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute least squares normal from an array of 3D points. </p>
<p>Input is the number of points <code>nr_points</code> and a pointer <code>_points</code> to the point array. Points are assumed to be float tripples laying consecutively in the memory. Thus a vector <code>P</code> of type <code>std::vector&lt;cgv::math::fvec&lt;float,3&gt;</code> &gt; can be passed to this function according to estimate_normal_ls(P.size(), &amp;P.front()[0], ...). The resulting 3D normal is written into the memory point to by <code>_normal</code> assuming space for 3 floats. If <code>_evals</code> is specified, also the eigenvalues from the fit are written to 3 floats pointed to by <code>_evals</code>. If <code>_mean</code> is specified, also the point mean through which the least squares plane goes is returned. If <code>_evecs</code> is specified, also the eigenvectors from the fit are written in 3 float trippels to memory pointed to by <code>_evecs</code>. </p>

<p class="definition">Definition at line <a class="el" href="normal__estimation_8cxx_source.html#l00010">10</a> of file <a class="el" href="normal__estimation_8cxx_source.html">normal_estimation.cxx</a>.</p>

<p class="reference">References <a class="el" href="mat_8h_source.html#l00839">cgv::math::mat&lt; T &gt;::col()</a>, <a class="el" href="point__operations_8h_source.html#l00110">covmat()</a>, <a class="el" href="point__operations_8h_source.html#l00230">covmat_and_mean()</a>, <a class="el" href="eig_8h_source.html#l00092">eig_sym()</a>, <a class="el" href="align_8h_source.html#l00014">mean()</a>, <a class="el" href="fvec_8h_source.html#l00320">normalize()</a>, <a class="el" href="vec_8h_source.html#l00232">cgv::math::vec&lt; T &gt;::set_extern_data()</a>, and <a class="el" href="mat_8h_source.html#l00524">cgv::math::mat&lt; T &gt;::set_extern_data()</a>.</p>

</div>
</div>
<a id="a094390494484e1f786fe835c1820d630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a094390494484e1f786fe835c1820d630">&#9670;&nbsp;</a></span>first_ray_sphere_intersection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int cgv::math::first_ray_sphere_intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1ray.html">ray</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>out_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; *&#160;</td>
          <td class="paramname"><em>out_normal</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the first intersection between a ray and sphere and returns the number of intersections. </p>
<p>Differentiates between 0 or 1 intersections. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ray</td><td>the incomming ray. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">center</td><td>the sphere center position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">radius</td><td>the sphere radius. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_ts</td><td>the distances to the intersection points. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_normal</td><td>optional surface normal at the intersection point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of intersections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cgv_2math_2intersection_8h_source.html#l00209">209</a> of file <a class="el" href="cgv_2math_2intersection_8h_source.html">intersection.h</a>.</p>

<p class="reference">References <a class="el" href="fvec_8h_source.html#l00320">normalize()</a>, <a class="el" href="math_2ray_8h_source.html#l00029">cgv::math::ray&lt; T, N &gt;::position()</a>, and <a class="el" href="cgv_2math_2intersection_8h_source.html#l00177">ray_sphere_intersection()</a>.</p>

</div>
</div>
<a id="ab20031ad94f8b2a051428afe3a8ba59d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20031ad94f8b2a051428afe3a8ba59d">&#9670;&nbsp;</a></span>gaussj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::math::gaussj </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gauss-Jordan elimination (A*X=B) with full pivoting: The input matrix a is replaced by its inverse and the right hand side matrix b is replaced by ist corresponding solution matrix x. </p>
<p>Returns false if the matrix is singular. </p>

<p class="definition">Definition at line <a class="el" href="gaussj_8h_source.html#l00015">15</a> of file <a class="el" href="gaussj_8h_source.html">gaussj.h</a>.</p>

<p class="reference">References <a class="el" href="mat_8h_source.html#l00547">cgv::math::mat&lt; T &gt;::ncols()</a>, and <a class="el" href="mat_8h_source.html#l00541">cgv::math::mat&lt; T &gt;::nrows()</a>.</p>

</div>
</div>
<a id="a272db28d4d7d4cc2f6e608c50918a664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272db28d4d7d4cc2f6e608c50918a664">&#9670;&nbsp;</a></span>num_ransac_iterations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned cgv::math::num_ransac_iterations </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>p_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>p_surety</em> = <code>0.99</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the number of needed ransac iterations n_min... </p>
<p>minimal number of needed samples p_out... percentage of inliers p_surety... probability to sample at least one inlier </p>

<p class="definition">Definition at line <a class="el" href="ransac_8h_source.html#l00015">15</a> of file <a class="el" href="ransac_8h_source.html">ransac.h</a>.</p>

<p class="reference">References <a class="el" href="fvec_8h_source.html#l00462">ceil()</a>, and <a class="el" href="fvec_8h_source.html#l00614">pow()</a>.</p>

<p class="reference">Referenced by <a class="el" href="math_2plane_8h_source.html#l00092">ransac_plane_fit()</a>.</p>

</div>
</div>
<a id="a6fa33183d42422e47e25d8c55bbc9faa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa33183d42422e47e25d8c55bbc9faa">&#9670;&nbsp;</a></span>plane_val()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T cgv::math::plane_val </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A plane is defined as a vector (a,b,c,d) =&gt; a*x1 + b*x2 +c*x3 +d = 0. </p>
<p>evaluate implicit plane equation at x =(x1,x2,x3) return value should be zero on plane </p>

<p class="definition">Definition at line <a class="el" href="math_2plane_8h_source.html#l00018">18</a> of file <a class="el" href="math_2plane_8h_source.html">plane.h</a>.</p>

<p class="reference">References <a class="el" href="vec_8h_source.html#l00097">cgv::math::vec&lt; T &gt;::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="math_2plane_8h_source.html#l00032">plane_val()</a>, and <a class="el" href="math_2plane_8h_source.html#l00092">ransac_plane_fit()</a>.</p>

</div>
</div>
<a id="a9f72457452fa12679ad840de7b06df1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f72457452fa12679ad840de7b06df1c">&#9670;&nbsp;</a></span>poly_val() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T cgv::math::poly_val </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>polynomials are stored in vectors in the following order: [a,b,c,d] ...a*x^3 + b*x^2 + c*x + d </p>
<p>evaluate a polynomial p at x p is the vector of length n+1 whose elements are the coefficients of the polynomial in descending powers. evaluation is done by using the horner scheme </p>

<p class="definition">Definition at line <a class="el" href="polynomial_8h_source.html#l00026">26</a> of file <a class="el" href="polynomial_8h_source.html">polynomial.h</a>.</p>

<p class="reference">References <a class="el" href="vec_8h_source.html#l00097">cgv::math::vec&lt; T &gt;::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bi__polynomial_8h_source.html#l00020">bipoly_val()</a>.</p>

</div>
</div>
<a id="a556f6aef31de955ddca54cf92650b5f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a556f6aef31de955ddca54cf92650b5f4">&#9670;&nbsp;</a></span>poly_val() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt;T&gt; cgv::math::poly_val </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate a polynomial p at multiple positions x p is the vector of length n+1 whose elements are the coefficients of the polynomial in descending powers. </p>
<p>evaluation is done by using the horner scheme </p>

<p class="definition">Definition at line <a class="el" href="polynomial_8h_source.html#l00042">42</a> of file <a class="el" href="polynomial_8h_source.html">polynomial.h</a>.</p>

<p class="reference">References <a class="el" href="vec_8h_source.html#l00524">cgv::math::vec&lt; T &gt;::fill()</a>, and <a class="el" href="vec_8h_source.html#l00097">cgv::math::vec&lt; T &gt;::size()</a>.</p>

</div>
</div>
<a id="a980c68f5c243fa1a32c157ff23041952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a980c68f5c243fa1a32c157ff23041952">&#9670;&nbsp;</a></span>ransac_plane_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt;T&gt; cgv::math::ransac_plane_fit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>p_out</em> = <code>0.8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>d_max</em> = <code>0.001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>p_surety</em> = <code>0.99</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>msac</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ransac plane fit p_out... </p>
<p>outlier prob d_max... threshold distance p_surety... surety to compute number needed samples if m_sac flag is true m-estimator cost function is used if loransac flag is true <br  />
 </p>

<p class="definition">Definition at line <a class="el" href="math_2plane_8h_source.html#l00092">92</a> of file <a class="el" href="math_2plane_8h_source.html">plane.h</a>.</p>

<p class="reference">References <a class="el" href="fvec_8h_source.html#l00462">ceil()</a>, <a class="el" href="mat_8h_source.html#l00839">cgv::math::mat&lt; T &gt;::col()</a>, <a class="el" href="fvec_8h_source.html#l00473">cross()</a>, <a class="el" href="fvec_8h_source.html#l00438">length()</a>, <a class="el" href="mat_8h_source.html#l00547">cgv::math::mat&lt; T &gt;::ncols()</a>, <a class="el" href="mat_8h_source.html#l00541">cgv::math::mat&lt; T &gt;::nrows()</a>, <a class="el" href="ransac_8h_source.html#l00015">num_ransac_iterations()</a>, <a class="el" href="math_2plane_8h_source.html#l00018">plane_val()</a>, <a class="el" href="mat_8h_source.html#l00852">cgv::math::mat&lt; T &gt;::set_col()</a>, and <a class="el" href="random_8h_source.html#l00547">cgv::math::random::uniform_nchoosek()</a>.</p>

</div>
</div>
<a id="ab082b1f85d6c8a0223d62a0d5491da15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab082b1f85d6c8a0223d62a0d5491da15">&#9670;&nbsp;</a></span>ray_box_intersection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int cgv::math::ray_box_intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1ray.html">ray</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_ts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the intersection between a ray and axis aligned box and returns the number of intersections. </p>
<p>Differentiates between 0 or 2 intersections.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the numeric type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ray</td><td>the incomming ray. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min</td><td>the minimum box point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>the maximum box point. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_ts</td><td>the distances to the intersection points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of intersections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cgv_2math_2intersection_8h_source.html#l00057">57</a> of file <a class="el" href="cgv_2math_2intersection_8h_source.html">intersection.h</a>.</p>

<p class="reference">References <a class="el" href="fvec_8h_source.html#l00571">max()</a>, <a class="el" href="fvec_8h_source.html#l00553">min()</a>, <a class="el" href="fvec_8h_source.html#l00154">cgv::math::fvec&lt; T, N &gt;::x()</a>, <a class="el" href="fvec_8h_source.html#l00158">cgv::math::fvec&lt; T, N &gt;::y()</a>, and <a class="el" href="fvec_8h_source.html#l00162">cgv::math::fvec&lt; T, N &gt;::z()</a>.</p>

</div>
</div>
<a id="ad0233918261c3cf7f8a433e3e6511f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0233918261c3cf7f8a433e3e6511f10">&#9670;&nbsp;</a></span>ray_box_intersection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int cgv::math::ray_box_intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1ray.html">ray</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt;&#160;</td>
          <td class="paramname"><em>extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; *&#160;</td>
          <td class="paramname"><em>out_normal</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the intersection between a ray and axis aligned box located at the origin and returns the number of intersections. </p>
<p>Differentiates between 0 or 2 intersections.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the numeric type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ray</td><td>the incomming ray. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">extent</td><td>the total box extent/size. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_ts</td><td>the distances to the intersection points. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_normal</td><td>optional surface normal at the first intersection point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of intersections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cgv_2math_2intersection_8h_source.html#l00023">23</a> of file <a class="el" href="cgv_2math_2intersection_8h_source.html">intersection.h</a>.</p>

<p class="reference">References <a class="el" href="fvec_8h_source.html#l00450">abs()</a>, <a class="el" href="functions_8h_source.html#l00015">sign()</a>, <a class="el" href="functions_8h_source.html#l00018">step()</a>, <a class="el" href="fvec_8h_source.html#l00154">cgv::math::fvec&lt; T, N &gt;::x()</a>, <a class="el" href="fvec_8h_source.html#l00158">cgv::math::fvec&lt; T, N &gt;::y()</a>, and <a class="el" href="fvec_8h_source.html#l00162">cgv::math::fvec&lt; T, N &gt;::z()</a>.</p>

</div>
</div>
<a id="acb95bc20c76e28a4f330fbc4459cb5b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb95bc20c76e28a4f330fbc4459cb5b1">&#9670;&nbsp;</a></span>ray_cylinder_intersection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int cgv::math::ray_cylinder_intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1ray.html">ray</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>out_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; *&#160;</td>
          <td class="paramname"><em>out_normal</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the intersection between a ray and oriented cylinder defined by base center and axis and returns the number of intersections. </p>
<p>Differentiates between 0 or 1 intersections.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the numeric type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ray</td><td>the incomming ray. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>the cylinder center position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axis</td><td>the cylinder main axis and length. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">radius</td><td>the cylinder base radius. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_t</td><td>the distance to the intersection point. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_normal</td><td>optional surface normal at the intersection point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of intersections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cgv_2math_2intersection_8h_source.html#l00100">100</a> of file <a class="el" href="cgv_2math_2intersection_8h_source.html">intersection.h</a>.</p>

<p class="reference">References <a class="el" href="fvec_8h_source.html#l00386">dot()</a>, and <a class="el" href="functions_8h_source.html#l00015">sign()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cgv_2math_2intersection_8h_source.html#l00146">ray_cylinder_intersection2()</a>.</p>

</div>
</div>
<a id="a0b29101809f91572afdfb3349c7fa943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b29101809f91572afdfb3349c7fa943">&#9670;&nbsp;</a></span>ray_cylinder_intersection2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int cgv::math::ray_cylinder_intersection2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1ray.html">ray</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>start_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>end_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>out_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; *&#160;</td>
          <td class="paramname"><em>out_normal</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the intersection between a ray and oriented cylinder defined by start and end position and returns the number of intersections. </p>
<p>Differentiates between 0 or 1 intersections. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ray</td><td>the incomming ray. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_position</td><td>the cylinder base center position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_position</td><td>the cylinder top center position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">radius</td><td>the cylinder radius. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_t</td><td>the distance to the intersection point. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_normal</td><td>optional surface normal at the intersection point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of intersections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cgv_2math_2intersection_8h_source.html#l00146">146</a> of file <a class="el" href="cgv_2math_2intersection_8h_source.html">intersection.h</a>.</p>

<p class="reference">References <a class="el" href="cgv_2math_2intersection_8h_source.html#l00100">ray_cylinder_intersection()</a>.</p>

</div>
</div>
<a id="ac940672f781e5135fdde91c8e1ac3043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac940672f781e5135fdde91c8e1ac3043">&#9670;&nbsp;</a></span>ray_plane_intersection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int cgv::math::ray_plane_intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1ray.html">ray</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>out_t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the intersection between a ray and infinite plane and returns the number of intersections. </p>
<p>Differentiates between 0 or 1 intersections. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ray</td><td>the incomming ray. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">origin</td><td>the plane origin position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normal</td><td>the plane surface normal. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_t</td><td>the distance to the intersection point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of intersections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cgv_2math_2intersection_8h_source.html#l00159">159</a> of file <a class="el" href="cgv_2math_2intersection_8h_source.html">intersection.h</a>.</p>

<p class="reference">References <a class="el" href="fvec_8h_source.html#l00386">dot()</a>.</p>

</div>
</div>
<a id="a2b9d4d1815a621c4a3b7d3632671d524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b9d4d1815a621c4a3b7d3632671d524">&#9670;&nbsp;</a></span>ray_sphere_intersection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int cgv::math::ray_sphere_intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1ray.html">ray</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_ts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the intersection between a ray and sphere and returns the number of intersections. </p>
<p>Differentiates between 0, 1 or 2 intersections. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ray</td><td>the incomming ray. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">center</td><td>the sphere center position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">radius</td><td>the sphere radius. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_ts</td><td>the distances to the intersection points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of intersections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cgv_2math_2intersection_8h_source.html#l00177">177</a> of file <a class="el" href="cgv_2math_2intersection_8h_source.html">intersection.h</a>.</p>

<p class="reference">References <a class="el" href="fvec_8h_source.html#l00386">dot()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cgv_2math_2intersection_8h_source.html#l00209">first_ray_sphere_intersection()</a>.</p>

</div>
</div>
<a id="a7ddd4907f3139db3c3a62b74202d3241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ddd4907f3139db3c3a62b74202d3241">&#9670;&nbsp;</a></span>ray_torus_intersection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int cgv::math::ray_torus_intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1ray.html">ray</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>large_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>small_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>out_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; *&#160;</td>
          <td class="paramname"><em>out_normal</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the intersection between a ray and oriented torus defined by origin and medial axis and returns the number of intersections. </p>
<p>Differentiates between 0 or 1 intersections. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ray</td><td>the incomming ray. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">center</td><td>the torus center position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normal</td><td>the torus medial axis direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">large_radius</td><td>the torus ring radius (R). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">small_radius</td><td>the radial torus tube radius (r). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_t</td><td>the distance to the intersection point. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_normal</td><td>optional surface normal at the intersection point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of intersections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cgv_2math_2intersection_8h_source.html#l00331">331</a> of file <a class="el" href="cgv_2math_2intersection_8h_source.html">intersection.h</a>.</p>

<p class="reference">References <a class="el" href="fvec_8h_source.html#l00473">cross()</a>, <a class="el" href="pose_8h_source.html#l00033">inverse_pose_transform_point()</a>, <a class="el" href="pose_8h_source.html#l00036">inverse_pose_transform_vector()</a>, <a class="el" href="fvec_8h_source.html#l00320">normalize()</a>, <a class="el" href="pose_8h_source.html#l00019">pose_position()</a>, <a class="el" href="pose_8h_source.html#l00030">pose_transform_vector()</a>, and <a class="el" href="cgv_2math_2intersection_8h_source.html#l00236">ray_torus_intersection()</a>.</p>

</div>
</div>
<a id="ab2d772c970e1107e36343bb3caf57165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d772c970e1107e36343bb3caf57165">&#9670;&nbsp;</a></span>ray_torus_intersection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int cgv::math::ray_torus_intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1ray.html">ray</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>large_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>small_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>out_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcgv_1_1math_1_1fvec.html">fvec</a>&lt; T, 3 &gt; *&#160;</td>
          <td class="paramname"><em>out_normal</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the intersection between a ray and axis aligned torus with medial axis equal to the y-axis and returns the number of intersections. </p>
<p>Differentiates between 0 or 1 intersections. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ray</td><td>the incomming ray. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">large_radius</td><td>the torus ring radius (R). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">small_radius</td><td>the radial torus tube radius (r). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_t</td><td>the distance to the intersection point. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_normal</td><td>optional surface normal at the intersection point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of intersections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cgv_2math_2intersection_8h_source.html#l00236">236</a> of file <a class="el" href="cgv_2math_2intersection_8h_source.html">intersection.h</a>.</p>

<p class="reference">References <a class="el" href="fvec_8h_source.html#l00386">dot()</a>, <a class="el" href="fvec_8h_source.html#l00438">length()</a>, <a class="el" href="fvec_8h_source.html#l00320">normalize()</a>, <a class="el" href="math_2ray_8h_source.html#l00029">cgv::math::ray&lt; T, N &gt;::position()</a>, <a class="el" href="functions_8h_source.html#l00015">sign()</a>, <a class="el" href="fvec_8h_source.html#l00154">cgv::math::fvec&lt; T, N &gt;::x()</a>, and <a class="el" href="fvec_8h_source.html#l00158">cgv::math::fvec&lt; T, N &gt;::y()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cgv_2math_2intersection_8h_source.html#l00331">ray_torus_intersection()</a>.</p>

</div>
</div>
<a id="ad952cb09accb18e3535e7aeb6c8a5957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad952cb09accb18e3535e7aeb6c8a5957">&#9670;&nbsp;</a></span>rotate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcgv_1_1math_1_1fvec.html">cgv::math::fvec</a>&lt;T, 3&gt; cgv::math::rotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">cgv::math::fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1fvec.html">cgv::math::fvec</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>rotate vector v around axis n by angle a (given in radian) </p>
<p>the cos and sin functions need to be implemented for type T. </p>

<p class="definition">Definition at line <a class="el" href="geom_8h_source.html#l00010">10</a> of file <a class="el" href="geom_8h_source.html">geom.h</a>.</p>

<p class="reference">References <a class="el" href="fvec_8h_source.html#l00473">cross()</a>, and <a class="el" href="fvec_8h_source.html#l00386">dot()</a>.</p>

<p class="reference">Referenced by <a class="el" href="view_8cxx_source.html#l00231">cgv::render::view::roll()</a>, and <a class="el" href="view_8cxx_source.html#l00242">cgv::render::view::rotate()</a>.</p>

</div>
</div>
<a id="a10dff5b4a5e3e3f3727272dc9b129be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10dff5b4a5e3e3f3727272dc9b129be5">&#9670;&nbsp;</a></span>select_median_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T cgv::math::select_median_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the value of values the input vector arr will be rearanged to have this value in location arr[k], with all smaller elements moved to values[0..k-1] (in arbitrary order) and all larger elements in values[k+1..n] (also in arbitrary order). </p>
<p>if the number of components are even then the ceil((n+1)/2) entry is returned </p>

<p class="definition">Definition at line <a class="el" href="vec_8h_source.html#l01137">1137</a> of file <a class="el" href="vec_8h_source.html">vec.h</a>.</p>

<p class="reference">References <a class="el" href="vec_8h_source.html#l01121">select_value()</a>, and <a class="el" href="vec_8h_source.html#l00097">cgv::math::vec&lt; T &gt;::size()</a>.</p>

</div>
</div>
<a id="a0d9115b6999049fb851dc6da02c0ca31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d9115b6999049fb851dc6da02c0ca31">&#9670;&nbsp;</a></span>select_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T cgv::math::select_value </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the kth-smallest value of values the input vector values will be rearranged to have this value in location arr[k], with all smaller elements moved to values[0..k-1] (in arbitrary order) and all larger elements in values[k+1..n] (also in arbitrary order). </p>
<p><br  />
 </p>

<p class="definition">Definition at line <a class="el" href="vec_8h_source.html#l01121">1121</a> of file <a class="el" href="vec_8h_source.html">vec.h</a>.</p>

<p class="reference">References <a class="el" href="vec_8h_source.html#l00097">cgv::math::vec&lt; T &gt;::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="vec_8h_source.html#l01146">median_value()</a>, and <a class="el" href="vec_8h_source.html#l01137">select_median_value()</a>.</p>

</div>
</div>
<a id="aa0f80cfa8700f246807ae76fa63bbc1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0f80cfa8700f246807ae76fa63bbc1e">&#9670;&nbsp;</a></span>sphere_val()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T cgv::math::sphere_val </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A sphere is defined as a vector (a,b,c,r) =&gt; center (a,b,c) and radius r. </p>
<p>evaluate implicit sphere equation at x =(x1,x2,x3) returns signed dist <br  />
 </p>

<p class="definition">Definition at line <a class="el" href="math_2sphere_8h_source.html#l00020">20</a> of file <a class="el" href="math_2sphere_8h_source.html">sphere.h</a>.</p>

<p class="reference">References <a class="el" href="vec_8h_source.html#l00097">cgv::math::vec&lt; T &gt;::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="math_2sphere_8h_source.html#l00035">sphere_val()</a>.</p>

</div>
</div>
<a id="a1a12451076df1957fe4247589887704d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a12451076df1957fe4247589887704d">&#9670;&nbsp;</a></span>sqrdist_transf_1d()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cgv::math::sqrdist_transf_1d </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcgv_1_1math_1_1vec.html">vec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of 1d and 2d linear time distance transformation see: "Distance Transforms of Sampled Functions Pedro F. </p>
<p>Felzenszwalb and Daniel P. Huttenlocher" for details. </p>

<p class="definition">Definition at line <a class="el" href="distance__transform_8h_source.html#l00020">20</a> of file <a class="el" href="distance__transform_8h_source.html">distance_transform.h</a>.</p>

<p class="reference">References <a class="el" href="vec_8h_source.html#l00557">cgv::math::vec&lt; T &gt;::resize()</a>, and <a class="el" href="vec_8h_source.html#l00097">cgv::math::vec&lt; T &gt;::size()</a>.</p>

</div>
</div>
<a id="ab6a005510b7ffa2c6a772d826ba2c164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6a005510b7ffa2c6a772d826ba2c164">&#9670;&nbsp;</a></span>svd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::math::svd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcgv_1_1math_1_1diag__mat.html">diag_mat</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcgv_1_1math_1_1mat.html">mat</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ordering</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxiter</em> = <code>30</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the singular value decomposition of an MxN matrix a = u* w * v^t where u is an MxN matrix, w is a diagonal NxN matrix and v is a NxN square matrix. </p>
<p>If the algorithm can't achieve a convergence after 20 iteration false is returned other wise true. The resulting matrices are stored in the parameters u,w,v. Attention: v is returned not v^T ! So to compute the original matrix a from the decomposed matrices you have to multiply u*w*transpose(v). It is possible to store u directly into a to save memory, just put the same reference into a and u. If ordering is true the singular values are sorted in descending order. To ensure that u*w*v^t remains equal to the matrix a the algorithm also exchanges the columns of u and v. <br  />
 </p>

<p class="definition">Definition at line <a class="el" href="svd_8h_source.html#l00029">29</a> of file <a class="el" href="svd_8h_source.html">svd.h</a>.</p>

<p class="reference">References <a class="el" href="mat_8h_source.html#l00547">cgv::math::mat&lt; T &gt;::ncols()</a>, <a class="el" href="mat_8h_source.html#l00541">cgv::math::mat&lt; T &gt;::nrows()</a>, <a class="el" href="mat_8h_source.html#l00575">cgv::math::mat&lt; T &gt;::resize()</a>, and <a class="el" href="functions_8h_source.html#l00015">sign()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecgv.html">cgv</a></li><li class="navelem"><a class="el" href="namespacecgv_1_1math.html">math</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
